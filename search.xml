<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>發展心理學筆記-L10</title>
      <link href="/2025/05/05/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/"/>
      <url>/2025/05/05/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/</url>
      
        <content type="html"><![CDATA[<h1>L10 Becoming an Adult: Physical, Cognitive, and Personality Development in Young Adultho</h1><h2 id="emerging-adulthood">Emerging Adulthood</h2><h3 id="definition">Definition</h3><ul><li>True adulthood<ul><li>民法成年年齡 <code>18 歲</code></li></ul></li><li>Emerging adulthood<ul><li>the period between late-teens and mid- to late-20s when individuals are not adolescents but are not yet fully adults</li><li>探索職業、自我認同</li></ul></li></ul><h3 id="role-transitions">Role Transitions</h3><ul><li>Rites (儀式) of passage<ul><li>Rituals marking initiation into adulthood<ul><li>Especially common in developing countries</li><li>Involve special dress; sometimes involve religion</li></ul></li><li>marriage is most important in most cultures</li></ul></li><li>Role transitions<ul><li>承擔責任</li><li>投票、結婚、工作…</li></ul></li></ul><h3 id="behavioral-change">Behavioral Change</h3><p>減少有風險的行為</p><ul><li>Less risky<ul><li>decrease their engagement in risky behaviors/edgework</li></ul></li><li>Prefrontal cortex 前額葉皮層<ul><li><code>mid-20’</code> 完全開發</li></ul></li><li>Poverty<ul><li>風險行為與貧困有關聯</li></ul></li></ul><h3 id="behavioral-changes-erikson-s-theo">Behavioral Changes &amp; Erikson’s theo</h3><ul><li>intimacy vs. isolation<ul><li>Having a self-identity allows a young person to become intimate with another</li></ul></li><li>Conflicting evidence<ul><li>該理論只有部分正確</li></ul></li></ul><h3 id="financial-independence">Financial Independence</h3><ul><li>不上大學的年輕人經常比其他人更早就變得獨立</li><li>獨居會加速獨立的過程</li><li>推遲經濟獨立<ul><li>大學畢業後搬回家居住的比例增加</li></ul></li></ul><h2 id="physical-development-and-health">Physical Development and Health</h2><h3 id="growth-strength-and-physical-functioning-peak">Growth, Strength, and Physical Functioning Peak</h3><p>各種能力的巔峰</p><ul><li>體力，協調和敏捷 - late 20s ~ early 30s</li><li>感官敏銳度 - early 20s</li><li>視力 - remains high until middle age</li><li>聽力 -  decline by the late-20s, especially for high-pitched tones</li></ul><h3 id="lifestyle-factors">Lifestyle Factors</h3><ul><li>smoking</li><li>drink alcohol</li><li>nutrition</li></ul><h3 id="social-gender-and-ethnic-issues-in-health">Social, Gender, and Ethnic Issues in Health</h3><ul><li>社會經濟地位<ul><li>是否擁有良好的保險和醫療保健</li></ul></li><li>教育<ul><li>健康的生活方式並避免疾病</li><li>教育不會造成良好的健康，但是受過教育的人了解如何更好地照顧自己的健康</li></ul></li><li>性別差異<ul><li>ex: 某些文化中的婦女不允許獨自去診所</li></ul></li></ul><h2 id="cognitive-development">Cognitive Development</h2><h3 id="intelligence-in-adults">Intelligence in Adults</h3><ul><li>Multidimensionality 多維性<ul><li>擁有多種類型的智力能力</li></ul></li><li>Multidirectionality 多向性<ul><li>智力的某些面向成長了，某些面向則下降</li><li>每個人在不同面向的能力也不同 - <code>interindividual variability 個體差異</code></li></ul></li><li>Plasticity 可塑性<ul><li>能力可以在任何時間點在正確的條件下改變</li></ul></li></ul><h3 id="primary-and-secondary-mental-abilities">Primary and Secondary Mental Abilities</h3><ul><li>Primary mental abilities<ul><li>相關的智力技能<ul><li>ex: 記憶力、空間能力</li></ul></li><li>Seattle Longitudinal Study: 言語含義、空間取向、歸納推理、數字和單詞流利度</li></ul></li><li>Secondary mental abilities<ul><li>將 <code>Primary mental abilities</code> 歸納整合成六大類</li></ul></li></ul><h3 id="fluid-and-crystallized-intelligence">Fluid and Crystallized Intelligence</h3><ul><li><code>Fluid intelligence 液態智力</code><ul><li>邏輯推理與抽象思考的能力</li><li>年輕時達到巔峰，隨年齡逐漸下降</li></ul></li><li><code>Crystallized intelligenc 結晶智力</code><ul><li>透過學習與經驗所累積的知識與技能</li><li>隨年齡逐漸累績上升</li></ul></li></ul><img src="/2025/05/05/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/Intelligence.png" class="" title="Intelligence"><h3 id="neuroscience-research">Neuroscience Research</h3><ul><li>大腦內部的特殊區域與智力能力有關，這些區域的發展變化與能力變化有關</li><li>Parietofrontal integration theory (P-FIT)<ul><li>智力來自於分布在 <code>頂葉與額葉 (parietal and frontal lobes)</code> 的神經網路之整合運作</li><li>個體之間在大腦結構與功能上的差異，造成了智力上的差異</li></ul></li></ul><h3 id="reflective-judgment">Reflective judgment</h3><p>King and Kitchener. (1994). <code>The Reflective Judgment Model</code></p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>The Reflective Judgment Model</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Stages 1-3: prereflective thought 前反思思維</p></div></div><div class='timeline-item-content'><ul><li>不認為知識有不確定性</li><li>認為每個問題都有正確的答案</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Stages 4-5: quasi-reflective thinking 類反思思維</p></div></div><div class='timeline-item-content'><ul><li>認為知識是主觀的</li><li>真理是相對的，是每個人的意見</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Stages 6-7: true reflective judgme 反思思維</p></div></div><div class='timeline-item-content'><ul><li>評估問題時，會結合證據與論證進行分析</li><li><code>真理</code> 取決於證據與推論證的品質</li></ul></div></div></div><h2 id="who-do-you-want-to-be-personality-in-young-adulthood-family-relationships">Who Do You Want to Be? Personality in Young Adulthood Family Relationships</h2><h3 id="possible-selves">Possible Selves</h3><ul><li>representations of what we could become, what we would like to become, and what we are afraid of becoming</li><li>可能的類別: 家庭、個人、物質、人際關係和職業</li><li>Age differences in hoped-for selves<ul><li>Young adults (20s) concerned with family (與婚姻相關)</li><li>Adults in their 30s concerned with personal issues (自我成長)</li><li>Family issues the focus again in ages 40-59<ul><li>放孩子自由</li><li>接受中年的生理變化</li></ul></li><li>Personal concerns more prominent for 60+ (健康問題)</li></ul></li></ul><h3 id="personal-control-beliefs">Personal Control Beliefs</h3><p>一個人對於自己能否控制生活事件與結果的信念與期待</p><ul><li>成功的人通常擁有較高的 <code>sense of personal control</code></li><li><code>personal control</code> 的發展，會依情境背景而有所不同</li><li>分類<ul><li>Primary control<ul><li>透過行為來改變外在世界</li><li>與 <code>生物性(biological factors)</code> 有較大關聯 (老年時期會衰減)</li><li>ex: 獲取第二份工作以增加收入</li></ul></li><li>Secondary control<ul><li>改變內在的認知或行為來適應外在情況</li><li>ex: 認為即使面臨挑戰，也能夠成功的信念</li></ul></li></ul></li></ul><img src="/2025/05/05/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/Personal-Contro.png" class="" title="Personal-Contro">]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L9</title>
      <link href="/2025/04/21/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/"/>
      <url>/2025/04/21/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/</url>
      
        <content type="html"><![CDATA[<h1>L9 Moving into the Adult Social World: Socioemotional Development in Adolescence</h1><h2 id="identity-and-self-esteem">Identity and Self-Esteem</h2><h3 id="the-search-for-identity">The Search for Identity</h3><img src="/2025/04/21/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/Identity.png" class="" title="Identity"><table><thead><tr><th></th><th>有尋找認同</th><th>無尋找認同</th></tr></thead><tbody><tr><td>找到認同</td><td>認同達成</td><td>認同早閉</td></tr><tr><td>沒有找到認同</td><td>認同未定</td><td>認同迷失</td></tr></tbody></table><h3 id="characteristic-ways-of-thinking-during-identity-search">Characteristic ways of thinking during identity search</h3><ul><li><code>Adolescent egocentrism 青少年自我中心</code> - 只專注於自己的感覺與經歷<ul><li>imaginary audience 想像觀眾 - 相信同伴一直在看著他們</li><li>Personal fable 個人神話寓言 - 相信他們自己的經歷和感受是獨一無二的</li><li>Illusion of invulnerability 無懈可擊的錯覺 - 相信不幸只會發生在別人身上</li></ul></li><li>找到認同之後，這些自我中心的想法會逐漸消失</li></ul><h3 id="who-what-helps-teens-form-identities">Who/What helps teens form identities?</h3><ul><li>Parents - 開放討論並允許孩子探索不同的選擇</li><li>Peers - 親密、值得信賴的朋友</li><li>Broader social context - 貧困的侷限性</li><li>Personality - 經驗的開放性</li></ul><h3 id="ethnic-identity-種族認同">Ethnic Identity 種族認同</h3><p>Typically three phases in achieving an ethnic identity:</p><ul><li>Initially, no examination of ethnic roots</li><li>Explore the personal impact of one’s cultural heritage</li><li>Achieve a distinct ethnic self-concept</li></ul><p>Benefits of a strong ethnic identity:</p><ul><li>更高的自尊心</li><li>與家人和朋友更愉快的互動</li><li>在學校的表現更好</li></ul><h2 id="romantic-relationships-and-sexuality">Romantic Relationships and Sexuality</h2><h3 id="romantic-relationships">Romantic Relationships</h3><ul><li>以友情為基礎建立<ul><li>發生在受歡迎程度和物理吸引力類似的人之間</li><li>隨著青少年的發展，信任和同情在人際關係中變得越來越重要</li></ul></li><li>關係之中的青少年通常會<code>更有自信</code></li><li>可能會有更多的情感衝突</li></ul><h3 id="sexual-behavior">Sexual Behavior</h3><ul><li>男女差異<ul><li>男生 - 更多視為娛樂</li><li>女生 - 更多視為愛與浪漫的表達</li></ul></li><li>Teen Pregnancy<ul><li>美國未成年懷孕率比台灣高<ul><li>沒有使用避孕方法</li><li>使用無效的避孕方法</li></ul></li><li>降低未成年懷孕數量<ul><li>完善的性教育</li></ul></li></ul></li></ul><h3 id="sexual-orientation">Sexual Orientation</h3><ul><li>Approx. 15% of teens question their sexual and emotional attraction<br>at some period<ul><li>Approx. 5% end up identifying as gay or lesbian</li><li>男生通常比女生早發現自己是同性戀者</li></ul></li><li>同性戀者在青年時期可能會有心理健康問題</li></ul><h3 id="dating-violence">Dating Violence</h3><ul><li>Approx. 25% of teens experience physical, emotional, and/or sexual violence while dating<ul><li>可能造成學業或行為問題</li></ul></li><li>Risk factors:<ul><li>父母行為、同伴行為</li><li>態度與個性</li></ul></li></ul><h2 id="the-world-of-work">The World of Work</h2><h3 id="career-development">Career Development</h3><p>經歷三個階段：</p><ul><li>Crystallization (13 - 14)<ul><li>teens use their emerging identities to form ideas about careers</li></ul></li><li>Specification (~18)<ul><li>learn more about specific lines of work and begin training</li></ul></li><li>Implementation<ul><li>enter workforce and learn first-hand from jobs</li></ul></li></ul><p>相關理論：</p><ul><li>Super’s theory - <code>自我認同(identity)</code> 是職業發展的主要推動力 (會隨時間改變)<ul><li>does not explain why people are attracted to certain kinds of work</li></ul></li><li>Personality-type theory - 職業選擇是<code>人格</code>的表現<ul><li>當一個人的人格特質和工作環境相同時，就會感到<code>滿足、成功且穩定</code></li><li>by John Holland</li><li><img src="/2025/04/21/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/Personality.png" class="" title="Personality"></li></ul></li></ul><h3 id="career-development-satisfaction">Career Development Satisfaction</h3><ul><li>Personalities</li><li>Other factors:<ul><li>Pay</li><li>workplace <code>stress</code></li><li>work-family balance</li><li>etc.</li></ul></li></ul><h3 id="part-time-employment">Part-Time Employment</h3><ul><li>缺點：<ul><li>長時間工作可能導致學業表現不佳</li><li>壓力過大的工作可能造成心理健康與行為問題<ul><li>降低自尊心、焦慮</li></ul></li><li>Misleading affluence (誤導性的富裕)<ul><li>把打工賺到的錢花在自己身上 (娛樂、奢侈品…)</li></ul></li></ul></li></ul><h2 id="the-dark-side">The Dark Side</h2><h3 id="alcohol">Alcohol</h3><ul><li>大多數美國青少年都承認使用酒精<ul><li>受父母影響</li><li>生活壓力</li><li>受同儕影響</li></ul></li></ul><h3 id="smoking-cigarettes">Smoking cigarettes</h3><ul><li>容易受到同儕影響</li><li>School-based programs<ul><li>教導抽菸會造成的影響</li><li>教導如何拒絕同儕的壓力</li></ul></li></ul><h3 id="depression">Depression</h3><ul><li>表徵：<ul><li>悲傷</li><li>易怒</li><li>低自尊</li></ul></li><li>約15%的青少年，且女生較多</li><li>原因通常是因為重大的損失或失敗<ul><li>ex: death of a family member or a terrible date</li></ul></li></ul><h3 id="why-do-only-some-teens-become-depression">Why do only some teens become depression</h3><ul><li>Temperament<ul><li>調節情緒困難的人更容易抑鬱</li></ul></li><li>A belief system<ul><li><code>internalizes failure 失敗內部化</code> - 將失敗認為是自己的特質</li></ul></li><li>Family<ul><li>情感疏離的父母</li><li>過度懲罰的父母</li><li>家庭壓力大</li></ul></li><li>Heredity 遺傳<ul><li>神經傳導物質水平較低</li></ul></li></ul><h3 id="depression-treatment">Depression Treatment</h3><ul><li>Antidepressant drugs 抗抑鬱藥<ul><li>僅適用於某些青少年 (不是永久解決方案)</li></ul></li><li>Psychotherapy 心理治療<ul><li>對青少年來說較好</li><li>強調認知與社交技能</li></ul></li></ul><p>如果沒有得到妥善的治療可能導致：</p><ul><li>學業表現不佳</li><li>人際關係困難</li><li>成年後的抑鬱症</li></ul><h3 id="delinquency-犯罪">Delinquency 犯罪</h3><ul><li>分類<ul><li>Adolescent-limited antisocial behavior 青少年反社會行為<ul><li>行為通常比較輕微</li></ul></li><li>Life-course persistent antisocial behavior 終生反社會行為<ul><li>從年紀較小時開始，並持續一生</li><li>5% 的青少年</li><li>大部分青少年犯罪問題的原因</li></ul></li></ul></li><li>原因<ul><li>遺傳 - 天生攻擊性較高</li><li>認知技能 - 將別人的行為認為是有敵意的</li><li>衝動</li><li>家庭教養 - 過度包容 or 嚴厲</li><li>貧困</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L8</title>
      <link href="/2025/04/14/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/"/>
      <url>/2025/04/14/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/</url>
      
        <content type="html"><![CDATA[<h1>L8 Rites of Passage: Physical and Cognitive Development During Adolescence</h1><h2 id="pubertal-changes">Pubertal Changes</h2><h3 id="signs-of-physical-maturation">Signs of Physical Maturation</h3><ul><li>身體快速成長 &amp; 性成熟 (睪丸與乳房)。</li><li>通常女生發育較早(11)，男生較晚(13)。</li><li>青春期後男生通常會有較好的力量、速度與耐力。</li><li>肌肉質量/脂肪含量增加，骨骼成長，增加心肺耐力。</li></ul><img src="/2025/04/14/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/Puberty.png" class="" title="Puberty"><ul><li>Limbic system:  reward and pleasure-seeking centers</li><li>Frontal system: behavioral control systems</li><li><code>Limbic system</code> 發展的速度比 <code>Frontal system</code> 快。</li></ul><h3 id="psychological-impact-of-puberty">Psychological Impact of Puberty</h3><p>賀爾蒙不是青少年情緒的主要原因 - 活動和社交環境的變化會產生很大的影響:</p><ul><li>good mood when with friends</li><li>bad mood in adult-regulated settings (成人監管的環境)</li></ul><p>提早或過晚進入青春期:</p><ul><li>提早進入青春期可能對女孩有害<ul><li>自信降低</li><li>可能進行風險行為</li></ul></li></ul><h2 id="health">Health</h2><h3 id="nutrition">Nutrition</h3><ul><li>Calories<ul><li>Average teenage girls need 2200 calories per day</li><li>boys need 2700</li></ul></li><li>Calcium and iron (鈣 &amp; 鐵)<ul><li>對於 <code>骨頭生長</code> 與 <code>血紅素(hemoglobin)產生</code> 很重要</li></ul></li><li>食用 <code>fast food</code> 可能會導致以上的 nutrition 攝取不足。</li></ul><h3 id="obesity-weight-problems">Obesity/weight problems</h3><ul><li>Obese children can lose weight<ul><li>改變飲食習慣 &amp; 運動</li><li>避免終身問題</li></ul></li><li>Teenage girls tend to worry about their weight and try diets/diet pills<ul><li>可能導致 <code>anorexia 厭食症</code> / <code>bulimia 暴食症</code></li><li>Anorexia nervos: 持續拒絕吃飯，對體重增加有非理性恐懼<ul><li>可能導致心臟問題甚至死亡。</li></ul></li><li>Bulimia nervos: 在暴飲暴食和清除食物(嘔吐/使用瀉藥)之間交替的疾病</li></ul></li></ul><h3 id="physical-fitness">Physical Fitness</h3><ul><li>exercise - 30 minutes of exercise at least three times a week.</li><li>participating in sports<ul><li>Benefits: 增強自尊、學習計劃建立、社交技能</li><li>Negative/Dark sid: 運動傷害、藥物可能對身體與情緒有影響</li></ul></li></ul><h3 id="threats-to-adolescent-well-being">Threats to Adolescent Well-Being</h3><ul><li>Adolescents take risks that adults often find unacceptable</li><li>死亡原因大多與意外事故有關</li></ul><h2 id="information-processing-during-adolescence">Information-Processing During Adolescence</h2><h3 id="working-memory-and-processing-speed">Working Memory and Processing Speed</h3><ul><li>Working memory and processing speed capacities increase during adolescence (接近成人)</li></ul><h3 id="increased-knowledge">Increased knowledge</h3><ul><li>Content knowledge</li><li>Strategies</li><li>Metacognition</li><li>problem solving</li><li>Reasoning</li></ul><h2 id="reasoning-about-moral-issues">Reasoning About Moral Issues</h2><p><a href="https://douobb.github.io/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/">Kohlberg’s Theory of Moral Reasoning</a></p><ul><li>Kohlberg believed that<ul><li>人們的道德會逐階段成長，不會跳過任何階段。</li><li>青少年只有在向他們施加壓力時，才傾向於道德地行事。</li></ul></li><li>Critics of Kohlberg’s theory say that<ul><li>沒有考慮不同的文化因素</li></ul></li><li>According to Carol Gilligan:<ul><li>女性更傾向於<code>照顧</code>，男性更傾向於<code>正義</code>。</li><li>實際上男女判斷道德的方式類似，取決於 <code>dilemma</code> 的情境與本質。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L7</title>
      <link href="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/"/>
      <url>/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/</url>
      
        <content type="html"><![CDATA[<h1>L7 Expanding Social Horizons:Socioemotional Development in Middle Childhood</h1><h2 id="family-relationships">Family Relationships</h2><h3 id="dimensions-and-styles-of-parenting">Dimensions and Styles of Parenting</h3><img src="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/Parenting.png" class="" title="Parenting-Styles"><ul><li>Authoritative parenting 民主威權型<ul><li>父母解釋規則並鼓勵討論。</li><li>通常是最好的。</li><li>有助於提高成績、自尊心和友善程度。</li></ul></li><li>Authoritarian parenting 威權專制型<ul><li>父母制定規則，並期望在沒有討論的情況下遵守它們。</li><li>通常產生缺乏自尊並且侵略性強的孩子。</li></ul></li><li>Permissive parenting 放任型<ul><li>父母通常接受孩子的行為並且很少進行懲罰。</li><li>通常產生衝動性格的孩子。</li></ul></li><li>Uninvolved parenting 漠視型<ul><li>父母只提供孩子的基本需求。</li><li>通常產生侵略性強且學習成績較差的孩子。</li></ul></li></ul><h3 id="specific-parental-behaviors-influence-children">Specific parental behaviors influence children</h3><ul><li>Direct instruction - 直接告訴孩子怎麼做、何時做以及為何做</li><li>Modeling - 父母的行為常常被模仿</li><li>Reinforcement<ul><li>增加隨後反應的可能性。</li><li><code>Negative reinforcement trap</code> - 不知不覺地加強了父母試圖減少的行為。</li></ul></li><li>Punishment</li></ul><h3 id="siblings">Siblings</h3><ul><li>有手足之後對 <code>first-borns</code> 的影響可能是吸引走了父母的注意。</li><li>年長的兄弟姐妹會與年幼的兄弟姐妹玩耍、安慰他們並教導他們。</li><li>有些兄弟姐妹關係親密，而有些則常爭吵，關係不和。</li></ul><h3 id="first-borns-and-later-borns">First-borns and later- borns</h3><ul><li>父母通常對 <code>first-borns</code> 更有愛，但也更嚴厲處罰。<ul><li>對後出生的孩子設定更現實的期望。</li></ul></li><li><code>first-borns</code> 通常 <code>IQ</code> 較高，且更有可能上大學。</li><li><code>first-borns</code> 更可能遵從父母的要求。</li><li><code>Later-borns</code> 往往在人際關係中更受歡迎，且更具創新性。</li></ul><h2 id="peers">Peers</h2><h3 id="friendship">Friendship</h3><ul><li>發展<ul><li>在 4-5 歲時，玩伴之間形成了友誼。</li><li>在 8-11 歲時，友誼包含相同喜好、信任和協助。</li><li>在青春期，親密關係存在於親密的友誼中。</li></ul></li><li>好處<ul><li>自尊心更高，減少抑鬱，增強親社會技能。</li><li>能夠更好地應對生活壓力。</li></ul></li><li>潛在壞處<ul><li><code>共同反芻 (Co-rumination)</code> - 討論個人問題<ul><li>在青春期女孩中常見，會增加患抑鬱和焦慮的風險。</li></ul></li><li>具有<code>攻擊性</code>的朋友常會互相鼓勵攻擊性行為。</li><li>參與<code>高風險行為</code>(如吸菸、毒品、性行為)的朋友往往會強化彼此的危險行為。</li></ul></li></ul><h3 id="popularity-and-rejection">Popularity and Rejection</h3><p>Most children in elementary schools fall into five categories:</p><ul><li><code>Popular</code> children<ul><li>liked by many and may be:<ul><li>Children who are skilled academically and socially</li><li>Aggressive boys and relationally aggressive girls</li></ul></li></ul></li><li><code>Rejected</code> children<ul><li>disliked by many</li><li>Most are aggressive and hostile; others shy, withdraw</li></ul></li><li><code>Controversial</code> children<ul><li>both liked and disliked intensively by different classmates</li></ul></li><li><code>Average</code> children<ul><li>liked and disliked by some</li></ul></li><li><code>Neglected</code> children<ul><li>ignored by classmates</li></ul></li></ul><h3 id="aggressive-children-and-their-victims">Aggressive Children and Their Victims</h3><ul><li>Instrumental aggression 工具性攻擊 - 用於實現目標<ul><li>早在 1-2 歲就出現。</li></ul></li><li>Hostile aggression 敵意攻擊 - 意圖恐嚇、騷擾或羞辱<ul><li>出現於小學。</li><li>隨著時間減少。</li><li>與輟學，成年暴力和失業有關。</li></ul></li></ul><h2 id="electronic-media">Electronic Media</h2><h3 id="television">Television</h3><ul><li>觀看電視中的暴力行為後，可能導致侵略性增加。</li><li>可能導致性別刻板印象。</li><li>可能影響親社會行為。</li></ul><h3 id="computers">Computers</h3><ul><li>遊戲的內容會影響兒童的發展<ul><li>俄羅斯方塊等遊戲可以提高空間技能。</li><li>玩暴力遊戲可能使兒童更具侵略性。</li></ul></li></ul><h2 id="understanding-others">Understanding Others</h2><p>Understanding What Others Think</p><img src="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/Understanding.png" class="" title="Understanding-Others">]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L6</title>
      <link href="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L6/"/>
      <url>/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L6/</url>
      
        <content type="html"><![CDATA[<h1>L6 Off to School: Cognitive and Physical Development in Middle Childhood</h1><h2 id="aptitudes-for-school">Aptitudes for School</h2><p><a href="https://douobb.github.io/2024/11/01/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/">Theories of Intelligence</a></p><h3 id="group-differences-in-test-scores">Group differences in test scores</h3><ul><li>Experience with test content<ul><li>通常基於中產階級經驗。</li></ul></li><li>Test-taking skills<ul><li>一些文化鼓勵協作解決問題。</li><li>對不熟悉的成人的問題保持警惕。</li></ul></li><li>Stereotype threat 刻板印象的威脅<ul><li>由於刻板印象而害怕做得不好，導致焦慮。</li></ul></li></ul><h2 id="special-children-special-needs">Special Children, Special Needs</h2><h3 id="gifted-and-creative-children">Gifted and Creative Children</h3><ul><li><code>IQ &gt;= 130</code> or exceptional ability in art, music, dance…</li><li>Intelligence relies on <code>convergent thinking 聚斂思考</code></li><li>Creativity relies on <code>divergent thinking 發散思考</code></li></ul><h3 id="children-with-disability-intellectual-disability">Children with Disability: Intellectual disability</h3><ul><li>必須在<code>18歲</code>之前表現。</li><li><code>IQ &lt;= 70</code></li><li>缺乏概念能力、實踐能力和社交能力。</li><li>風險因子:<ul><li>Biomedical factor - Down syndrome 唐氏症</li><li>Social factors - 貧困</li><li>Behavioral factors - 兒童忽視</li><li>Educational factors - 特殊教育計劃不足</li></ul></li></ul><h3 id="attention-deficit-hyperactivity-disorder-adhd">Attention-Deficit Hyperactivity Disorder (ADHD)</h3><ul><li>3-7% 的兒童，男女比約為 4:1。</li><li>症狀:<ul><li>Hyperactivity 過動</li><li>Inattention 不專注</li><li>Impulsivity 衝動</li></ul></li><li>並非每個孩子都有相同症狀</li><li>風險因子:<ul><li>遺傳</li><li>產前暴露於酒精或毒品</li></ul></li></ul><h2 id="academic-skills">Academic Skills</h2><h3 id="reading">Reading</h3><p>Steps in true reading:</p><ul><li>將字母發音來解碼單詞。</li><li>將單詞儲存於長期記憶。</li><li>上下文有助於識別單詞及其含義。</li></ul><h3 id="writing">Writing</h3><p>The <code>POW + TREE</code> strategy - a general plan for writing (POW) and a structure for a paragraph (TREE)</p><h3 id="math">Math</h3><ul><li>數手指</li><li>一年級左右開始默數</li><li>8-9歲時開始利用記憶進行加法</li><li>隨著年齡提升</li></ul><h2 id="physical-development">Physical Development</h2><h3 id="participating-in-sports">Participating in Sports</h3><ul><li>好處:<ul><li>鍛煉和提高運動技能</li><li>發展自尊心和主動性</li><li>學習社交技能和合作</li><li>以實際的方式運用認知技能</li></ul></li><li>潛在危害: 參與運動可能與反社會和犯罪行為有關</li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L5</title>
      <link href="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/"/>
      <url>/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/</url>
      
        <content type="html"><![CDATA[<h1>L5 Entering the Social World:Socioemotional Development in Infancy and Early Childhood</h1><h2 id="beginnings-trust-and-attachment">Beginnings: Trust and Attachment</h2><h3 id="erikson-s-stages-of-early-psychosocial-development">Erikson’s Stages of Early Psychosocial Development</h3><ul><li>Stage 1: <code>basic trust vs. mistrust</code> (基本信任與不信任)<ul><li>父母回應孩子的需求-&gt;培養信任。</li><li>信任和不信任平衡，發展 <code>Hope</code>：對新經驗的開放性，同時了解危險的可能性。</li></ul></li><li>Stage 2: <code>autonomy vs. shame and doubt</code> (自主與羞恥和懷疑)<ul><li>瞭解可以自由控制自己的行為，去抵銷懷疑與羞恥。</li><li>產生 <code>Will</code>，了解可以與環境有意地互動。</li></ul></li><li>Stage 3: <code>initiative vs. guilt</code> (自動自發與罪惡感)<ul><li>一個人的行動可能與他人的目標發生衝突。</li><li>產生 <code>Purpose</code>，平衡個人的行動與他人的目標。</li></ul></li></ul><h3 id="four-phases-in-growth-of-attachment">Four phases in growth of attachment</h3><ul><li>Preattachment (出生 - 6周)<ul><li>記得母親的聲音與味道。</li><li>行為引起成人的照顧。</li></ul></li><li>Attachment in the making (6-8周 - 6-8月)<ul><li>與照顧者更多的互動。</li><li>開始區別主要照顧者。</li></ul></li><li>True attachment (6-8月 - 18月)<ul><li>挑出依戀對象並表示信任。</li></ul></li><li>Reciprocal relationships (18月 - )<ul><li>能夠引起互動並了解父母的感受和目標。</li></ul></li></ul><h3 id="attachment-takes-four-primary-different-form">Attachment takes four primary different form</h3><ul><li>Secure attachment 安全依附<ul><li>當母親離開房間時，嬰兒可能不會哭泣，但是當母親回來時會想和她在一起。</li></ul></li><li>Avoidant attachment 迴避型依附<ul><li>當母親離開房間時，嬰兒不會哭泣，當母親回來時會避開她的視線。</li></ul></li><li>Resistant attachment 抗拒型依附<ul><li>當母親離開時，嬰兒很沮喪，當母親回來後仍然很難安慰。</li></ul></li><li>Disorganized attachment 紊亂型依附<ul><li>當母親離開並返回時，嬰兒表現出困惑，對母親表現出矛盾的行為。</li></ul></li></ul><h2 id="emerging-emotions">Emerging Emotions</h2><h3 id="experiencing-and-expressing-emotions">Experiencing and Expressing Emotions</h3><ul><li>Basic emotions<ul><li>包括主觀的感覺，生理改變和公開行為。</li><li>歡樂、憤怒、恐懼、興趣、厭惡、痛苦、悲傷、驚喜。</li><li>嬰兒在八個月內經歷全部。</li></ul></li><li>Complex emotions<ul><li>出現<code>自我意識</code>後浮現 (平均18個月後)</li><li>驕傲、罪惡感、尷尬。</li></ul></li></ul><h3 id="recognizing-and-using-others-emotions">Recognizing and Using Others’ Emotions</h3><ul><li>嬰兒可以在四個月大的時候檢測面部表情的情緒。</li><li>將他們的情緒與母親相匹配<ul><li>母親微笑時表現開心的情緒。</li></ul></li><li>Social referencing 社會參照<ul><li>向父母尋求線索，了解如何解讀情境。</li></ul></li></ul><h2 id="interacting-with-others">Interacting with Others</h2><h3 id="the-joys-of-play">The Joys of Play</h3><ul><li>Solitary play<ul><li>學齡前兒童可能的選擇。<ul><li>ex: lego, puzzles…</li></ul></li><li>不健康的 Solitary play:<ul><li>漫無目的地在活動之間切換。</li><li>父母只有觀看而沒有參與。</li></ul></li></ul></li><li>Parallel play<ul><li>每個孩子各自玩耍，但對其他孩子的行為感興趣。</li></ul></li><li>Simple social play<ul><li>幼兒從事類似的活動，互相交談或微笑。</li><li>15-18月開始。</li></ul></li><li>Cooperative play<ul><li>遊戲具有獨特的主題，孩子們扮演角色。</li><li><code>Make-believe play</code> 假扮遊戲</li><li>2歲開始。</li></ul></li></ul><h3 id="ways-that-parents-become-involved-in-children-s-play">Ways that parents become involved in children’s play</h3><ul><li>充當玩伴並促進遊戲發展。</li><li>安排社交活動與拜訪。</li><li>指導孩子掌握衝突解決與決策能力。<ul><li>有建設性的指導才能讓孩子受益。</li></ul></li><li>當發生衝突時充當調解人。</li></ul><h2 id="helping-others">Helping Others</h2><img src="/2025/03/31/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/Helping.png" class="" title="Helping"><h2 id="gender-roles-and-gender-identity">Gender Roles and Gender Identity</h2><p>孩子在學習性別角色的同時，開始認同自己是男孩或女孩。</p><ul><li><code>Gender stereotypes</code> 性別刻板印象<ul><li>關於男性和女性的信念和形象，不一定是正確或錯誤。</li></ul></li><li>18月後，孩子會對玩具產生偏向。<ul><li>ex: 卡車、洋娃娃…</li></ul></li></ul><h3 id="gender-stereotypes">Gender Stereotypes</h3><p>某些真實存在的性別差異</p><ul><li>語言能力 - 女孩通常具有優勢。</li><li>數學能力 - 男性有些微優勢。</li><li>空間能力 - 男生在嬰兒時期具有優勢。</li><li>社會影響力 - 女孩更有可能聽取成人的指示並同意群體決策。</li><li>攻擊性<ul><li>男孩在17月後展現更強的物理攻擊性。</li><li>女孩更傾向於關係攻擊，破壞他人與同伴的關係。</li></ul></li><li>情緒敏感性 - 女孩能夠更好地表達自己的情緒並且理解他人的情緒。</li></ul><h3 id="full-understanding-of-gender-emerges-in-three-steps">Full understanding of gender emerges in three steps:</h3><ul><li>Label<ul><li>孩子在 <code>2-3 歲</code>時將自己標記為男孩或女孩。</li></ul></li><li>boy -&gt; man and girl -&gt; women<ul><li><code>學齡前</code>兒童開始明白。</li></ul></li><li>Gender cannot be changed<ul><li><code>4-7 歲</code>時，孩子們知道不能根據服飾或性別活動判斷性別。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L4</title>
      <link href="/2025/03/10/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L4/"/>
      <url>/2025/03/10/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L4/</url>
      
        <content type="html"><![CDATA[<h1>L4 The Emergence of Thought and Language: Cognitive Development in Infancy and Early Childhood</h1><h2 id="the-onset-of-thinking-piaget-s-cognitive-developmental-theory">The Onset of Thinking:Piaget’s Cognitive Developmental Theory</h2><h3 id="piaget-s-methods-for-investigating-children-s-thought">Piaget’s Methods for Investigating Children’s Thought</h3><ul><li><code>Observed</code> infant children and presented them with everyday problems</li><li>Derived ideas about cognitive changes in the first two years.</li><li>Adapted psychoanalysis clinical method for childhood and adolescent<br>thought</li><li>Conducted open-ended clinical <code>interviews</code> based on initial responses</li></ul><h3 id="piaget-s-cognitive-developmental-theory">Piaget’s Cognitive Developmental Theory</h3><p>Central to Piaget’s theory is the biological concept of adaptation (適應)</p><ul><li>Schemes (schema) 基模<ul><li>psychological structures that organize experience 基於經驗的心理結構</li><li>嬰兒根據他們<code>可以執行的行動</code>分組 (ex:吸吮、抓握)</li><li>學齡前兒童根據<code>功能或概念</code>分組</li><li>年齡更大的兒童根據<code>抽象概念</code>分組 (ex:“activities I love”)</li></ul></li><li>Assimilation 同化<ul><li>將新的經驗納入舊的基模中</li></ul></li><li>Accommodation 調適<ul><li>根據新的經驗對基模進行調整</li></ul></li><li>Equilibrium/Equilibration 恢復平衡<ul><li>根據外在信息與內部結構間進行平衡並且修復錯誤的觀念</li></ul></li></ul><h3 id="stages-of-piaget-s-theory">Stages of Piaget’s theory</h3><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>發展時間軸</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(0-2) - Sensorimotor Stage 感覺運動期</p></div></div><div class='timeline-item-content'><ul><li>Infants “think” by acting on the world with their eyes, ears, hands, and mouth.</li><li>Milestone: Understanding objects<ul><li><code>object permanence (物體恆常性)</code></li></ul></li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(2-7) - Preoperational stage 前運思期</p></div></div><div class='timeline-item-content'><ul><li>Preschool children use symbols to represent their earlier sensorimotor discoveries</li><li>Development of language and make-believe play takes place. 假設遊戲</li><li>特點:<ul><li><code>Egocentrism</code> (自我中心) - 未能將他人的象徵觀點與自己區分開<ul><li>ex: three-mountains problem</li></ul></li><li><code>Centration</code> (片見性) - 專注於情況的一個方面，忽略了其他重要特徵<ul><li>ex: 同樣多的水倒入不同寬度的瓶子</li></ul></li><li><code>Appearance as reality</code> (表象等同真實) - 容易被物體的外觀分散注意力</li><li><code>Ignoring the dynamic transforma</code> (忽略動態變換)</li><li><code>Irreversibility</code> (不可逆性) - 無法進行邏輯逆推</li><li>difficulty with <code>hierarchical classification</code> (難以進行分層分類)<ul><li>ex: <code>花</code> 和 <code>紅花</code> 哪個比較多? (兒童無法意識到<code>花</code>包含<code>紅花</code>與其他顏色的花)</li></ul></li></ul></li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(7-11) - Concrete operational stage 具體運思期</p></div></div><div class='timeline-item-content'><ul><li>Children’s reasoning becomes logical and better organized</li><li>已經可以處理前一個階段的問題</li><li>However, children think in a logical, organized fashion only when dealing with concrete information they can perceive directly. (無法處理抽象問題)</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(11-) - Formal operations stage 形式運思期</p></div></div><div class='timeline-item-content'><p>學會<code>抽象思考</code></p></div></div></div><h3 id="contributions-of-piaget-s-theory">Contributions of Piaget’s Theory</h3><ul><li>認為兒童是具有豐富知識結構的主動學習者。</li><li>探討兒童對物理世界與社會世界的理解。</li><li>激發對兒童自我概念、人際關係及他人理解的研究。</li><li>鼓勵發展強調探索學習與環境接觸的教育理念。</li></ul><h3 id="limitations-criticisms-of-piaget-s-theory">Limitations/ criticisms of Piaget’s Theory</h3><ul><li>低估了嬰兒與學齡前兒童的能力<ul><li>嬰兒對於物體的認知高於預期</li><li>當任務縮減時，兒童表現出的能力與成人相近</li><li>訓練可以增兒童的表現</li></ul></li><li>高估了青少年的能力<ul><li>認知成熟度取決於知識的複雜性和對任務的熟悉程度</li></ul></li><li>階段理論受到質疑</li><li>發展心理學界對皮亞傑理論的分歧</li></ul><h3 id="extending-piaget-s-account">Extending Piaget’s Account</h3><ul><li>Children’s Naive Theories:<ul><li>Core knowledge hypothesis 核心知識假說<ul><li>兒童天生具備一些<code>基本的世界知識</code>，而這些知識會隨著經驗而發展和擴展</li></ul></li><li>包含物理學、生物學以及心理學</li></ul></li><li>嬰兒比 Piage 認為的更早了解物體<ul><li><code>Naive Theory of Physics</code><ul><li>4.5 個月大的嬰兒已經部分理解物體恆存性</li><li>5 個月大的嬰兒預期液體會改變形狀</li></ul></li><li>到了4歲，兒童已經發展出一套基本的生物學直覺概念，<code>Naive Theory of Biology</code>:<ul><li>Growth: 動畫物體隨時間變大</li><li>Internal parts 內部構造: 人類有血液與骨骼，而石頭沒有</li><li>Inheritance 繼承: 生物的外型會類似父母</li><li>Healing: 他們的頭髮可以再生，但玩偶的不行</li></ul></li></ul></li></ul><h2 id="information-processing-during-infancy-and-early-childhood">Information Processing During Infancy and Early Childhood</h2><h3 id="general-principles-of-information-processing">General Principles of Information Processing</h3><p>人類思考的基礎:</p><ul><li>Mental hardware: 先天內建的心理與神經結構，這些結構讓大腦能夠正常運作。</li><li>Mental software: 負責執行特定任務的心理「程式」。</li></ul><p>隨著兒童的發展，這些心理結構與認知過程會變得更加複雜、強大且高效。</p><h3 id="learning">Learning</h3><p>Learning takes several forms:</p><ul><li>Habituation 習慣化<ul><li>一旦變得熟悉，對刺激的反應會減少 (ex:交通噪音)</li></ul></li><li>Classical conditioning 古典制約<ul><li>刺激引起了最初由另一種刺激產生的反應 (ex:流水聲使嬰兒哭泣，因為他們知道要洗澡了)</li></ul></li><li>Operant conditioning 操作制約<ul><li>獎勵和懲罰決定了行為會重複發生的可能性 (ex:嬰兒的笑容得到了擁抱的回報，導致其在未來笑得更多)</li></ul></li><li>Imitation 模仿<ul><li>模仿成人的面部表情</li></ul></li></ul><h3 id="memory">Memory</h3><ul><li><p>Three important features of memory in young babies:</p><ul><li>Events from the past are remembered</li><li>Over time, events are no longer recalled</li><li>Cues prompt memories that seem to have been forgotten</li></ul></li><li><p>Memory improves as development progresses</p><ul><li>Growth in brain regions that support memory</li><li>海馬迴 (hippocampus) 和杏仁核 (amygdala) 參與記憶存儲，前額葉皮層 ( prefrontal cortex) 用於檢索。</li></ul></li><li><p>Autobiographical memory 自傳記憶 - people’s memory of the experience/events of their own lives</p><ul><li>First develops in the preschool years</li><li>A result of basic memory skills that develop in infancy, language skills, and a <code>sense of self</code> (自我意識)<ul><li>自我意識使經驗有連貫性和連續性</li></ul></li></ul></li></ul><div class="note primary no-icon flat"><p>遭虐待的兒童的證詞是否準確?</p><ul><li>Preschoolers are suggestible<ul><li>主要問題有時會被存儲為虛假記憶</li><li>常常搞混誰說了或做了什麼事</li></ul></li><li>Guidelines must be followed to ensure that preschoolers can provide reliable testimony</li><li>Preschooler testimony interview guidelines<ul><li>事情發生後儘快採訪兒童。</li><li>鼓勵孩子們說實話，可以說「我不知道」或是糾正採訪者。</li><li>讓孩子們用自己的話描述事件，提問開放式問題。</li><li>提出考慮事件其他可能解釋的問題</li></ul></li></ul></div><h3 id="learning-number-skills">Learning Number Skills</h3><ul><li>One-to-one principle 一對一對應原則<ul><li>每個物品對應一個數字，不會漏掉或重複。</li></ul></li><li>Stable-order principle 固定順序原則<ul><li>數數時數字的順序必須固定，如 1、2、3、4、5。</li></ul></li><li>Cardinality principle 基數原則<ul><li>數完一組物品後，最後說出的數字表示該組物品的總數。</li></ul></li></ul><h2 id="mind-and-culture-vygotsky-s-theory">Mind and Culture:Vygotsky’s Theory</h2><h3 id="zone-of-proximal-development-近約發展區">Zone of proximal development 近約發展區</h3><p>The <code>zones</code>:</p><ul><li>Actual Development Level: 可以獨力完成的任務，不需要幫助。</li><li>Zone of Proximal Development: 可以在指導和支持下完成的任務，是學習和發展的最佳區域。</li><li>Beyond the ZPD: 超出當前能力的任務。</li></ul><h3 id="scaffolding-鷹架">Scaffolding 鷹架</h3><ul><li>老師，父母或同伴提供的支持和指導，以幫助學習者在 <code>ZPD</code> 內完成任務。</li><li>不同文化的父母所提供的 <code>Scaffolding</code> 可能不同。<ul><li>口頭教學、手勢等。</li></ul></li></ul><h3 id="private-speech-私語">Private speech 私語</h3><ul><li>private speech<ul><li>個體在獨自活動時大聲說出來的話語。</li><li>解決問題和自我調節的認知工具。</li><li>隨著成長會轉為 <code>inner speech (though)</code>。</li></ul></li><li>social speech<ul><li>針對他人。</li></ul></li></ul><h2 id="language">Language</h2><h3 id="the-road-to-speech">The Road to Speech</h3><ul><li>一個月的嬰兒可以區分一些 <code>Phonemes (音素)</code>。<ul><li>音素為最小的語音單位。</li></ul></li><li>七到八個月的孩子會注意他們經常聽到的單詞。</li><li>嬰兒識別單詞的方式:<ul><li>注意重音音節</li><li>句子開頭或結尾的單詞更容易辨認</li><li>注意一起經常使用的音節</li><li><code>infant-directed speech (motherese/parentese)</code><ul><li>成人與嬰兒說話時的一種特殊語言模式，具有較高音調、誇張的語調、較慢的語速、清晰的發音，並且經常使用簡單、重複的詞語，以幫助嬰兒理解語言。</li></ul></li></ul></li></ul><h3 id="first-words-and-many-more">First Words and Many More</h3><ul><li>兒童在能夠說出單詞之前，就已經能夠理解單詞。</li><li>兩歲的兒童約有幾百的詞彙量。<ul><li>六歲的兒童約有一萬的詞彙量。</li></ul></li><li>開始使用語言之前，孩子必須認識到單詞是物體的符號。<ul><li>a furry thing that barks is “dog”</li></ul></li><li>Fast Mapping<ul><li>孩子能夠迅速將單詞與它所代表的事物建立聯繫，而不需要考慮所有可能的含義。</li></ul></li></ul><h3 id="factors-in-learning-new-words">Factors in learning new words</h3><ul><li>Joint attention: 父母協助標記孩子表現出興趣的對象。</li><li>Constraints on word names<ul><li>如果孩子聽到一個陌生的詞，並且場景中有一些他已經認識的物體，以及一些他不認識的物體，那麼這個新詞很可能指的是那些還沒有名字的物體。</li><li>當孩子聽到一個新詞時，他們會假設這個詞指的是整個物體，而不是物體的一部分或某個特徵。</li></ul></li><li>Sentence cues: 透過句子結構來推測單詞的意思。</li><li>Cognitive factors: 語言成為實現目標和傳遞意圖的手段。</li></ul><h3 id="developmental-change-in-word-learning">Developmental change in word learning</h3><ul><li>18 個月以前的兒童主要依靠 <code>attentional processes</code> 學習單詞，通常會根據物體的顏色、形狀或大小來識別它們的名稱。</li><li>24 個月的兒童使用 <code>language and social cues</code> 學習單詞。</li><li>兒童常見的命名錯誤:<ul><li>Underextension 過度侷限<ul><li>將某個單詞的使用範圍縮小，只適用於特定對象。</li><li>認為「dog」這個詞只用來指代家裡的寵物狗，而不認為鄰居的狗或其他品種的狗也是「dog」。</li></ul></li><li>overextension 過度延伸<ul><li>將某個單詞的適用範圍擴大，將其用於更多與該物體特徵相似的對象。</li><li>認為所有四隻腳的動物都叫「dog」。</li></ul></li></ul></li></ul><h3 id="children-have-different-styles-of-learning-language">Children have different styles of learning language</h3><ul><li>Referential style 指稱型<ul><li>詞彙主要由人名、物品名稱和動作詞組成</li><li>將語言作為智力工具，用來標記和識別物體</li></ul></li><li>Expressive style 表達型<ul><li>詞彙包含一些名稱詞，但也有許多社交短語<ul><li>ex: “I want it”</li></ul></li><li>將語言作為社交工具，用來與他人溝通</li></ul></li></ul><h3 id="are-doing-these-helpful">Are doing these helpful?</h3><ul><li>Parents<ul><li>與孩子交談並命名感興趣的對象</li><li>閱讀書籍並與孩子一起觀看教育視頻，鼓勵語言成長</li></ul></li><li>Baby videos<ul><li>促進嬰兒單詞學習的 Baby videos 通常無益</li></ul></li></ul><h3 id="speaking-in-sentences-grammatical-development">Speaking in Sentences:Grammatical Development</h3><ul><li>兒童可以用基本公式製作包含兩個單詞的句子<ul><li>ex: “gimme cookie”, “Timmy sleep”</li><li>Telegraphic speech 電報式語言: 僅包含與含意直接相關的單字</li></ul></li><li>三歲的孩子可能在句子中包含 10 個以上的單字</li></ul><h3 id="speaking-in-sentences">Speaking in Sentences</h3><p>英語具有高度不規則的文法</p><ul><li>Overregularizations 過度規則化<ul><li>將文法規則應用於該規則例外的單詞</li><li>ex: “man” -&gt; “mans”</li></ul></li></ul><h3 id="how-do-children-acquire-grammar">How do children acquire grammar?</h3><ul><li>behaviorists 行為主義:<ul><li>模仿聽到的語言學習</li><li>語言太複雜了，可能無法通過模仿學習</li></ul></li><li>linguists 語言學, Chomsky, Language Acquisition Device (LAD) 語言習得裝置<ul><li>兒童天生就具備語言學習的機制，被稱為語言習得裝置（LAD），可以幫助兒童學習語法。</li><li>大腦有特定區域專門處理語言，使人類能夠迅速學會語法。</li><li>0-12 歲為學習語言的關鍵期。</li></ul></li><li>cognitive theorists 認知理論<ul><li>觀察環境中的規律來學習語言，包括語法規則。</li></ul></li><li>social interaction theory 社會互動理論<ul><li>成人和兒童共同努力促進語言發展。</li></ul></li></ul><h3 id="communicating-with-others">Communicating with Others</h3><img src="/2025/03/10/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L4/Communicating.png" class="" title="Communicating">]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L3</title>
      <link href="/2025/03/03/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/"/>
      <url>/2025/03/03/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/</url>
      
        <content type="html"><![CDATA[<h1>L3 Tools for Exploring the World: Physical, Perceptual, and Motor Development</h1><h2 id="the-newborn">The Newborn</h2><h3 id="reflexes-反射">Reflexes 反射</h3><img src="/2025/03/03/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/Reflexes.png" class="" title="theory"><h3 id="neonatal-behavioral-assessment-scale-nbas">Neonatal Behavioral Assessment Scale (NBAS)</h3><p>新生兒行為評估量表。</p><ul><li>Used with newborns to 24-month-olds</li><li>Provides a detailed picture of the baby’s behavior</li><li>Includes 28 behavior items and 18 reflex test</li><li>Evaluates functioning of four systems:<ul><li>Autonomic</li><li>Motor</li><li>State</li><li>Social</li></ul></li></ul><h3 id="the-newborn-s-states">The Newborn’s States</h3><p>Newborns alternate among four states:</p><ul><li>Alert inactiviy<ul><li>平靜，眼睛睜開，觀察周圍環境</li></ul></li><li>Waking activity<ul><li>眼睛睜開但無法對焦，伴隨不規則的動作</li></ul></li><li>Crying<ul><li>劇烈哭泣，伴隨激動的動作</li></ul></li><li>Sleeping<ul><li>眼睛閉合，有時靜止且呼吸規律；有時輕微移動且呼吸不規則</li></ul></li></ul><h3 id="newborn-s-cry">Newborn’s cry</h3><ul><li>Basic cry<ul><li>起初柔和漸進，隨後變得更強烈</li><li>通常發生在嬰兒感到疲倦或飢餓時</li></ul></li><li>Mad cry<ul><li>更為強烈的 <code>Basic cry</code></li></ul></li><li>Pain cry<ul><li>突然長時間大聲哭泣，接著出現長時間的停頓和急促喘氣</li></ul></li></ul><h3 id="newborn-s-sleep">Newborn’s sleep</h3><ul><li>Newborns sleep <code>16-18 hours</code> a day<ul><li>睡眠與清醒的循環為三小時睡眠、一小時清醒，維持一整天。</li></ul></li><li>約 <code>6個月</code>後開始可整晚睡眠 (10-12小時)</li><li>新生兒的睡眠有一半屬於 irregular/rapid-eye movement (REM 快速動眼期)</li><li>Sudden infant death syndrome (SIDS) 嬰兒猝死症候群<ul><li>風險因素:<ul><li>2~4個月</li><li>早產或過輕</li><li>父母抽菸</li><li>趴睡</li><li>蓋太多毯子</li><li>容易過熱</li></ul></li></ul></li></ul><h3 id="temperament-氣質">Temperament 氣質</h3><p>A consistent style or pattern of behavior that related to personality later in life (影響之後的性格)</p><p>Three dimension:</p><ul><li>Surgency/extroversion 突發性/外向性<ul><li>is infant generally <code>happy, active, and vocal</code>? 是否快樂、活躍、發聲</li></ul></li><li>Negative affect 負向情感<ul><li>angry, fearful, shy; not easily sooth</li></ul></li><li>Effortful control 主動控制<ul><li>can focus attention; not readily distracted; can inhibit responses</li><li>可以保持專注並且自我調節</li></ul></li></ul><p>What factors can affect temperament?</p><ul><li>Heredity 遺傳<ul><li>雙胞胎的氣質相近</li><li><code>Negative affect</code> 更容易受遺傳影響</li></ul></li><li>Environment 環境<ul><li>母親的抑鬱會導致嬰兒容易感到恐懼</li><li>不同的文化會使嬰兒的氣質不同</li></ul></li></ul><h2 id="physical-development">Physical Development</h2><p>略過</p><h2 id="moving-and-grasping-early-motor-skills">Moving and Grasping:Early Motor Skills</h2><h3 id="moving-and-grasping">Moving and Grasping</h3><ul><li>Motor skills 運動技能<ul><li>coordinated movements of the muscles and limbs 肌肉與四肢協調</li><li>Infants learn to move about in the world</li></ul></li><li>Fine motor skill 精細運動技能<ul><li>associated with <code>grasping, holding, and manipulating</code> objects 抓臥並操作物體</li><li>Feeding (拿取瓶子、器皿等) is a fine motor skill</li></ul></li></ul><h2 id="coming-to-know-the-world-perception">Coming to Know the World: Perception</h2><h3 id="smelling-tasting-touching-and-hearing">Smelling, Tasting, Touching, and Hearing</h3><ul><li>Infants have a keen sense of smell<ul><li>Recognize familiar smell (ex:母親)</li><li>對氣味有反應 (ex:甜味-&gt;正向，腐爛的蛋-&gt;負面)</li></ul></li><li>Can differentiate among different tastes<ul><li>Prefer <code>sweet tastes</code> and do not like sour or bitter ones</li></ul></li><li>Sensitive to touch<ul><li>Elicit specific behaviors (increased heart rate, cry, etc.) in response to pain</li></ul></li><li>Infants best hear sounds in the range of human speech<ul><li>四五個月的嬰兒對自己的名字有反應，並且可以區分母音與子音</li></ul></li></ul><h3 id="seeing">Seeing</h3><ul><li>Newborns’ and young babies’ vision is much worse than an adult’s<ul><li>Fully develops by <code>age one</code></li></ul></li><li>At <code>three months</code>, babies can see the <code>full range of colors</code></li><li>Even newborns readily recognize face<ul><li>更容易辨別該族群的人的面孔</li></ul></li></ul><h2 id="becoming-self-aware">Becoming Self-Aware</h2><h3 id="origins-of-self-concept">Origins of Self-Concept</h3><ul><li>Self-awareness emerges between <code>18-24 month</code><ul><li>Use of own name or personal pronouns 使用自己的名字/代詞</li><li>Knowledge of age and gender 對年紀與性別有認知</li></ul></li></ul><h3 id="theory-of-mind-心智理論">Theory of Mind 心智理論</h3><p>a naive understanding of the relations between mind and behavior</p><ul><li>Intentionality 意向性<ul><li>心靈代表或呈現事物、屬性或狀態的能力</li><li><code>One-year-olds</code> understand intentionality</li></ul></li><li>Theory of mind<ul><li>推論他人心智狀態的能力</li><li>develops <code>between ages two and five</code></li></ul></li><li>behavior is a result on one’s beliefs<ul><li>Around <code>age four</code>, children understand that behavior is a result on one’s beliefs, even when beliefs are wrong</li></ul></li><li>Language skills or interactions with other people 語言以及與他人的互動<ul><li>may lead to the theory of mind</li></ul></li></ul><p>false-belief task:</p><img src="/2025/03/03/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/task.png" class="" title="false-belief-task">]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>發展心理學筆記-L1</title>
      <link href="/2025/02/24/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L1/"/>
      <url>/2025/02/24/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L1/</url>
      
        <content type="html"><![CDATA[<h1>L1 Developmental Psychology (Human Development)</h1><h2 id="thinking-about-development">Thinking About Development</h2><p>Fundamental Issues in Human Development:</p><ul><li>Nature-nurture issue 先天與後天<ul><li>個人特質是先天還是後天而來。</li></ul></li><li>Continuity-discontinuity issue 連續與不連續<ul><li>個人特質是不變還是緩慢改變，又或是突然的巨大變化。</li></ul></li><li>Universal vs. context-specific issue 普世皆然與情境特定<ul><li>發展的途徑與方式是否是唯一的。</li></ul></li></ul><p>Basic Forces in Human Development:</p><ul><li>Four Interactive Force<ul><li>Biological forces</li><li>Psychological forces</li><li>Sociocultural forces</li><li>Life-cycle force</li></ul></li><li>Biopsychosocial framework 生物心理社會框架<ul><li>上面四個作用力互相影響</li></ul></li></ul><h2 id="developmental-theories">Developmental Theories</h2><h3 id="psychodynamic-theory-心理動力論">Psychodynamic Theory 心理動力論</h3><p>Development is determined by how well people resolve conflicts faced at different age.</p><p>Key theorists:</p><ul><li>Erik Erikson<ul><li><a href="https://douobb.github.io/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/">Erikson’s stages of development</a></li></ul></li><li>Sigmund Freud</li></ul><h3 id="learning-theory-學習論">Learning theory 學習論</h3><ul><li>Behaviorism 行為主義<ul><li>行為的後果決定了將來是否重複這種行為。</li></ul></li><li>Social learning theory 社會學習論<ul><li><a href="https://douobb.github.io/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12">Albert Bandura’s social cognitive theory</a></li><li>透過模仿或觀察來學習。</li></ul></li></ul><h3 id="cognitive-developmental-theory-認知發展論">Cognitive-developmental theory 認知發展論</h3><p>How people think and how thinking changes over time.</p><ul><li>Piaget’s theory<ul><li>孩子創建有關世界的理論，並通過經驗來測試。</li><li><a href="https://douobb.github.io/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/">Piaget’s Four Stages of Cognitive Development</a></li></ul></li><li>Information-processing theory 訊息處理論<ul><li>人類的認知由心理硬件 (cognitive structure) 和心理軟件 (sets of cognitive processe) 組成。</li></ul></li><li>Vygotsky’s theory<ul><li>檢視兒童各面向的發展時應該考慮其<code>文化背景</code>。</li></ul></li></ul><h3 id="ecological-systems-perspective-生態系統取向">Ecological &amp; Systems Perspective 生態系統取向</h3><p>Development is inseparable from the environment in which a person develops.</p><ul><li>Bronfenbrenner’s theory<ul><li>將兒童發展視為<code>受周圍環境多層次影響</code>的複雜關係系統。  <img src="/2025/02/24/%E7%99%BC%E5%B1%95%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L1/Bronfenbrenner.png" class="" title="theory"></li><li>Competence-environmental press theory 能力-環力壓力論<ul><li>合適的能力與環境壓力比例是有利於發展的。</li></ul></li></ul></li></ul><h3 id="life-span-perspective-生命全期取向">Life-span perspective 生命全期取向</h3><p>認為發展心理學應研究<code>人類生命的全部過程</code>，而不應只研究人類發展過程中的某一階段，生命中的每個階段都會受到前面階段的影響。</p><p>Four central features of lifespan development perspective:</p><ul><li>Multidirectionality 多向性</li><li>plasticity 可塑性</li><li>historical context 歷史情境</li><li>multiple causation 多重因果</li></ul><h3 id="life-course-perspective-生命歷程取向">Life-course perspective 生命歷程取向</h3><p>各個世代的人類心理發展受到什麼影響，考慮到個<code>人與社會之間的交互作用</code>。<br>ex:不同世代的人們結婚年齡的不同。</p><h2 id="doing-developmental-research">Doing Developmental Research</h2><h3 id="measurement-in-human-development">Measurement in Human Development</h3><ul><li>Systematic observation 系統觀察<ul><li>Naturalistic observations 自然觀察 - 現實的情境下進行觀察。</li><li>Structured observations 結構性觀察 - 創造出特定情境觀察受試者的反應。</li><li>可能產生不自然或不切實際的行為。</li></ul></li><li>Sampling behavior with tasks 透過任務進行採樣</li><li>Self-reports 自我報告<ul><li>問卷 &amp; 口頭採訪</li></ul></li><li>Physiological measures 生理測量<ul><li>腦部成像、心跳…</li></ul></li></ul><h3 id="is-the-chosen-method-reliable-and-valid">Is the chosen method reliable and valid?</h3><ul><li>Reliability 信度<ul><li>對同一現象進行重複觀察之後是否可以得到相同資料值。</li></ul></li><li>Validity 效度<ul><li>測量方法能否如實反映所欲測量對象的能力。</li></ul></li></ul><h3 id="general-designs-for-research">General Designs for Research</h3><ul><li>Correlational studies 相關研究 - 變數之間的相關性 (-1.0 ~ 1.0)。</li><li>Experimental studies 實驗研究 - 操弄自變量觀察結果。<ul><li>分組時必須採用 Random assignment (隨機分派)</li></ul></li><li>Qualitative research 質性研究 - 深入瞭解人類的行為及其理由。</li></ul><h3 id="designs-for-studying-development">Designs for Studying Development</h3><ul><li>Longitudinal studies 縱貫 - 長時間觀察特定人群。</li><li>Cross-sectional studies 橫斷 - 單一時間觀察不同年齡的人。<ul><li>Cohort effects 世代效應</li></ul></li><li>Sequential studies 序列 - 結合以上兩種設計。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPE筆記-5</title>
      <link href="/2025/02/03/GPE%E7%AD%86%E8%A8%98-5/"/>
      <url>/2025/02/03/GPE%E7%AD%86%E8%A8%98-5/</url>
      
        <content type="html"><![CDATA[<p>大概刷了 50 題左右 <a href="https://gpe-helper.setsal.dev/">GPE Helper</a> 上面比較常出現的題目，根據題目類型分類做一些筆記，方便之後複習。</p><div class="note primary flat"><p>本篇主題大多與數學相關。</p></div><mark class="hl-label default">數學</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>22151 Big Mod</td><td><a href="https://vjudge.net/problem/UVA-374">374</a></td></tr><tr><td>10559 I Love Big Numbers !</td><td><a href="https://vjudge.net/problem/UVA-10220">10220</a></td></tr><tr><td>10422 Is This Integration</td><td><a href="https://vjudge.net/problem/UVA-10209">10209</a></td></tr><tr><td>10559 10675 Urn-ball Probabilities!</td><td><a href="https://vjudge.net/problem/UVA-10169">10169</a></td></tr><tr><td>23661 Bit Mask</td><td><a href="https://vjudge.net/problem/UVA-10718">10718</a></td></tr><tr><td>10414 Bangla Numbers</td><td><a href="https://vjudge.net/problem/UVA-10101">10101</a></td></tr></tbody></table><h1>數學相關</h1><h2 id="big-mod">Big Mod</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-374">UVA 374</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>根據輸入的數字 <code>B, P, M</code> 求 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>B</mi><mi>P</mi></msup><mi>m</mi><mi>o</mi><mi>d</mi><mi>M</mi></mrow><annotation encoding="application/x-tex">B^P mod M</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8413309999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">P</span></span></span></span></span></span></span></span><span class="mord mathdefault">m</span><span class="mord mathdefault">o</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span></span></span></span>。</p><mark class="hl-label default">解題方法</mark> <p>快速冪的計算方式加上 <code>mod</code>。</p><mark class="hl-label default">注意事項</mark> <ul><li>快速冪函數的參數 <code>b</code> 應該改為 <code>b % m</code> 避免計算時超出 <code>int</code> 範圍。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> b, <span class="type">int</span> p, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="number">1</span>) <span class="keyword">return</span> b % m;</span><br><span class="line">    <span class="type">int</span> t = <span class="built_in">f</span>(b, p / <span class="number">2</span>, m), tt = (t * t) % m;</span><br><span class="line">    <span class="keyword">if</span>(p % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> tt;</span><br><span class="line">    <span class="keyword">return</span> (tt * b) % m;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> b, p, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; b &gt;&gt; p &gt;&gt; m)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(b % m, p, m) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="i-love-big-numbers">I Love Big Numbers !</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10220">UVA 10220</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>根據輸入的數字 <code>n</code>，求 <code>n!</code> 的各位數字和。</p><mark class="hl-label default">解題方法</mark> <p>因為題目的 <code>n</code> 最大只到 1000，因此可以提前建表，利用一個陣列儲存每一位數字，並利用大數運算的方式逐漸乘上去，每乘一次就紀錄各位數字和。</p><mark class="hl-label default">注意事項</mark> <ul><li>陣列大小要開夠，並且初始值為 <code>1</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">1001</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(<span class="number">3001</span>, <span class="number">0</span>));</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    v[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3000</span>; j++)&#123;</span><br><span class="line">            v[i][j] = v[i - <span class="number">1</span>][j] * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">3000</span>; j++)&#123;</span><br><span class="line">            v[i][j + <span class="number">1</span>] += v[i][j] / <span class="number">10</span>;</span><br><span class="line">            v[i][j] %= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3000</span>; j++)&#123;</span><br><span class="line">            ans[i] += v[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        cout &lt;&lt; ans[n] &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="is-this-integration">Is This Integration</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10209">UVA 10209</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>根據輸入的數字 <code>a</code> 作為邊長，求正方形分割各區塊的面積。</p><mark class="hl-label default">解題方法</mark> <ul><li><code>z</code> 的面積是正方形減去正三角形以及兩個 <code>1/12</code> 圓， 且網狀線背景區域面積為 <code>4z</code>。</li><li><code>y</code> 的面積是正方形減去 <code>1/4</code> 圓以及兩個 <code>z</code>，且點狀背景區域面積為 <code>4y</code></li><li>斜線背景面積為正方形減去 <code>(4y + 4z)</code>。</li></ul><img src="/2025/02/03/GPE%E7%AD%86%E8%A8%98-5/10422.png" class="" title="分割"><mark class="hl-label default">注意事項</mark> <ul><li><code>pi</code> 的數值多位一點比較精準。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> pi = <span class="number">3.141592653589793</span>, n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="type">double</span> z = n * n * (<span class="number">1</span> - <span class="built_in">sqrt</span>(<span class="number">3</span>) / <span class="number">4</span> - pi / <span class="number">6</span>);</span><br><span class="line">        <span class="type">double</span> y = n * n * (<span class="number">1</span> - pi / <span class="number">4</span>) - <span class="number">2</span> * z;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.3f %.3f %.3f\n&quot;</span>, n * n - <span class="number">4</span> * y - <span class="number">4</span> * z, <span class="number">4</span> * y, <span class="number">4</span> * z);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="urn-ball-probabilities">Urn-ball Probabilities!</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10169">UVA 10169</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>有兩個罐子，其中一個有一顆紅球，另一個有一顆紅球與白球，每次各從兩個罐子中取出一顆球並放回，並且加入一顆白球，輸入一個數字 <code>n</code>，求出 <code>n</code> 次操作中至少有一次取出兩個紅球的機率，以及連續 <code>n</code> 次都取出兩個紅球的機率小數點後有幾個 <code>0</code>。</p><mark class="hl-label default">解題方法</mark> <ul><li>建立一個陣列 <code>v</code> 儲存 <code>n</code> 次操作中至少有一次取出兩個紅球的機率，可以知道 <code>v[i] = v[i - 1] + (1 - v[i - 1]) / (i * (i + 1))</code>。</li><li>建立一個陣列 <code>d</code> 儲存連續 <code>n</code> 次都取出兩個紅球的機率小數點後有幾個 <code>0</code>，因為小數點後 0 的個數應該是 <code>-log(k_n))</code> 的整數部分 (k_n 為連續 <code>n</code> 次都取出兩個紅球的機率)，<code>k_n = k_(n - 1) * 1 / (i * (i + 1))</code>，把 log 外的負號放進去並且分解，就能得到 <code>d[i] = d[i - 1] + log10(i * (i + 1))</code>。</li></ul><mark class="hl-label default">注意事項</mark> <ul><li>變數 <code>i</code> 用 <code>double</code> 避免精度誤差。</li><li>注意題目要求的輸出格式。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1000001</span>, <span class="number">0</span>)</span>, <span class="title">d</span><span class="params">(<span class="number">1000001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">double</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000000</span>; i++)&#123; <span class="comment">//i 用 double</span></span><br><span class="line">        v[i] = v[i - <span class="number">1</span>] + (<span class="number">1</span> - v[i - <span class="number">1</span>]) / (i * (i + <span class="number">1</span>));</span><br><span class="line">        d[i] = d[i - <span class="number">1</span>] + <span class="built_in">log10</span>(i * (i + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%.6f %d\n&quot;</span>, v[n], (<span class="type">int</span>)d[n]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bit-mask">Bit Mask</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10718">UVA 10718</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>輸入為三個 <code>32 bit</code> 的 <code>unsigned integers</code> <code>N, L, U</code>，求出 <code>M</code> 滿足 <code>L &lt;= M &lt;= U</code> 且使得 <code>N or M</code> 為最大值，如果有多個 <code>M</code> 滿足該條件則傳回最小的。</p><mark class="hl-label default">解題方法</mark> <p>由 <code>32 bit</code> 的最高位開始檢查，如果 <code>N</code> 在此位置為 <code>1</code> 則 <code>M</code> 在此位可以為 <code>0 or 1</code>，為了避免 <code>M &lt; L</code> 超出邊界，必須要檢查 <code>如果 M 在此位以後都為 1 是否能滿足 M &gt;= L</code>。如果 <code>N</code> 在此位置為 <code>0</code>，則要盡可能的使 <code>M</code> 在此位置為 <code>1</code>，因此要檢查 <code>當 M 在此位置為 1 時是否滿足 M &lt;= U</code>。</p><mark class="hl-label default">注意事項</mark> <ul><li><code>(long long)1 &lt;&lt; i</code> 前面將 <code>1</code> 轉為 <code>long long</code> 是因為位移之後可能會超過 <code>int</code> 範圍。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, l, u;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; l &gt;&gt; u)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> m = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">long</span> <span class="type">long</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//由最高位往低位檢查</span></span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> t = ((<span class="type">long</span> <span class="type">long</span>)<span class="number">1</span> &lt;&lt; i), k = (m | t);</span><br><span class="line">            <span class="keyword">if</span>((n &amp; t))&#123; <span class="comment">// n 此位為 1</span></span><br><span class="line">                <span class="keyword">if</span>(m + t - <span class="number">1</span> &lt; l) m = k; <span class="comment">//是否大於下界</span></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(k &lt;= u) m = k; <span class="comment">// 是否小於上界</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bangla-numbers">Bangla Numbers</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10101">UVA 10101</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>將輸入的數字轉換為某種特殊的文字形式。</p><mark class="hl-label default">解題方法</mark> <p>根據四個單位的大小，遞迴處理數字。</p><mark class="hl-label default">注意事項</mark> <ul><li>當數字為 <code>0</code> 時，需要輸出 <code>0</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(<span class="type">long</span> <span class="type">long</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n / <span class="number">10000000</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n / <span class="number">10000000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; kuti&quot;</span>;</span><br><span class="line">        n %= <span class="number">10000000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n / <span class="number">100000</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n / <span class="number">100000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; lakh&quot;</span>;</span><br><span class="line">        n %= <span class="number">100000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n / <span class="number">1000</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n / <span class="number">1000</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; hajar&quot;</span>;</span><br><span class="line">        n %= <span class="number">1000</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n / <span class="number">100</span>)&#123;</span><br><span class="line">        <span class="built_in">solve</span>(n / <span class="number">100</span>);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; shata&quot;</span>;</span><br><span class="line">        n %= <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(n)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> n, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%4d.&quot;</span>, c);</span><br><span class="line">        <span class="keyword">if</span>(n) <span class="built_in">solve</span>(n);</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot; 0&quot;</span>;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPE筆記-4</title>
      <link href="/2025/01/28/GPE%E7%AD%86%E8%A8%98-4/"/>
      <url>/2025/01/28/GPE%E7%AD%86%E8%A8%98-4/</url>
      
        <content type="html"><![CDATA[<p>大概刷了 50 題左右 <a href="https://gpe-helper.setsal.dev/">GPE Helper</a> 上面比較常出現的題目，根據題目類型分類做一些筆記，方便之後複習。</p><div class="note primary flat"><p>本篇主題大多與數學相關。</p></div><mark class="hl-label default">質數表</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>24461 Sum of Consecutive Prime Numbers</td><td><a href="https://vjudge.net/problem/UVA-1210">1210</a></td></tr><tr><td>23571 Smith Numbers</td><td><a href="https://vjudge.net/problem/UVA-10042">10042</a></td></tr></tbody></table><mark class="hl-label default">約瑟夫問題</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>21944 Power Crisis</td><td><a href="https://vjudge.net/problem/UVA-151">151</a></td></tr><tr><td>10607 Joseph’s Cousin</td><td><a href="https://vjudge.net/problem/UVA-10015">10015</a></td></tr></tbody></table><mark class="hl-label default">座標系</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>2009-24 Unique lines</td><td></td></tr><tr><td>10551 Bee Maja</td><td><a href="https://vjudge.net/problem/UVA-10182">10182</a></td></tr></tbody></table><mark class="hl-label default">運算式</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>2008-37 Prefix expression evaluation</td><td></td></tr><tr><td>23671 Camel trading</td><td><a href="https://vjudge.net/problem/UVA-10700">10700</a></td></tr></tbody></table><h1>質數表</h1><h2 id="sum-of-consecutive-prime-numbers">Sum of Consecutive Prime Numbers</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-1210">UVA 1210</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>根據題目輸入的數字，計算其能夠寫成幾種連續質數的和，ex: <code>53 = 5 + 7 + 11 + 13 + 17</code> 同時 53 也是一個質數，故需要輸出 2。</p><mark class="hl-label default">解題方法</mark> <p>先建立一個儲存質數的 <code>vector</code>，不斷篩選出質數並放入其中，之後直接用暴力法測試是否能夠湊出題目要求的數字。</p><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">prime_table</span><span class="params">(<span class="number">10001</span>, <span class="number">1</span>)</span>, prime</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= <span class="number">10000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(prime_table[i] == <span class="number">1</span>)&#123; <span class="comment">//質數表</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt;= <span class="number">10000</span>; j += i) prime_table[j] = <span class="number">0</span>;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; prime[i] &lt;= n &amp;&amp; i &lt; prime.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i; s &lt; n &amp;&amp; j &lt; prime.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                s += prime[j]; <span class="comment">//不斷累加</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(s == n) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="smith-numbers">Smith Numbers</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10042">UVA 10042</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p><code>Smith Numbers</code> 的定義為原數字的各位數字和與其質因數分解的每個數字的各位數字和相同，ex: <code>4937775 = 3 · 5 · 5 · 65837</code> 且兩邊的各位數字和相同。輸入一個數字，求出大於該數字的最小 <code>Smith Numbers</code>。</p><mark class="hl-label default">解題方法</mark> <p>建立一個質數表，方便之後的質因數分解，從題目給出的數字開始增加，並且判斷是否為 <code>Smith Numbers</code>，每次質因數分解結束時可能會有三種情況需要分開討論：</p><ul><li>剩下 <code>1</code>，代表已經全部處理完畢。</li><li>剩下 <code>自己</code>，代表這個數字是質數 (沒有小於等於自己開根號的質數)。</li><li>剩下 <code>不是自己的質數</code>，把剩下數字的各位數字相加。</li></ul><p>之後比較兩邊數字是否相等，就能夠做出判斷。</p><mark class="hl-label default">注意事項</mark> <ul><li>質數不是 <code>Smith Numbers</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">p</span><span class="params">(<span class="number">100000</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">primeTable</span><span class="params">()</span></span>&#123; <span class="comment">//建立質數表</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">100000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i])&#123;</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + i; j &lt; <span class="number">100000</span>; j += i)&#123;</span><br><span class="line">                p[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">s</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//計算各位數字和</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(x != <span class="number">0</span>)&#123;</span><br><span class="line">        c += (x % <span class="number">10</span>);</span><br><span class="line">        x /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//檢查是否為 Smith Numbers</span></span><br><span class="line">    <span class="keyword">if</span>(x &lt; <span class="number">100000</span> &amp;&amp; p[x]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//該數為質數</span></span><br><span class="line">    <span class="type">int</span> c1 = <span class="built_in">s</span>(x), c2 = <span class="number">0</span>, tmp = x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; prime.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(x % prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> t = <span class="built_in">s</span>(prime[i]);</span><br><span class="line">            <span class="keyword">while</span>(x % prime[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                c2 += t;</span><br><span class="line">                x /= prime[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(x == tmp) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">//該數為質數</span></span><br><span class="line">    <span class="keyword">if</span>(x != <span class="number">1</span>) c2 += <span class="built_in">s</span>(x);</span><br><span class="line">    <span class="keyword">if</span>(c1 == c2) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">primeTable</span>();</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin &gt;&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = m + <span class="number">1</span>; i &lt;= INT_MAX; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i))&#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>約瑟夫問題</h1><h2 id="power-crisis">Power Crisis</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-151">UVA 151</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>基本上就是 <code>約瑟夫問題</code>，每次輸入一個大於 13 的人數 <code>n</code>，求出數字 <code>m</code> 做為每次跳過的人數，使得第 13 個人可以最後存活。</p><mark class="hl-label default">解題方法</mark> <p>遍歷 <code>1 ~ n</code> 的數字，使用約瑟夫問題的公式，計算最後存活的人並判斷是否正確。</p><mark class="hl-label default">注意事項</mark> <ul><li>約瑟夫問題公式要注意。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        k = (k + x) % i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (k == <span class="number">11</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(n, i))&#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="joseph-s-cousin">Joseph’s Cousin</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10015">UVA 10015</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p><code>約瑟夫問題</code> 的變體，每次輸入人數 <code>n</code>，並且第 <code>i</code> 次跳過的人數為第 <code>i</code> 個質數，ex:第一次跳 2 人，第二次跳 3 人，第三次跳 5 人…，求出最後剩下的人。</p><mark class="hl-label default">解題方法</mark> <p>把質數表建好，套上約瑟夫問題的公式，不過每次跳過的人數是質數表上對應的數字。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意套用公式的時候質數要由大到小帶入。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">v</span><span class="params">(<span class="number">100000</span>, <span class="literal">true</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prime</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; <span class="number">50000</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[i])&#123;</span><br><span class="line">            p.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(p.<span class="built_in">size</span>() == <span class="number">3501</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = i + i; k &lt;= <span class="number">50000</span>; k += i)&#123;</span><br><span class="line">                v[k] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">f</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        k = (k + p[n - i]) % i; <span class="comment">//由大到小</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">prime</span>();</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">f</span>(n) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>座標系</h1><h2 id="unique-lines">Unique lines</h2><mark class="hl-label default">題目大意</mark> <p>給定若干個平面上的點，求這幾個點可以產生多少不同的線。</p><mark class="hl-label default">解題方法</mark> <p>首先遍歷所有點，並儲存每條邊的斜率，以及經過的其中一個點，分別儲存兩點間在 <code>x</code> 和 <code>y</code> 軸的變化量，之後遍歷所有儲存的邊，檢查是否有重複邊。</p><mark class="hl-label default">注意事項</mark> <ul><li>如果是儲存斜率的話，可能會有正無限與負無限判斷的問題，分別儲存 <code>x</code> 和 <code>y</code> 軸的變化量可以避免這個問題。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, t;</span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        v.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; t;</span><br><span class="line">        <span class="type">int</span> arr[t][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; t; i++)&#123; <span class="comment">//遍歷所有點建立邊</span></span><br><span class="line">            cin &gt;&gt; arr[i][<span class="number">0</span>] &gt;&gt; arr[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                v.<span class="built_in">push_back</span>(&#123;arr[i][<span class="number">0</span>] - arr[j][<span class="number">0</span>], arr[i][<span class="number">1</span>] - arr[j][<span class="number">1</span>], arr[i][<span class="number">0</span>], arr[i][<span class="number">1</span>]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123; <span class="comment">//遍歷所有邊檢查重複</span></span><br><span class="line">            <span class="type">int</span> b = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; v.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[i][<span class="number">0</span>] * v[j][<span class="number">1</span>] != v[i][<span class="number">1</span>] * v[j][<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(v[i][<span class="number">0</span>] * (v[i][<span class="number">3</span>] - v[j][<span class="number">3</span>]) == v[i][<span class="number">1</span>] *(v[i][<span class="number">2</span>] - v[j][<span class="number">2</span>]))&#123;</span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b == <span class="number">1</span>) ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bee-maja">Bee Maja</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10182">UVA 10182</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>在一個六邊形的座標系中，有兩種表達格子的方式 (Maja’s &amp; Willi’s)，每次輸入一個數字 (Willi’s)，需要轉換成 <code>Maja’s</code> 座標表達方式輸出。</p><mark class="hl-label default">解題方法</mark> <p>觀察六邊形的右下那條邊，可以發現兩種表達方式都有規律，<code>Maja’s</code> 座標分別為 <code>&#123;0, 1&#125;, &#123;0, 1&#125;, &#123;0, 2&#125;...</code>，<code>Willi’s</code> 座標分別為 <code>1, 7, 19...</code> 可以發現他們的差為 6 的整數倍，根據規律可以提前把轉換的表建立好。</p><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, dir[<span class="number">6</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line">vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">200000</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">200</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> p = <span class="number">1</span> + i * (i + <span class="number">1</span>) * <span class="number">3</span>, x = i, y = <span class="number">0</span>;</span><br><span class="line">        v[p] = &#123;x, y&#125;; <span class="comment">//p 點對應座標</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; <span class="number">5</span>; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i; k++)&#123;</span><br><span class="line">                p--;</span><br><span class="line">                x += dir[j][<span class="number">0</span>];</span><br><span class="line">                y += dir[j][<span class="number">1</span>];</span><br><span class="line">                v[p] = &#123;x, y&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; i - <span class="number">1</span>; k++)&#123;</span><br><span class="line">            p--;</span><br><span class="line">            x += dir[<span class="number">5</span>][<span class="number">0</span>];</span><br><span class="line">            y += dir[<span class="number">5</span>][<span class="number">1</span>];</span><br><span class="line">            v[p] = &#123;x, y&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        cout &lt;&lt; v[n].first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; v[n].second &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>運算式</h1><h2 id="prefix-expression-evaluation">Prefix expression evaluation</h2><mark class="hl-label default">題目大意</mark> <p>根據輸入的前序表達式計算其結果，如果該表達式不合法則輸出 <code>illegal</code>。</p><mark class="hl-label default">解題方法</mark> <p>將輸入的字串由後往前檢查，如果是數字則放入 <code>stack</code> 中，如果是符號則取出 <code>stack</code> 頂部的兩個數字做運算，運算完之後再放回 <code>stack</code> 中，最後剩下的數字就是計算的結果，如果在運算的過程有遇到 <code>stack</code> 為空的情況代表表達式有錯誤。</p><mark class="hl-label default">注意事項</mark> <ul><li>遍歷字串的時候是由後往前的，因此處理數字的時候要注意。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, str) &amp;&amp; str != <span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">0</span>, t = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = str.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123; <span class="comment">//由後往前</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123; <span class="comment">//數字</span></span><br><span class="line">                n += t * (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                t *= <span class="number">10</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">&#x27; &#x27;</span>)&#123; <span class="comment">//空格</span></span><br><span class="line">                    <span class="keyword">if</span>(str[i + <span class="number">1</span>] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i + <span class="number">1</span>] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                        stk.<span class="built_in">push</span>(n);</span><br><span class="line">                        t = <span class="number">1</span>;</span><br><span class="line">                        n = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> n1 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> n2 = stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="type">int</span> tmp;</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span>) tmp = n1 + n2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span>) tmp = n1 - n2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;*&#x27;</span>) tmp = n1 * n2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;/&#x27;</span>) tmp = n1 / n2;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;%&#x27;</span>) tmp = n1 % n2;</span><br><span class="line">                stk.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(b == <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> ans = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(!stk.<span class="built_in">empty</span>()) cout &lt;&lt; <span class="string">&quot;illegal&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="camel-trading">Camel trading</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10700">UVA 10700</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>題目的輸入為一個式子，裡面只包含數字以及 <code>*</code>, <code>+</code> 兩個符號，可以隨意地在式子中加入括號，求出計算後所能得到的最大以及最小值。</p><mark class="hl-label default">解題方法</mark> <p>最大值一定是把所有有加號的數字先相加之後才相乘，最小值則是先處理相乘之後再相加，可以先將符號和數字分別儲存，後面再取出處理。</p><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">maxn</span><span class="params">(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; num, vector&lt;<span class="type">char</span>&gt; op)</span></span>&#123; <span class="comment">//先加後乘</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; op.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op[i] == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">            num[i + <span class="number">1</span>] += num[i];</span><br><span class="line">            num[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        num[i] *= num[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[num.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">minn</span><span class="params">(vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; num, vector&lt;<span class="type">char</span>&gt; op)</span></span>&#123; <span class="comment">//先乘後加</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; op.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(op[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            num[i + <span class="number">1</span>] *= num[i];</span><br><span class="line">            num[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; num.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        num[i] += num[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num[num.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        cin &gt;&gt; str;</span><br><span class="line">        vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; num;</span><br><span class="line">        vector&lt;<span class="type">char</span>&gt; op;</span><br><span class="line">        <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把數字和符號分開儲存</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str[i] == <span class="string">&#x27;+&#x27;</span> || str[i] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                op.<span class="built_in">push_back</span>(str[i]);</span><br><span class="line">                num.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> tmp = tmp * <span class="number">10</span> + (str[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        num.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;The maximum and minimum are &quot;</span> &lt;&lt; <span class="built_in">maxn</span>(num, op) &lt;&lt; <span class="string">&quot; and &quot;</span> &lt;&lt; <span class="built_in">minn</span>(num, op) &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPE筆記-3</title>
      <link href="/2025/01/27/GPE%E7%AD%86%E8%A8%98-3/"/>
      <url>/2025/01/27/GPE%E7%AD%86%E8%A8%98-3/</url>
      
        <content type="html"><![CDATA[<p>大概刷了 50 題左右 <a href="https://gpe-helper.setsal.dev/">GPE Helper</a> 上面比較常出現的題目，根據題目類型分類做一些筆記，方便之後複習。</p><mark class="hl-label default">Map</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>10579 Hay Points</td><td><a href="https://vjudge.net/problem/UVA-10295">10295</a></td></tr><tr><td>10520 Conformity</td><td><a href="https://vjudge.net/problem/UVA-11286">11286</a></td></tr></tbody></table><mark class="hl-label default">Array</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>21964 Fill the Containers</td><td><a href="https://vjudge.net/problem/UVA-11413">11413</a></td></tr><tr><td>23551 Largest Square</td><td><a href="https://vjudge.net/problem/UVA-10908">10908</a></td></tr><tr><td>10437 Zeros and Ones</td><td><a href="https://vjudge.net/problem/UVA-10324">10324</a></td></tr></tbody></table><mark class="hl-label default">暴力法</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>10655 Sumsets</td><td><a href="https://vjudge.net/problem/UVA-10125">10125</a></td></tr><tr><td>10417 The Hotel with Infinite Rooms</td><td><a href="https://vjudge.net/problem/UVA-10170">10170</a></td></tr><tr><td>22351 Quirksome Squares</td><td><a href="https://vjudge.net/problem/UVA-256">256</a></td></tr></tbody></table><h1>Map</h1><h2 id="hay-points">Hay Points</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10295">UVA 10295</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>首先會列出數個單字以及其所對應的價值，之後會有幾段文字，根據文字中出現的單字計算其總價值，如果單字沒有寫出其對應價值，代表價值為 0。</p><mark class="hl-label default">解題方法</mark> <p>使用 <code>Map</code> 儲存列出的單字以及其價值，之後遍歷整段文字，利用 <code>count</code> 判斷單字的價值並加總。</p><mark class="hl-label default">注意事項</mark> <ul><li>要判斷的文字可能有多行，並且用 <code>.</code> 間隔。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m, n, k;</span><br><span class="line">string str;</span><br><span class="line">map&lt;string, <span class="type">int</span>&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m &gt;&gt; n;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; str &gt;&gt; k;</span><br><span class="line">        dict[str] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="type">int</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(cin &gt;&gt; str &amp;&amp; str != <span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dict.<span class="built_in">count</span>(str) != <span class="number">0</span>) c += dict[str]; <span class="comment">//檢查是否有價值</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="conformity">Conformity</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-11286">UVA 11286</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>輸入包含若干行，每行有五個數字代表學生修習的課程，找到最多人選擇的課程組合有幾個學生選擇，如果有兩個或以上的組合有相同數量的學生選擇，則將他們的選擇人數相加。</p><mark class="hl-label default">解題方法</mark> <ul><li>將輸入的五個課程排序之後作為 <code>Map</code> 的 key，並且每次更新 <code>Map</code> 時紀錄最多人選擇的組合有幾人選擇，之後利用 <code>iterator</code> 遍歷 <code>Map</code> 統計人數。</li><li>也可以選擇將課程排序之後轉為 <code>string</code> 並作為 <code>Map</code> 的 key。</li></ul><mark class="hl-label default">注意事項</mark> <ul><li>一定要將輸入的課程排序之後再儲存。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        map&lt;vector&lt;<span class="type">int</span>&gt;, <span class="type">int</span>&gt; m;</span><br><span class="line">        <span class="type">int</span> ma = <span class="number">-1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">                cin &gt;&gt; v[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>()); <span class="comment">//排序</span></span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(v) != <span class="number">0</span>) m[v]++;</span><br><span class="line">            <span class="keyword">else</span> m[v] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(m[v] &gt; ma) ma = m[v];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); i != m.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i-&gt;second == ma) c += (i-&gt;second);</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Array</h1><h2 id="fill-the-containers">Fill the Containers</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-11413">UVA 11413</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>有好幾瓶不同容量的牛奶，現在要將其重新分配到幾個瓶子中，每瓶牛奶只能裝到一個瓶子中，不能分配到好幾個瓶子裡，而且只能按照牛奶的順序進行分配，求分配後最大容量的瓶子所需的最小值。<br>ex:<br>3 瓶牛奶容量分別為 <code>4, 78, 9</code>，分配到 2 瓶子中，最大容量的瓶子最少需要 <code>4 + 78 = 82</code>，不能分成 <code>4 + 9, 78</code> 因為這樣沒有按照順序。</p><mark class="hl-label default">解題方法</mark> <p>使用二分搜尋，每次判斷是否能夠滿足分配規則，不能滿足就把數字放大，否則把數字縮小，直到找到最小的容量。</p><mark class="hl-label default">注意事項</mark> <ul><li>紀錄牛奶容量的總和可以作為二分搜尋的上限。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(<span class="number">1000</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123; <span class="comment">//檢查是否滿足分配規則</span></span><br><span class="line">    <span class="type">int</span> c = <span class="number">0</span>, tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(tmp + v[i] &gt; x)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[i] &gt; x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tmp = v[i];</span><br><span class="line">            c++;</span><br><span class="line">        &#125;<span class="keyword">else</span> tmp += v[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (c + <span class="number">1</span> &lt;= m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            r += v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(r &gt; l)&#123; <span class="comment">//二分搜尋</span></span><br><span class="line">            <span class="type">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(mid, n, m)) r = mid;</span><br><span class="line">            <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="largest-square">Largest Square</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10908">UVA 10908</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一個二維矩陣，裡面包含不同字母，之後輸入一個座標，求以該座標為中心的同字母正方形之最大邊長。</p><mark class="hl-label default">解題方法</mark> <p>由中心開始，每次往外檢查一圈，直到出現不同的字母就停下。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意陣列的邊界。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; v, <span class="type">int</span> r, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span> t = v[r][c];</span><br><span class="line">    <span class="keyword">for</span>(; i &lt; <span class="built_in">max</span>(v.<span class="built_in">size</span>(), v[<span class="number">0</span>].<span class="built_in">size</span>()); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(r + i &gt;= v.<span class="built_in">size</span>() || r - i &lt; <span class="number">0</span> || c + i &gt;= v[<span class="number">0</span>].<span class="built_in">size</span>() || c - i &lt; <span class="number">0</span>) <span class="keyword">break</span>; <span class="comment">//檢查邊界</span></span><br><span class="line">        <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; i * <span class="number">2</span>; j++)&#123; <span class="comment">//檢查最外圈</span></span><br><span class="line">            <span class="keyword">if</span>(v[r + i][c - i + j] != t || v[r + i - j][c + i] != t || v[r - i][c + i - j] != t || v[r - i + j][c - i] != t) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j != i * <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> t, m, n, q, r, c;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        cin &gt;&gt; m &gt;&gt; n &gt;&gt; q;</span><br><span class="line">        cout &lt;&lt; m &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; n &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; q &lt;&lt; endl;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">v</span>(m, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                cin &gt;&gt; v[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            cin &gt;&gt; r &gt;&gt; c;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">solve</span>(v, r, c) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="zeros-and-ones">Zeros and Ones</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10324">UVA 10324</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一個由 <code>0</code> 和 <code>1</code> 組成的字串，之後會有數個查詢，每次查詢一個範圍內的數字是否都是相同的，如果範圍內都是同樣的 <code>0</code> 或是 <code>1</code> 則返回正確，否則返回錯誤。</p><mark class="hl-label default">解題方法</mark> <p>另外建立一個陣列儲存前綴和，並利用區間的數字總和判斷區間內是否都是 <code>0</code> 或是 <code>1</code>。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意區間總和的計算。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"><span class="type">int</span> c = <span class="number">1</span>, q, a, b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">        c++;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(str.size() + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            v[i + <span class="number">1</span>] = v[i] + (str[i] - <span class="string">&#x27;0&#x27;</span>); <span class="comment">//計算前綴和</span></span><br><span class="line">        &#125;</span><br><span class="line">        cin &gt;&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(q--)&#123;</span><br><span class="line">            cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">            <span class="keyword">if</span>(v[a] == v[b + <span class="number">1</span>] || v[a] + b - a + <span class="number">1</span> == v[b + <span class="number">1</span>]) cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl; <span class="comment">//判斷區間總和</span></span><br><span class="line">            <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>暴力法</h1><div class="note primary no-icon flat"><p>有些題目看似需要去想一些演算法來處理，實際上數字範圍不大，可以直接用暴力的方式去解。</p></div><h2 id="sumsets">Sumsets</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10125">UVA 10125</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一串數字，在這些數字中取出四個不重複數字，使得 <code>a + b + c = d</code>，求出最大可能的 <code>d</code>。</p><mark class="hl-label default">解題方法</mark> <ul><li>將數字排序之後，由大到小將數字做為 <code>d</code> 並檢查，如果滿足條件則退出。</li><li>更好的作法可以解 <code>a + b = d - c</code>。</li></ul><mark class="hl-label default">注意事項</mark> <ul><li>注意數字不能重複，而且 <code>d</code> 可能是負值。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = n - <span class="number">1</span>; d &gt;= <span class="number">0</span>; d--)&#123; <span class="comment">//d 由大到小</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> c = <span class="number">0</span>; c &lt; n; c++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(c == d) <span class="keyword">continue</span>; <span class="comment">//避免重複</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> b = c + <span class="number">1</span>; b &lt; n; b++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(b == d) <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> a = b + <span class="number">1</span>; a &lt; n; a++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(a == d) <span class="keyword">continue</span>;</span><br><span class="line">                        <span class="keyword">if</span>(v[a] + v[b] + v[c] == v[d])&#123;</span><br><span class="line">                            ans = v[d];</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(ans != INT_MIN) <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(ans != INT_MIN) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans != INT_MIN) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans != INT_MIN) cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;no solution&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-hotel-with-infinite-rooms">The Hotel with Infinite Rooms</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10170">UVA 10170</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>有一間有無限房間的飯店，並且有好幾團旅客依照特定的規則入住：每一團都比前一團多住一天，並且每次只會有一團旅客入住，現在給定第一團旅客所住的天數，求第 <code>n</code> 天是第幾團旅客正在住。</p><mark class="hl-label default">解題方法</mark> <p>不斷累加旅客所住的時間，直到超過所求天數 <code>n</code> 為止。</p><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="type">long</span> s, d;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; s &gt;&gt; d)&#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = s;;i++)&#123;</span><br><span class="line">            c += i;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= d)&#123;</span><br><span class="line">                cout &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="quirksome-squares">Quirksome Squares</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-256">UVA 256</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>有一種特殊的數字 <code>x</code> 有 <code>2n</code> 位數，可以分成兩個 <code>n</code> 位數 <code>a、b</code>，並且滿足 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>+</mo><msup><mi>b</mi><mn>2</mn></msup><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex">a^2 + b^2 = x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span> ，ex: <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>3</mn><msup><mn>0</mn><mn>2</mn></msup><mo>+</mo><mn>2</mn><msup><mn>5</mn><mn>2</mn></msup><mo>=</mo><mn>3025</mn></mrow><annotation encoding="application/x-tex">30^2 + 25^2 = 3025</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.897438em;vertical-align:-0.08333em;"></span><span class="mord">3</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord"><span class="mord">5</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">3</span><span class="mord">0</span><span class="mord">2</span><span class="mord">5</span></span></span></span>，每次會輸入一個數字 <code>2n</code>，求出所有 <code>2n</code> 位數的特殊數字。</p><mark class="hl-label default">解題方法</mark> <p>接收輸入前先把 <code>2, 4, 6, 8</code> 位數的表先建立好，其實就是遍歷範圍內的數字做檢查。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意題目要求位數不夠的話要補 <code>0</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">v</span>(<span class="number">4</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="type">int</span> n, d[<span class="number">4</span>] = &#123;<span class="number">10</span>, <span class="number">100</span>, <span class="number">1000</span>, <span class="number">10000</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)&#123; <span class="comment">//建表</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; d[k]; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; d[k]; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>((i + j) * (i + j) == (i * d[k] + j))&#123;</span><br><span class="line">                    v[k].<span class="built_in">push_back</span>((i + j) * (i + j));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v[n / <span class="number">2</span> - <span class="number">1</span>].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="built_in">printf</span>(<span class="string">&quot;%02d\n&quot;</span>, v[<span class="number">0</span>][i]); <span class="comment">//補 0</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">&quot;%04d\n&quot;</span>, v[<span class="number">1</span>][i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">&quot;%06d\n&quot;</span>, v[<span class="number">2</span>][i]);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%08d\n&quot;</span>, v[<span class="number">3</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPE筆記-2</title>
      <link href="/2025/01/26/GPE%E7%AD%86%E8%A8%98-2/"/>
      <url>/2025/01/26/GPE%E7%AD%86%E8%A8%98-2/</url>
      
        <content type="html"><![CDATA[<p>大概刷了 50 題左右 <a href="https://gpe-helper.setsal.dev/">GPE Helper</a> 上面比較常出現的題目，根據題目類型分類做一些筆記，方便之後複習。</p><mark class="hl-label default">DFS&BFS</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>11006 Rank the Languages</td><td><a href="https://vjudge.net/problem/UVA-10336">10336</a></td></tr><tr><td>22171 Dungeon Master</td><td><a href="https://vjudge.net/problem/UVA-532">532</a></td></tr></tbody></table><mark class="hl-label default">Tree&Graph</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>2009-17 Binary tree traversals</td><td></td></tr><tr><td>10038 Disk Tree</td><td><a href="https://vjudge.net/problem/UVA-1556">1556</a></td></tr><tr><td>10602 Longest Paths</td><td><a href="https://vjudge.net/problem/UVA-10000">10000</a></td></tr><tr><td>24731 Roads in the North</td><td><a href="https://vjudge.net/problem/UVA-10308">10308</a></td></tr></tbody></table><h1>DFS &amp; BFS</h1><h2 id="rank-the-languages">Rank the Languages</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10336">UVA 10336</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一張地圖，上面標有小寫英文字母，字母 <code>k</code> 的區域代表裡面所有的字母皆為字母 <code>k</code>，要求計算每個字母所有的區域數量，並且將他們排序。</p><mark class="hl-label default">解題方法</mark> <p>每次使用 <code>DFS</code> 尋找相鄰的相同字母，並將其標示為其他字元 (題目中不會使用到的) 代表已經處理過，使用 <code>vector</code> 來儲存每個字母的區域數量，最後用自訂的 <code>cmp</code> 函數來排序。</p><mark class="hl-label default">注意事項</mark> <ul><li>DFS 的條件記得要加上 <code>與當前字母相同</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, h, w, dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p1, pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt; p2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.second != p2.second) <span class="keyword">return</span> p1.second &gt; p2.second;</span><br><span class="line">    <span class="keyword">return</span> p1.first &lt; p2.first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; &amp;world, <span class="type">int</span> x, <span class="type">int</span> y, <span class="type">char</span> cur)</span></span>&#123;</span><br><span class="line">    world[x][y] = <span class="string">&#x27;A&#x27;</span>; <span class="comment">//改為用不到的字母</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</span><br><span class="line">        <span class="type">int</span> nx = x + dir[i][<span class="number">0</span>], ny = y + dir[i][<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; h &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; w &amp;&amp; world[nx][ny] != <span class="string">&#x27;A&#x27;</span> &amp;&amp; cur == world[nx][ny])&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(world, nx, ny, cur);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        cin &gt;&gt; h &gt;&gt; w;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">char</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">char</span>&gt;&gt; <span class="built_in">world</span>(h, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(w));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; h; p++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> q = <span class="number">0</span>; q &lt; w; q++)&#123;</span><br><span class="line">                cin &gt;&gt; world[p][q];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> p = <span class="number">0</span>; p &lt; h; p++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> q = <span class="number">0</span>; q &lt; w; q++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(world[p][q] != <span class="string">&#x27;A&#x27;</span>)&#123; <span class="comment">//當前位置還沒處理過</span></span><br><span class="line">                    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; v.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">                        <span class="keyword">if</span>(v[k].first == world[p][q])&#123;</span><br><span class="line">                            (v[k].second)++;</span><br><span class="line">                            b = <span class="number">1</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(b == <span class="number">0</span>) v.<span class="built_in">push_back</span>(&#123;world[p][q], <span class="number">1</span>&#125;);</span><br><span class="line">                    <span class="built_in">dfs</span>(world, p, q, world[p][q]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp); <span class="comment">//照區域數量排序</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;World #&quot;</span> &lt;&lt; i &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; v.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">            cout &lt;&lt; v[k].first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; v[k].second &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dungeon-master">Dungeon Master</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-532">UVA 532</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一個三維的迷宮，求出是否能夠從起點到達終點，如果可以的話必須印出最短時間。</p><mark class="hl-label default">解題方法</mark> <p>從起點開始用 <code>BFS</code> 尋找路徑，如果能夠到達終點，此時的時間一定是最短的。</p><mark class="hl-label default">注意事項</mark> <ul><li><code>BFS</code> 時可以前進的方向有 6 個。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> l, r, c, ans, dir[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&gt;&amp; v, vector&lt;<span class="type">int</span>&gt; s, vector&lt;<span class="type">int</span>&gt; e)</span> </span>&#123;</span><br><span class="line">    queue&lt;vector&lt;<span class="type">int</span>&gt;&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;s[<span class="number">0</span>], s[<span class="number">1</span>], s[<span class="number">2</span>], <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="type">int</span> x = (q.<span class="built_in">front</span>())[<span class="number">0</span>], y = (q.<span class="built_in">front</span>())[<span class="number">1</span>], z = (q.<span class="built_in">front</span>())[<span class="number">2</span>], step = (q.<span class="built_in">front</span>())[<span class="number">3</span>];</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(x == e[<span class="number">0</span>] &amp;&amp; y == e[<span class="number">1</span>] &amp;&amp; z == e[<span class="number">2</span>]) <span class="keyword">return</span> step;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> d = <span class="number">0</span>; d &lt; <span class="number">6</span>; d++)&#123;</span><br><span class="line">            <span class="type">int</span> nx = x + dir[d][<span class="number">0</span>], ny = y + dir[d][<span class="number">1</span>], nz = z + dir[d][<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span>(nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; l &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; r &amp;&amp; nz &gt;= <span class="number">0</span> &amp;&amp; nz &lt; c &amp;&amp; v[nx][ny][nz] != <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                v[nx][ny][nz] = <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;nx, ny, nz, step + <span class="number">1</span>&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; l &gt;&gt; r &gt;&gt; c &amp;&amp; l != <span class="number">0</span> &amp;&amp; r != <span class="number">0</span> &amp;&amp; c != <span class="number">0</span>)&#123;</span><br><span class="line">        ans = <span class="number">30000</span>;</span><br><span class="line">        vector&lt;vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;&gt; <span class="built_in">v</span>(l, vector&lt;vector&lt;<span class="type">char</span>&gt;&gt;(r, <span class="built_in">vector</span>&lt;<span class="type">char</span>&gt;(c)));</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(<span class="number">3</span>)</span>, <span class="title">e</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; l; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; r; j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; c; k++)&#123;</span><br><span class="line">                    cin &gt;&gt; v[i][j][k];</span><br><span class="line">                    <span class="keyword">if</span>(v[i][j][k] == <span class="string">&#x27;S&#x27;</span>) s = &#123;i, j, k&#125;;</span><br><span class="line">                    <span class="keyword">if</span>(v[i][j][k] == <span class="string">&#x27;E&#x27;</span>) e = &#123;i, j, k&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans = <span class="built_in">bfs</span>(v, s, e);</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">-1</span>) cout &lt;&lt; <span class="string">&quot;Trapped!&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Escaped in &quot;</span> &lt;&lt; ans &lt;&lt; <span class="string">&quot; minute(s).&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Tree &amp; Graph</h1><h2 id="binary-tree-traversals">Binary tree traversals</h2><mark class="hl-label default">題目大意</mark> <p>已知一個二元樹的前序和中序遍歷，求出其後序遍歷。</p><mark class="hl-label default">解題方法</mark> <p>利用遞迴重構出二元樹，之後求後續遍歷並輸出。</p><mark class="hl-label default">注意事項</mark> <ul><li>重構樹的過程要注意左右子樹的元素數量。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">char</span> c;</span><br><span class="line">    node* left;</span><br><span class="line">    node* right;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">char</span> k)&#123;</span><br><span class="line">        c = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">node* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">char</span>&gt; pre, vector&lt;<span class="type">char</span>&gt; in, <span class="type">int</span> pre_l, <span class="type">int</span> pre_r, <span class="type">int</span> in_l, <span class="type">int</span> in_r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre_l &gt; pre_r || in_l &gt; in_r) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = in_l; i &lt;= in_r; i++)&#123; <span class="comment">//求左子樹的元素數量</span></span><br><span class="line">        <span class="keyword">if</span>(pre[pre_l] == in[i])&#123;</span><br><span class="line">            len = i - in_l;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node* root = <span class="keyword">new</span> <span class="built_in">node</span>(pre[pre_l]);</span><br><span class="line">    root -&gt; left = <span class="built_in">buildTree</span>(pre, in, pre_l + <span class="number">1</span>, pre_l + len, in_l, in_l + len - <span class="number">1</span>); <span class="comment">//重構左子樹</span></span><br><span class="line">    root -&gt; right = <span class="built_in">buildTree</span>(pre, in, pre_l + len + <span class="number">1</span>, pre_r, in_l + len + <span class="number">1</span>, in_r); <span class="comment">//重構右子樹</span></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">postorder</span><span class="params">(node* root)</span></span>&#123; <span class="comment">//後序遍歷</span></span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">postorder</span>(root -&gt; left);</span><br><span class="line">    <span class="built_in">postorder</span>(root -&gt; right);</span><br><span class="line">    cout &lt;&lt; root -&gt; c &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">char</span>&gt; <span class="title">pre</span><span class="params">(n)</span>, <span class="title">in</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; pre[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; in[i];</span><br><span class="line">        &#125;</span><br><span class="line">        node* root = <span class="built_in">buildTree</span>(pre, in, <span class="number">0</span>, n - <span class="number">1</span>, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">postorder</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="disk-tree">Disk Tree</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-1556">UVA 1556</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定許多行的資料夾路徑，輸出所有資料夾的結構，同一層內資料夾依照字典序排列，並且根據層級補上對應的空格。</p><mark class="hl-label default">解題方法</mark> <p>輸入時把 <code>\</code> 替換為空格，並且利用 <code>stringstream</code> 分割每個資料夾，使用 <code>字典樹</code> 儲存資料夾，最後 <code>DFS</code> 遍歷每個節點中的 <code>Map</code> 以達到照字典序排列的要求。</p><div class="note info flat"><p>補充資料： <a href="https://douobb.github.io/2025/01/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E5%AD%97%E5%85%B8%E6%A8%B9/">演算法筆記-字典樹</a></p></div><mark class="hl-label default">注意事項</mark> <ul><li>字典樹的結構比較複雜，需要多留意。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name;</span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; nextNode;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">node</span>(string s)&#123;</span><br><span class="line">        name = s;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(vector&lt;string&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dict[cur].nextNode).<span class="built_in">count</span>(v[i]) == <span class="number">0</span>)&#123; <span class="comment">//沒有此資料夾</span></span><br><span class="line">            dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>(v[i]));</span><br><span class="line">            dict[cur].nextNode[v[i]] = dict.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dict[cur].nextNode[v[i]];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; d; i++)&#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dict[cur].name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(dict[cur].nextNode).<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k = dict[cur].nextNode.<span class="built_in">begin</span>(); k != dict[cur].nextNode.<span class="built_in">end</span>(); k++)&#123; <span class="comment">//照字典序遍歷</span></span><br><span class="line">            <span class="built_in">dfs</span>(k -&gt; second, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string str, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        dict.<span class="built_in">clear</span>();</span><br><span class="line">        dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>(<span class="string">&quot;&quot;</span>));</span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">&#x27;\\&#x27;</span>) str[i] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//替換為空格</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">            vector&lt;string&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; s)&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insertNode</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="longest-paths">Longest Paths</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10000">UVA 10000</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一張有向的無環圖以及起點，保證從起點可以到任何一個點，求出離起點最遠的點以及距離。</p><mark class="hl-label default">解題方法</mark> <p>將邊權設為 <code>-1</code>，因為是無環圖所以不用擔心負環，使用 <code>Bellman-Ford Algorithm</code> 求出最短的距離，之後再將距離轉為正數就是題目要求的最遠距離。</p><mark class="hl-label default">注意事項</mark> <ul><li>邊權為負時不能用 <code>Dijkstra 演算法</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v, <span class="type">int</span> n, <span class="type">int</span> s, <span class="type">int</span> c)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n, INT_MAX)</span></span>;</span><br><span class="line">    dis[s - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dis[v[i].first] - <span class="number">1</span> &lt; dis[v[i].second])&#123;</span><br><span class="line">                dis[v[i].second] = dis[v[i].first] - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = INT_MAX, ans;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; dis.<span class="built_in">size</span>(); i++)&#123; <span class="comment">//找最小值</span></span><br><span class="line">        <span class="keyword">if</span>(dis[i] &lt; m)&#123;</span><br><span class="line">            ans = i;</span><br><span class="line">            m = dis[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Case &quot;</span> &lt;&lt; c &lt;&lt; <span class="string">&quot;: The longest path from &quot;</span> &lt;&lt; s &lt;&lt; <span class="string">&quot; has length &quot;</span> &lt;&lt; -m &lt;&lt; <span class="string">&quot;, finishing at &quot;</span> &lt;&lt; ans + <span class="number">1</span> &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, s, a, b, c = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        c++;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; v;</span><br><span class="line">        <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b &amp;&amp; a != <span class="number">0</span> &amp;&amp; b != <span class="number">0</span>)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(&#123;a - <span class="number">1</span>, b - <span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>(v, n, s, c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="roads-in-the-north">Roads in the North</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10308">UVA 10308</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一棵樹，求出樹中最長的兩點距離。</p><mark class="hl-label default">解題方法</mark> <p>題意同求樹的直徑 (最長兩點距離)，隨便選一個點作為根開始，利用 <code>DFS</code> 遍歷每個點，將遍歷到的點作為中繼點，求其離葉節點的最長與次長距離，相加並與當前最大值比較。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意輸入的格式，不同的 case 間以空行區隔。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">addRoad</span><span class="params">(string str, vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; adj[])</span></span>&#123;</span><br><span class="line">    <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">    <span class="type">int</span> a, b, c;</span><br><span class="line">    ss &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">    adj[a].<span class="built_in">push_back</span>(&#123;b, c&#125;);</span><br><span class="line">    adj[b].<span class="built_in">push_back</span>(&#123;a, c&#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dfs</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; adj[], <span class="type">int</span> x, <span class="type">int</span> px, <span class="type">int</span> &amp;d)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> h1 = <span class="number">0</span>, h2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; adj[x].<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(adj[x][i].first != px)&#123;</span><br><span class="line">            <span class="type">int</span> h = <span class="built_in">dfs</span>(adj, adj[x][i].first, x, d) + adj[x][i].second;</span><br><span class="line">            <span class="keyword">if</span>(h &gt; h1)&#123; <span class="comment">//檢查是否為最長、次長邊</span></span><br><span class="line">                h2 = h1;</span><br><span class="line">                h1 = h;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(h &gt; h2) h2 = h;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d = <span class="built_in">max</span>(d, h1 + h2); <span class="comment">//檢查是否是最長距離</span></span><br><span class="line">    <span class="keyword">return</span> h1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, str))&#123;</span><br><span class="line">        <span class="type">int</span> d = <span class="number">0</span>;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; adj[<span class="number">10001</span>];</span><br><span class="line">        <span class="built_in">addRoad</span>(str, adj);</span><br><span class="line">        <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, str) &amp;&amp; str != <span class="string">&quot;\0&quot;</span>)&#123;</span><br><span class="line">            <span class="built_in">addRoad</span>(str, adj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(adj, <span class="number">1</span>, <span class="number">1</span>, d);</span><br><span class="line">        cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GPE筆記-1</title>
      <link href="/2025/01/24/GPE%E7%AD%86%E8%A8%98-1/"/>
      <url>/2025/01/24/GPE%E7%AD%86%E8%A8%98-1/</url>
      
        <content type="html"><![CDATA[<p>大概刷了 50 題左右 <a href="https://gpe-helper.setsal.dev/">GPE Helper</a> 上面比較常出現的題目，根據題目類型分類做一些筆記，方便之後複習。</p><mark class="hl-label default">字串處理</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>24941 Uncompress</td><td><a href="https://vjudge.net/problem/UVA-245">245</a></td></tr><tr><td>11041 Children’s Game</td><td><a href="https://vjudge.net/problem/UVA-10905">10905</a></td></tr><tr><td>10582 Power Strings</td><td><a href="https://vjudge.net/problem/UVA-10298">10298</a></td></tr></tbody></table><mark class="hl-label default">動態規劃</mark> <table><thead><tr><th>Problem</th><th>UVA</th></tr></thead><tbody><tr><td>23681 Bachet’s Game</td><td><a href="https://vjudge.net/problem/UVA-10404">10404</a></td></tr><tr><td>22181 Dollars</td><td><a href="https://vjudge.net/problem/UVA-147">147</a></td></tr><tr><td>2008-28 Longest monotonically increasing subsequence</td><td></td></tr><tr><td>10621 Luggage</td><td><a href="https://vjudge.net/problem/UVA-10664">10664</a></td></tr><tr><td>23651 The jackpot</td><td><a href="https://vjudge.net/problem/UVA-10684">10684</a></td></tr></tbody></table><h1>字串處理</h1><h2 id="uncompress">Uncompress</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-245">UVA 245</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>介紹了一種文本壓縮的方式，每次遇到重新單字時，將其移入一個 <code>list</code> 的最前方，如果遇到已經出現過的單字，則以其在 <code>list</code> 中的位置來代替該單字，並且將其在 <code>list</code> 中再次移到最前方。現在給定一段壓縮文本，要求將其復原。</p><mark class="hl-label default">解題方法</mark> <p>用 <code>getline</code> 處理輸入，儲存使用 <code>vector</code> 來實現，用 <code>erase</code>、<code>push_back</code> 函數來處理 <code>vector</code> 中的單字。</p><mark class="hl-label default">注意事項</mark> <ul><li>可能會有符號與單字、數字相連的情況。</li><li>輸入可能有空行。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str, ans, tmp;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">getline</span>(cin, str) &amp;&amp; str != <span class="string">&quot;0&quot;</span>)&#123;</span><br><span class="line">        ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        str += <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        n = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; str.<span class="built_in">size</span>(); k++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((str[k] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; str[k] &lt;= <span class="string">&#x27;z&#x27;</span> ) || (str[k] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; str[k] &lt;= <span class="string">&#x27;Z&#x27;</span> ))&#123; <span class="comment">//字母</span></span><br><span class="line">                tmp += str[k];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(str[k] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[k] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123; <span class="comment">//數字</span></span><br><span class="line">                n = n * <span class="number">10</span> + (str[k] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123; <span class="comment">//空格、符號、換行</span></span><br><span class="line">                <span class="keyword">if</span>(n != <span class="number">0</span>)&#123;</span><br><span class="line">                    ans += v[v.<span class="built_in">size</span>() - n];</span><br><span class="line">                    v.<span class="built_in">push_back</span>(v[v.<span class="built_in">size</span>() - n]);</span><br><span class="line">                    v.<span class="built_in">erase</span>(v.<span class="built_in">begin</span>() + (v.<span class="built_in">size</span>() - n - <span class="number">1</span>));</span><br><span class="line">                    n = <span class="number">0</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp != <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                    ans += tmp;</span><br><span class="line">                    v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                    tmp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                ans += str[k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="children-s-game">Children’s Game</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10905">UVA 10905</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定一串數字，求出這些數字排列可以組合出的最大值。</p><mark class="hl-label default">解題方法</mark> <p>利用自訂的排序函數 <code>cmp</code> 將數字排序。</p><mark class="hl-label default">注意事項</mark> <ul><li>直接將輸入值以 <code>string</code> 儲存而不是用 <code>int</code> 可以方便比較。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string str1, string str2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str1 + str2 &gt; str2 + str1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="function">vector&lt;string&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cout &lt;&lt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="power-strings">Power Strings</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10298">UVA 10298</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>求出一個字串的最大循環次數。<br>ex:<br>aaaaa : 5<br>ababab : 3<br>abcd : 1</p><mark class="hl-label default">解題方法</mark> <p>尋找字串長度的因數，並使用 <code>substr</code> 取子字串進行檢查。</p><mark class="hl-label default">注意事項</mark> <ul><li><code>substr</code> 的參數使用為 <code>str.substr(起點, 長度)</code> 而非 <code>str.substr(起點, 終點)</code>。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string str;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> l = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &gt;= <span class="number">1</span>; i--)&#123; <span class="comment">//由大到小</span></span><br><span class="line">        <span class="keyword">if</span>(l % i == <span class="number">0</span>)&#123; <span class="comment">//因數</span></span><br><span class="line">            <span class="type">bool</span> b = <span class="literal">true</span>;</span><br><span class="line">            string tmp = str.<span class="built_in">substr</span>(<span class="number">0</span>, l / i); <span class="comment">//取第一個子字串</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp != str.<span class="built_in">substr</span>(j * (l / i), l / i))&#123; <span class="comment">//比對</span></span><br><span class="line">                    b = <span class="literal">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(b) <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; str &amp;&amp; str != <span class="string">&quot;.&quot;</span>)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="built_in">solve</span>(str) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>動態規劃</h1><h2 id="bachet-s-game">Bachet’s Game</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10404">UVA 10404</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>取石頭遊戲，給定特定數量的石頭，並且兩人輪流取石頭，能取的石頭數量為固定的幾個值，假設兩人都做出最佳選擇，求最後的勝利者。</p><mark class="hl-label default">解題方法</mark> <p>使用一個 <code>vector</code> 儲存 <code>剩餘 i 個石頭時的勝利者</code>，並利用動態規劃更新。</p><mark class="hl-label default">注意事項</mark> <ul><li>注意 <code>dp[0]</code> 的初始化。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &gt;&gt; m)&#123;</span><br><span class="line">        <span class="type">int</span> arr[m];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">            cin &gt;&gt; arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// i = 0 時第二個人勝利</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i - arr[j] &gt;= <span class="number">0</span> &amp;&amp; dp[i - arr[j]] == <span class="number">0</span>) dp[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[n]) cout &lt;&lt; <span class="string">&quot;Stan wins&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;Ollie wins&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="dollars">Dollars</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-147">UVA 147</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給定特定金額，求出可以湊出該金額的方法數。</p><mark class="hl-label default">解題方法</mark> <p>使用一個 <code>vector</code> 儲存 <code>湊出金額 i 的方法數</code>，並根據輸入來輸出對應的方法數。</p><mark class="hl-label default">注意事項</mark> <ul><li>組合數量可能超過 int 範圍。</li><li>金額有小數點，儲存在表格時必須乘以 100，由小數點轉為整數時，可能會有精度的誤差，因此要加上 <code>0.5</code> 避免錯誤 (或是也可以處理輸入時分成整數與小數兩個部分)。</li><li>注意輸出格式，可以用 <code>printf</code> 方便處理。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;<span class="type">long</span> <span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">30001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="type">int</span> c[<span class="number">11</span>] = &#123;<span class="number">10000</span>, <span class="number">5000</span>, <span class="number">2000</span>, <span class="number">1000</span>, <span class="number">500</span>, <span class="number">200</span>, <span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="type">double</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">10</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = c[i]; j &lt;= <span class="number">30000</span>; j++)&#123;</span><br><span class="line">            dp[j] += dp[j - c[i]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%6.2f%17lld\n&quot;</span>, n, dp[(<span class="type">int</span>)(n * <span class="number">100</span> + <span class="number">0.5</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="longest-monotonically-increasing-subsequence">Longest monotonically increasing subsequence</h2><mark class="hl-label default">題目大意</mark> <p>給定一串數字，求出 <code>LIS</code> 的數量，並且印出所有 <code>LIS</code>。</p><mark class="hl-label default">解題方法</mark> <ul><li>先利用動態規劃求每個位置結尾的 <code>LIS</code> 長度，之後利用遞迴回推的方式列印出所有 <code>LIS</code>。</li><li>因為數字最多只有 9 個，因此也可以直接暴力求解。</li></ul><mark class="hl-label default">注意事項</mark> <ul><li>注意 <code>LIS</code> 數量的計算方式以及回推的方法。</li></ul><mark class="hl-label default">程式碼1</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt; dp, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; path)</span></span>&#123;</span><br><span class="line">    path.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">    <span class="keyword">if</span>(dp[i] == <span class="number">1</span>)&#123; <span class="comment">//回推到底</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = path.<span class="built_in">size</span>() - <span class="number">1</span>; k &gt;= <span class="number">0</span>; k--)&#123;</span><br><span class="line">            cout &lt;&lt; path[k] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--)&#123;</span><br><span class="line">            <span class="keyword">if</span>(v[j] &lt; v[i] &amp;&amp; dp[j] + <span class="number">1</span> == dp[i]) <span class="built_in">printLIS</span>(v, dp, j, path); <span class="comment">//往前推一位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        <span class="type">int</span> n, len = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="comment">// c[i] 為以 i 為結尾的 LIS 數量</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span>, <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">c</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[j] &lt; v[i])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j] + <span class="number">1</span> &gt; dp[i])&#123;</span><br><span class="line">                        dp[i] = dp[j] + <span class="number">1</span>;</span><br><span class="line">                        c[i] = c[j];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(dp[j] + <span class="number">1</span> == dp[i])&#123;</span><br><span class="line">                        c[i] += c[j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="built_in">max</span>(len, dp[i]); <span class="comment">// LIS 長度</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cLIS = <span class="number">0</span>; <span class="comment">//LIS 數量</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == len) cLIS += c[i];</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; cLIS &lt;&lt; endl;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == len) <span class="built_in">printLIS</span>(v, dp, i, path);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><mark class="hl-label default">程式碼2</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; LIS;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">findLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt; dp, <span class="type">int</span> i, vector&lt;<span class="type">int</span>&gt;&amp; path, <span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == len)&#123; <span class="comment">//符合 LIS 長度</span></span><br><span class="line">        LIS.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == v.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(path.<span class="built_in">size</span>() == <span class="number">0</span> || path[path.<span class="built_in">size</span>() - <span class="number">1</span>] &lt; v[i])&#123; <span class="comment">//滿足規則，加入該數字</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">        <span class="built_in">findLIS</span>(v, dp, i + <span class="number">1</span>, path, len);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">findLIS</span>(v, dp, i + <span class="number">1</span>, path, len); <span class="comment">//不加入該數字</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        LIS.<span class="built_in">clear</span>();</span><br><span class="line">        <span class="type">int</span> n, len = <span class="number">0</span>;</span><br><span class="line">        cin &gt;&gt; n;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span>, <span class="title">dp</span><span class="params">(n, <span class="number">1</span>)</span>, <span class="title">c</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(v[j] &lt; v[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            len = <span class="built_in">max</span>(len, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line">        <span class="built_in">findLIS</span>(v, dp, <span class="number">0</span>, path, len);</span><br><span class="line">        cout &lt;&lt; LIS.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; LIS.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; len; j++)&#123;</span><br><span class="line">                cout &lt;&lt; LIS[i][j]  &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cout &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="luggage">Luggage</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10664">UVA 10664</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給出一串數字，代表各個行李的重量，找出是否能夠將行李分為同樣重量的兩堆。</p><mark class="hl-label default">解題方法</mark> <p>首先統計行李總重量以及數量，如果為奇數則直接輸出否，之後利用動態規劃判斷是否能夠湊出 <code>總重量 / 2</code> 這個重量，類似硬幣問題，但是每個硬幣只能使用一次。</p><mark class="hl-label default">注意事項</mark> <ul><li>輸入是一行一行的，並不知道行李數量，因此輸入用 <code>getline</code> 和 <code>stringstream</code> 處理。</li><li>每個行李只有一個，動態規劃遍歷重量時的順序應該是由後往前，避免重複使用。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">string str, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getline</span>(cin, str);</span><br><span class="line">    <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="type">int</span> ws = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; s)&#123;</span><br><span class="line">            <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                k = k * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(k);</span><br><span class="line">            ws += k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ws % <span class="number">2</span> == <span class="number">1</span> || v.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>)&#123; <span class="comment">//判斷總重量與數量</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(ws / <span class="number">2</span> + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = dp.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= v[i]; j--)&#123; <span class="comment">//由後往前</span></span><br><span class="line">                <span class="keyword">if</span>(dp[j - v[i]] == <span class="number">1</span>) dp[j] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(dp[dp.<span class="built_in">size</span>() - <span class="number">1</span>] == <span class="number">1</span>) cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="the-jackpot">The jackpot</h2><blockquote><p><a href="https://vjudge.net/problem/UVA-10684">UVA 10684</a></p></blockquote><mark class="hl-label default">題目大意</mark> <p>給出一串數字，代表每次賭注的收益，可能有正(賺錢)有負(賠錢)，求出一段連續的投注可以獲得的最高收益，如果可以獲得正收益，則輸出最大收益，否則輸出否。</p><mark class="hl-label default">解題方法</mark> <p>最大子數列問題，使用 <code>Kadane’s Algorithm</code> 求最大值。</p><mark class="hl-label default">注意事項</mark> <ul><li>如果最大值為 <code>0</code> 則同樣無法獲得正收益，要注意判斷。</li></ul><mark class="hl-label default">程式碼</mark> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n &amp;&amp; n != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cin &gt;&gt; v[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cursum = <span class="number">0</span>, maxsum = v[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            cursum = <span class="built_in">max</span>(cursum + v[i], v[i]);</span><br><span class="line">            maxsum = <span class="built_in">max</span>(maxsum, cursum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(maxsum &lt;= <span class="number">0</span>) cout &lt;&lt; <span class="string">&quot;Losing streak.&quot;</span> &lt;&lt; endl; <span class="comment">//包括 0</span></span><br><span class="line">        <span class="keyword">else</span> cout &lt;&lt; <span class="string">&quot;The maximum winning streak is &quot;</span> &lt;&lt; maxsum &lt;&lt; <span class="string">&quot;.&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo備忘錄-1</title>
      <link href="/2025/01/13/hexo%E5%82%99%E5%BF%98%E9%8C%84-1/"/>
      <url>/2025/01/13/hexo%E5%82%99%E5%BF%98%E9%8C%84-1/</url>
      
        <content type="html"><![CDATA[<div class="note primary no-icon flat"><p>紀錄一些關於 <code>hexo</code> 的小事。</p></div><h1>數學公式</h1><p>最近發現文章中的數學公式看起來怪怪的，後面都會重複一次原本的文字，後來調整了一些 <code>MathJax</code> 的設定之後就正常了。</p><div class="note info flat"><p>參考資料： <a href="https://butterfly.js.org/posts/4aa8abbe/">Butterfly 文檔(三) 主題配置</a></p></div><ol><li>在終端機中輸入以下指令，卸載 hexo 的 markdown 渲染器，並且安裝 <code>hexo-renderer-kramed</code>：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall hexo-renderer-marked --save</span><br><span class="line">npm install hexo-renderer-kramed --save</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>_config.yml</code> 中加入以下代碼：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kramed:</span></span><br><span class="line">  <span class="attr">gfm:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">pedantic:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">sanitize:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tables:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartLists:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">smartypants:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 <code>_config.butterfly.yml</code> 中加入以下代碼：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># MathJax</span></span><br><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1>分類相關</h1><h2 id="子分類">子分類</h2><p>如果要讓頁面屬於某個子分類，只要在 <code>categories</code> 中輸入兩行的分類，該頁面就會變為 <code>分類 &gt; 子分類</code></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> 分類</span><br><span class="line"><span class="bullet">  -</span> 子分類</span><br></pre></td></tr></table></figure><p>也可以寫成：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [分類, 子分類]</span><br></pre></td></tr></table></figure><p>如果要讓一篇文章同時屬於多個分類，則可以這樣寫：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">categories:</span><br><span class="line"><span class="bullet">  -</span> [分類1]</span><br><span class="line"><span class="bullet">  -</span> [分類2]</span><br></pre></td></tr></table></figure><h2 id="刪除分類">刪除分類</h2><p>如果不小心打錯分類的名稱，可能會在分類區看到剛剛打錯的名稱，可以利用以下的程式碼，把檔案清除並且重新產生就好。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo g</span><br></pre></td></tr></table></figure><h1>網頁圖標</h1><p>把圖片放在 <code>source/img</code> 中，並且在 <code>_config.yml</code> 中加入以下代碼：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># favicon</span></span><br><span class="line"><span class="attr">favicon:</span> <span class="string">/img/favicon.png</span></span><br></pre></td></tr></table></figure><h1>部署報錯</h1><p>當部署檔案時發生 <code>Error: Spawn failed at ChildProcess.&lt;anonymous&gt;...</code> 錯誤時，可以嘗試重新部署。如果還是無法解決，把 <code>.deploy_git</code> 資料夾刪除，讓 hexo 重新產生一次就能成功部屬。</p>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-字典樹</title>
      <link href="/2025/01/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E5%AD%97%E5%85%B8%E6%A8%B9/"/>
      <url>/2025/01/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E5%AD%97%E5%85%B8%E6%A8%B9/</url>
      
        <content type="html"><![CDATA[<p><code>字典樹 (Trie)</code> 是一種樹狀結構，可以用來儲存 <code>字串</code> 或是 <code>層狀資料夾</code> 類型的資料，每個節點分別可以儲存一個字元或是資料夾名稱，並且可以進行插入、查詢等操作。</p><h1>儲存字串</h1><h2 id="結構">結構</h2><p><code>node</code> 中包含了儲存的字元、後續字元的位置、以及目前位置是否是一個字串的結尾，如果能夠確定後續字元的種類的話 (如 ‘a’ ~ ‘z’)，也可以使用一般的陣列來儲存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    <span class="type">char</span> ch; <span class="comment">//字元</span></span><br><span class="line">    unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; nextNode; <span class="comment">//後續字元位置</span></span><br><span class="line">    <span class="type">bool</span> wordEnd; <span class="comment">//是否為字串結尾</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">        wordEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">node</span>(<span class="type">char</span> c)&#123;</span><br><span class="line">        ch = c;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">        wordEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; dict; <span class="comment">//用來儲存節點</span></span><br></pre></td></tr></table></figure><p>注意每次使用前要先清空 <code>dict</code>，並建立根結點，可以使用以下代碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict.<span class="built_in">clear</span>(); <span class="comment">// 初始化 dict</span></span><br><span class="line">dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>()); <span class="comment">//建立根結點</span></span><br></pre></td></tr></table></figure><p>或是在每次 <code>insertString</code> 時判斷 <code>dict</code> 是否為空，如果為空的話再補上根結點。</p><h2 id="插入">插入</h2><p>從根結點開始進行插入，記得最後要把字串的結尾進行標註。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertString</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">//目前所在字元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dict[cur].nextNode).<span class="built_in">count</span>(str[i]) == <span class="number">0</span>)&#123; <span class="comment">//如果該字元不存在</span></span><br><span class="line">            dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>(str[i])); <span class="comment">//加入字元</span></span><br><span class="line">            dict[cur].nextNode[str[i]] = dict.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dict[cur].nextNode[str[i]]; <span class="comment">//下一層</span></span><br><span class="line">    &#125;</span><br><span class="line">    dict[cur].wordEnd = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查詢">查詢</h2><p>從根結點開始查找，如果不存在就直接退出，到最後還要進行是否為字串結尾的判斷，因為查找的字串可能是其他字串的前綴。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">searchString</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">//目前所在字元</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dict[cur].nextNode).<span class="built_in">count</span>(str[i]) == <span class="number">0</span>)&#123; <span class="comment">//如果該字元不存在</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dict[cur].nextNode[str[i]]; <span class="comment">//下一層</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict[cur].wordEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>儲存層狀資料夾</h1><p>以 <code>UVA-1556 Disk Tree</code> 為例。</p><h2 id="結構">結構</h2><p>依照題目要求可以建立一個字典樹，每個節點儲存的是該資料夾的名稱，以及子資料夾對應的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    string name; <span class="comment">//資料夾名稱</span></span><br><span class="line">    map&lt;string, <span class="type">int</span>&gt; nextNode; <span class="comment">//子資料夾位置</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">node</span>()&#123;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">node</span>(string s)&#123;</span><br><span class="line">        name = s;</span><br><span class="line">        nextNode.<span class="built_in">clear</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;node&gt; dict; <span class="comment">//用來儲存節點</span></span><br></pre></td></tr></table></figure><p>可以注意這裡使用的是 <code>map</code>，而不是 <code>unordered_map</code>，以便於在後面輸出時以字典序輸出。因為題目沒有要求儲存功能，因此不需要多加一個確認是否為結尾的變數。</p><h2 id="插入">插入</h2><p>根據傳入的 <code>vector</code> 來插入對應的資料夾，如果對應的資料夾不存在，就將其加入字典樹中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertNode</span><span class="params">(vector&lt;string&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> cur = <span class="number">0</span>; <span class="comment">//目前所在資料夾</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>((dict[cur].nextNode).<span class="built_in">count</span>(v[i]) == <span class="number">0</span>)&#123; <span class="comment">//如果資料夾不存在</span></span><br><span class="line">            dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>(v[i])); <span class="comment">//加入資料夾</span></span><br><span class="line">            dict[cur].nextNode[v[i]] = dict.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = dict[cur].nextNode[v[i]]; <span class="comment">//下一層</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="遍歷">遍歷</h2><p>題目要求需要輸出所有資料夾，並且根據資料夾的層數位移，同一層的資料夾需要依照字典序進行輸出，這邊我們利用 map 的 <code>iterator</code> 來進行照字典序的遍歷。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cur)&#123; <span class="comment">//根結點 0 不需要輸出</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; d; i++)&#123; <span class="comment">//根據層數位移</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout &lt;&lt; dict[cur].name &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(dict[cur].nextNode).<span class="built_in">empty</span>())&#123; <span class="comment">//如果不是葉節點就繼續遍歷子資料夾</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> k = dict[cur].nextNode.<span class="built_in">begin</span>(); k != dict[cur].nextNode.<span class="built_in">end</span>(); k++)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(k -&gt; second, d + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主程式">主程式</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">string str, s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; n)&#123;</span><br><span class="line">        dict.<span class="built_in">clear</span>(); <span class="comment">// 初始化 dict</span></span><br><span class="line">        dict.<span class="built_in">push_back</span>(<span class="built_in">node</span>()); <span class="comment">//建立根結點</span></span><br><span class="line">        <span class="keyword">while</span>(n--)&#123;</span><br><span class="line">            cin &gt;&gt; str;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(str[i] == <span class="string">&#x27;\\&#x27;</span>) str[i] = <span class="string">&#x27; &#x27;</span>; <span class="comment">//把 &#x27;\&#x27; 替換為 &#x27; &#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line">            vector&lt;string&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(ss &gt;&gt; s)&#123;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(s);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">insertNode</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>, <span class="number">0</span>); <span class="comment">//輸出資料夾，從根結點 0 開始，層數也是從 0 開始</span></span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> 資料結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-動態規劃</title>
      <link href="/2024/12/31/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/"/>
      <url>/2024/12/31/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E5%8B%95%E6%85%8B%E8%A6%8F%E5%8A%83/</url>
      
        <content type="html"><![CDATA[<p>把原本複雜的問題分解為相對簡單的子問題，通常適用於有重疊子問題的情況，可以透過儲存子問題的答案減少之後處理複雜問題的時間。</p><h1>Rod Cutting Problem</h1><p>有一根長度為 <code>L</code> 的棒子，以及價格表 <code>v[i]</code> 代表 <code>長度為 i 的棒子的價值</code>，找出一種切割方案，使得切割後的棒子價值總和最大。</p><p>建立一個 vector 來儲存長度為 <code>i</code> 的棒子切割後的最大總價值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">rodCutting</span><span class="params">(<span class="type">int</span> L, vector&lt;<span class="type">int</span>&gt; v)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(L + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> m = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; j++)&#123;</span><br><span class="line">          m = <span class="built_in">max</span>(m, v[j] + dp[i - j]);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[L];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>陣列的更新是由較短的長度開始往後更新，之後較大的值就可以透過前面已有的陣列值進行判斷。</p><h1>最大子數列</h1><p><a href="https://douobb.github.io/2024/05/04/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-1/">Kadane’s Algorithm</a></p><h1>最長遞增子序列</h1><p>給定一個陣列，最長遞增子序列是其一子序列，其中的每個元素值為遞增。</p><h2 id="longest-increasing-subsequence-lis">Longest Increasing Subsequence (LIS)</h2><ul><li>求出最長遞增子序列的長度。</li></ul><p>建立一個 vector 來儲存以 <code>arr[i]</code> 為結尾的 LIS 長度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size(), <span class="number">1</span>)</span></span>; <span class="comment">//初始為1</span></span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j] &lt; arr[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        m = <span class="built_in">max</span>(m, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weighted-longest-increasing-subsequence">Weighted Longest Increasing Subsequence</h2><ul><li>每個 <code>arr[i]</code> 有其對應的權重 <code>w[i]</code>。</li><li>求權重和最大的遞增子序列之長度。</li></ul><p>建立一個 vector 來儲存以 <code>arr[i]</code> 為結尾的 weightedLIS 權重。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">weightedLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; arr, vector&lt;<span class="type">int</span>&gt; w)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(arr.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">      dp[i] = w[i]; <span class="comment">//初始化為權重</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> m = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">          <span class="keyword">if</span>(arr[j] &lt; arr[i]) dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + w[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        m = <span class="built_in">max</span>(m, dp[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>最長共同子序列</h1><p>求出兩個序列中最長的共同子序列 <code>Longest Common Subsequence (LCS)</code> 之長度。</p><p>建立一個二維 vector <code>dp[i][j]</code> 來儲存 <code>v1 前 i 個元素</code> 與 <code>v2 前 j 個元素</code> 的 <code>LCS</code> 長度。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCS</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v1, vector&lt;<span class="type">int</span>&gt; v2)</span></span>&#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(v1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(v2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= v2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(v1[i - <span class="number">1</span>] == v2[j - <span class="number">1</span>]) dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[v1.<span class="built_in">size</span>()][v2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>編輯距離</h1><p>兩個字串之間，由一個轉成另一個所需的最少編輯操作次數。</p><h2 id="萊文斯坦距離-levenshtein-distance">萊文斯坦距離 Levenshtein distance</h2><p>允許的編輯操作：</p><ul><li>將一個字符替換成另一個字符</li><li>插入一個字符</li><li>刪除一個字符</li></ul><p>建立一個二維 vector <code>dp[i][j]</code> 來儲存 <code>str1 前 i 個元素</code> 與 <code>str2 前 j 個元素</code> 之間的萊文斯坦距離。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">editDistance</span><span class="params">(string str1, string str2)</span></span>&#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(str1.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(str2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= str1.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= str2.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">      <span class="keyword">if</span>(i == <span class="number">0</span>) dp[i][j] = j;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) dp[i][j] = i;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(str1[i - <span class="number">1</span>] == str2[j - <span class="number">1</span>]) dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">      <span class="keyword">else</span> dp[i][j] = <span class="number">1</span> + <span class="built_in">min</span>(&#123;dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>], dp[i - <span class="number">1</span>][j - <span class="number">1</span>]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[str1.<span class="built_in">size</span>()][str2.<span class="built_in">size</span>()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="lcs-距離">LCS 距離</h2><p>允許的編輯操作：</p><ul><li>插入一個字符</li><li>刪除一個字符</li></ul><h1>矩陣鏈乘積</h1><p>兩個矩陣分別為 <code>a × b</code> 與 <code>b × c</code>，則將兩者相乘需要 O(abc) 的時間，當我們有一長串的矩陣 (matrix chain) 需要相乘時，可以選擇相乘的順序，目標是求出最短所需要的時間。</p><p>建立一個二維 vector <code>dp[i][j]</code> 來儲存 <code>第 i 個矩陣</code> 至 <code>第 j 個矩陣</code> 之間最小的矩陣鏈乘積，外部的兩個迴圈將矩陣之間的距離由小到大進行遍歷，第三個迴圈是對範圍內的分割點進行遍歷。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">matrixChainMultiplication</span><span class="params">(vector&lt;<span class="type">int</span>&gt; r, vector&lt;<span class="type">int</span>&gt; c)</span></span>&#123;</span><br><span class="line">  vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">dp</span>(r.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(r.<span class="built_in">size</span>(), INT_MAX));</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; r.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    dp[i][i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> len = <span class="number">1</span>; len &lt; r.<span class="built_in">size</span>(); len++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i + len &lt; r.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">      <span class="type">int</span> k = i + len;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = i; j &lt; k; j++)&#123; <span class="comment">//遍歷分割點</span></span><br><span class="line">        dp[i][k] = <span class="built_in">min</span>(dp[i][k], dp[i][j] + dp[j+<span class="number">1</span>][k] + r[i] * c[j] * c[k]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][r.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>背包問題</h1><p>每種物品有其對應的價值 <code>v[i]</code> 與重量 <code>w[i]</code>，將物品塞入一個有重量限制 <code>W</code> 的背包中，並盡量使背包中物品的總價值最大。</p><h2 id="分數背包">分數背包</h2><ul><li>物品可以切割，可以只放部分物品進入背包。<br>利用貪心法，每次從剩餘物品中找單位價值 <code>v[i]/w[i]</code> 最大者，並將其盡可能地塞入背包中，直到背包滿了為止。</li></ul><h2 id="0-1-背包問題">0/1 背包問題</h2><ul><li>每種物品只有一個。</li><li>物品無法切割，只能選擇是否放入背包 <code>(0/1)</code>。</li></ul><p>建立一個 vector 來儲存在背包重量為 i 時的最大價值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt; w, <span class="type">int</span> W)</span></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = W; j &gt;= w[i]; j--)&#123; <span class="comment">//反向</span></span><br><span class="line">      dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二個迴圈中變數 <code>j</code> 的值是由陣列的尾端開始，是為了避免同一個物品放入背包中兩次 (避免使用前面已更新的數值來更新後面的值)。</p><h2 id="無限背包">無限背包</h2><ul><li>每種物品有無限個。</li><li>物品無法切割，只能選擇是否放入背包 (需要考慮放入的數量)。</li></ul><p>建立一個 vector 來儲存在背包重量為 i 時的最大價值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt; w, <span class="type">int</span> W)</span></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = w[i]; j &lt;= W; j++)&#123; <span class="comment">//正向</span></span><br><span class="line">      dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>與 <code>0/1背包</code> 不同的是，第二個迴圈中變數 <code>j</code> 的值是由陣列的前端開始，因為無限背包問題中的物品是沒有數量限制的，同一個物品可以有多個存在於背包中。</p><h2 id="有限背包">有限背包</h2><ul><li>每種物品有限定數量 <code>n[i]</code>。</li><li>物品無法切割，只能選擇是否放入背包 (需要考慮放入的數量)。</li></ul><p>利用二進位分解，將每種物品的數量 n[i] 分成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn><mo separator="true">,</mo><mn>2</mn><mo separator="true">,</mo><mn>4...</mn><msup><mn>2</mn><mi>k</mi></msup><mo separator="true">,</mo><mi>n</mi><mo stretchy="false">[</mo><mi>i</mi><mo stretchy="false">]</mo><mo>−</mo><msup><mn>2</mn><mi>k</mi></msup></mrow><annotation encoding="application/x-tex">1,2,4...2^k,n[i]-2^k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.099108em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">4</span><span class="mord">.</span><span class="mord">.</span><span class="mord">.</span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span></span></span></span></span></span></span></span></span></span></span>，把每個組別當成一個物品，就可以將問題轉換為 <code>0/1背包問題</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">knapsack</span><span class="params">(vector&lt;<span class="type">int</span>&gt; v, vector&lt;<span class="type">int</span>&gt; w, vector&lt;<span class="type">int</span>&gt; n, <span class="type">int</span> W)</span></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(W + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">min</span>(n[i], W / w[i]), k = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>)&#123;</span><br><span class="line">      <span class="keyword">if</span>(k &gt; n) k = n;</span><br><span class="line">      n -= k;</span><br><span class="line">      <span class="keyword">for</span>(<span class="type">int</span> j = W; j &gt;= w[i] * k; j--)&#123; <span class="comment">//反向</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - w[i] * k] + v[i] * k);</span><br><span class="line">      &#125;</span><br><span class="line">      k *= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[w];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>硬幣問題</h1><h2 id="coin-change-problem">Coin Change Problem</h2><p>給定幾種不同價值的硬幣，求有幾種方式能湊到指定的金額。</p><p>建立一個 vector 來儲存金額 i 有幾種湊法，並由小到大進行更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt; c, <span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(T + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">//初始化為0</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//0元只有一種湊法</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = c[i]; j &lt;= T; j++)&#123;</span><br><span class="line">      dp[j] += dp[j - c[i]];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="change-making-problem">Change-Making Problem</h2><p>給定幾種不同價值的硬幣，求湊到指定的金額所需的最少硬幣數。</p><p>建立一個 vector 來儲存湊出金額 i 需要的最少硬幣數，並由小到大進行更新。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">changeMaking</span><span class="params">(vector&lt;<span class="type">int</span>&gt; c, <span class="type">int</span> T)</span></span>&#123;</span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(T + <span class="number">1</span>, INT_MAX)</span></span>; <span class="comment">//初始化為無限</span></span><br><span class="line">  dp[<span class="number">0</span>] = <span class="number">0</span>; <span class="comment">//0元只需要0個硬幣</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; c.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = c[i]; j &lt;= T; j++)&#123;</span><br><span class="line">      dp[j] = <span class="built_in">min</span>(dp[j], dp[j - c[i]] + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">return</span> dp[T];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> 動態規劃 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L15</title>
      <link href="/2024/12/13/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L15/"/>
      <url>/2024/12/13/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L15/</url>
      
        <content type="html"><![CDATA[<h1>L15 社會心理學</h1><p>人的思考和行為如何受到與別人互動的過程所影響。</p><p>Social Roles (社會角色) - 一個人在社會中的地位，期望他有哪些行為。</p><ul><li>史丹佛監獄實驗 - 監獄中權威者和被監管者行為影響。</li></ul><h2 id="social-cognition-社會認知">Social Cognition 社會認知</h2><p>Attribution (歸因) - 是什麼導致了某人的這種行為?</p><ul><li>Internal (dispositional) - 內部的性格</li><li>External (situational) - 外在的情境</li></ul><p>歸因時的偏誤：</p><ul><li>Fundamental attribution error - 低估了外在環境對於行為的影響。<ul><li>ex:她現在很生氣，所以她一定是個脾氣暴躁的人。</li></ul></li><li>Actor-observer bias - 傾向於將他人的行為歸因於內在因素，將自己的行為歸因於外在因素。</li><li>Self-fulfilling prophecies (自我實現預言) - 偏誤可能會形成事實。<ul><li>老師被告知某一群學生是&quot;黑馬&quot; (事實上隨機抽出的學生)。</li><li>在學年度的最後，這些&quot;黑馬&quot;在 IQ 分數上多了 22 分，顯著高於控制組。</li></ul></li></ul><h2 id="attitude-態度">Attitude 態度</h2><ul><li>Cognitive 認知 - beliefs, ideas</li><li>Affective 情感 - emotions, feelings</li><li>Behavioral 行為 - actions</li></ul><h3 id="persuasion-勸說">Persuasion 勸說</h3><p>嘗試改變他人的態度，良好的溝通包含以下要點：</p><ul><li>Communicator (溝通者) - 提出論點或訊息的人。<ul><li>討人喜歡、善於表達、值得信賴、專家。</li><li>在某些方面與受眾相似。</li></ul></li><li>Message (信息) - 溝通者的論點。<ul><li>訴諸情緒，尤其是恐懼或焦慮。</li><li>提供了明確的行動方針。</li><li>陳述明確的結論。</li><li>有事實和統計數據支持。</li><li>重複的行為。</li></ul></li><li>Audience (受眾) - 有說服力的訊息所針對的個人或群體。<ul><li>對於知識較為豐富的觀眾 - 提出雙面的論點。</li><li>對於知識較為稀少的觀眾 - 提出單面的論點。</li></ul></li></ul><h3 id="cognitive-dissonance-認知失調">Cognitive Dissonance 認知失調</h3><p>當行為和態度不一致時出現的一種不舒服的狀態。</p><p>Conformity (一致性) - Asch Experiment (阿希從眾實驗)</p><ul><li>將您的行為與感知的社會規範相匹配。</li><li>受試者與其他人坐在一起，故意給出錯誤答案。</li></ul><p>其他會改變態度的事物：</p><ul><li>Leader (領導者)</li><li>Obedience (服從) - 遵守權威人士的指示<ul><li>Milgram’s experiment (米爾格倫實驗) - 研究人員 (權威) 要求受試者 (老師) 電擊學生。</li></ul></li><li>Groupthink (團體迷思)<ul><li>在決策過程中，由於成員傾向讓自己的觀點與團體一致，因而令整個團體缺乏不同的思考角度，不能進行客觀分析。</li></ul></li><li>Brainwashing (洗腦)<ul><li>Unfreezing - 因為身體和心理虐待、睡眠不足、羞辱和孤立而使舊有的信念鬆動。</li><li>Change - 達到<code>崩潰點</code>並放棄以前的信念。</li><li>Refreezing - 獲得新的態度和信念。</li></ul></li><li>Cult (邪教)<ul><li>Recruitment (招募) - 成員通常在情緒的低谷加入。<ul><li>分手後</li><li>在考試中掙扎</li><li>試圖從家庭中獨立</li><li>青少年尋求父母權威的替代</li></ul></li><li>Conversion (轉換)<ul><li>Love bombing - 給成員滿滿的愛與理解。</li><li>Rituals (儀式) - 削弱身體和情緒上的抵抗力，阻礙批判性思考。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L14</title>
      <link href="/2024/12/06/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L14/"/>
      <url>/2024/12/06/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L14/</url>
      
        <content type="html"><![CDATA[<h1>L14 心理治療</h1><h2 id="psychodynamic-approach-心理動力學方法">Psychodynamic approach 心理動力學方法</h2><p>進行 <code>Psychoanalysis (精神分析)</code>，目標：</p><ul><li>增強自我, 讓本我, 自我和超我達到平衡</li><li>協助病人幫潛意識的思想帶到意識上</li></ul><p>方法：</p><ul><li>free association - 讓患者在放鬆的情境下交談。</li><li>Resistance - 當患者抗拒討論某個話題時，可能就是問題的線索。</li><li>dream analysis - 淺意識可能會在夢中顯露出來 (進行夢的解析)。</li><li>Transference &amp; Countertransference<ul><li>Transference 移情作用 - 當事人(患者)將對 A 的情感投射至 B (治療師)身上。</li><li>Countertransference 反移情作用 - 治療師將對 A 的情感投射至 B (患者)身上。</li></ul></li></ul><h2 id="behavior-approach-行為方法">Behavior approach 行為方法</h2><p>利用古典制約 (classical conditioning)：</p><ul><li>Exposure therapy (暴露治療) - Systematic desensitization (系統脫敏)<ul><li>放鬆肌肉 -&gt; 視覺上想像自己害怕的處境 -&gt; 在該處境下嘗試放鬆 -&gt; 從弱刺激慢慢進展到強刺激</li><li>Eye movement desensitization and reprocessing (EMDR) - 眼動脫敏再處理。</li></ul></li><li>Aversion therapy (嫌惡治療法)</li></ul><p>利用操作制約 (operational conditioning)：</p><ul><li>正強化策略 - 病人有良好行為時，治療師給予獎賞。</li><li>消退策略 - 將某些行為的獎勵消除。<ul><li>孩子不乖，雖然打他了，但他還是繼續鬧，可能是得到了注意力這個酬賞。</li></ul></li></ul><h2 id="cognitive-approach-認知方法">Cognitive approach 認知方法</h2><p>改變患者的認知：</p><ul><li>Cognitive therapy for depression (Aaron Beck) - 憂鬱症治療<ul><li>辨識錯誤信念</li><li>評估錯誤信念</li><li>挑戰錯誤信念</li></ul></li><li>Rational-emotive behavior therapy (REBT) - 理性情緒行為治療<ul><li>激活經驗 -&gt; 信念 -&gt; 情緒後果</li><li>並非外界發生的事情導致情緒問題，而是錯誤的 <code>Belief (信念)</code>導致情緒問題 - <code>Irrational Beliefs (非理性信念)</code>。</li><li>治療師可能會直接攻擊患者的邏輯、挑戰他們的思維，用與他們的信念相反的證據來說服他們。</li></ul></li></ul><h2 id="humanistic-人本主義方法">Humanistic 人本主義方法</h2><p>Carl Rogers – <code>self-actualization (自我實現)</code></p><ul><li>Client-centered therapy (個人中心治療)<ul><li>無私的誠實</li><li>準確地同理心</li><li>不帶評價的關懷</li></ul></li><li>Group therapies (團體心理治療)<ul><li>Couple therapy</li><li>Family therapy</li><li>Community support groups</li></ul></li></ul><h2 id="biological-approach-生物學方法">Biological approach 生物學方法</h2><ul><li>從 <code>Neurotransmitters (神經傳導物質)</code> 下手：<ul><li>精神分裂症 - 減少多巴胺。</li><li>憂鬱症 - 增加血清素 / 正腎上腺素。</li><li>躁鬱症 - 服用鋰鹽。</li><li>焦慮症 - 增加 GABA。</li></ul></li><li>Biomedical therapy (生物醫學療法)<ul><li>Electroconvulsive therapy (ECT) - 電痙攣療法<ul><li>對重度憂鬱症有效，但不知道其機制以及後遺症。</li></ul></li><li>Epetitive transcranial magnetic stimulation (rTMS)<ul><li>在頭顱外給磁場，影響腦部反應。</li><li>同樣不知道其機制以及後遺症。</li></ul></li></ul></li></ul><h2 id="心理醫師">心理醫師</h2><ul><li>精神科醫師(Psychiatrist)<ul><li>對患者進行各項精神疾病、精神官能症之診斷，及藥物治療，部分精神科醫師也從事心理治療。</li><li>只有精神科醫師可做「診斷」及「開藥」。</li></ul></li><li>心理師<ul><li>臨床心理師(Clinical Psychologist)<ul><li>對患者進行心理治療、行為治療、心理衡鑑、及精神鑑定等。</li><li>不能進行藥物治療。</li></ul></li><li>諮商心理師(Counseling Psychologist)<ul><li>對個案進行心理諮商、心理測驗、心理輔導等工作，不能開藥。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L13</title>
      <link href="/2024/11/29/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L13/"/>
      <url>/2024/11/29/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L13/</url>
      
        <content type="html"><![CDATA[<h1>L13 心理異常</h1><p>任何的行為都可以看成一個連續尺度，每個人都會感傷，焦慮或是感到壓力 (負面情緒有演化上的功用)。<br>當這些負面情緒影響你的正常生活時，才算是異常：</p><ul><li>我很焦慮所以我無法離家去工作。</li><li>我很沮喪所以我無法睡得好。</li></ul><p>客觀化 (objectify) 所會遇到的問題：</p><ul><li>同一個行為，在某情境下正常，但換了一個情境變成異常。</li><li>誠實是個正常行為，但在某些情況下<code>誠實</code>會變得白目。<br>因此我們會在連續的尺度上劃定界線，超過了界線就算是異常，目前的標準為 <code>DSM-5</code> (Diagnostic and Statistical Manual of Mental Disorder)。</li></ul><h2 id="psychotic-disorders-精神障礙">Psychotic Disorders 精神障礙</h2><h3 id="精神病">精神病</h3><ul><li><p>特徵：<code>Delusions (妄想)</code>、<code>Hallucinations (幻覺)</code>。</p><ul><li>妄想：個人堅持錯誤的信念。</li><li>幻覺：想像出來的感覺。</li></ul></li><li><p>神經認知障礙</p><ul><li>阿茲海默症</li></ul></li><li><p>Delusional disorder (妄想症)</p><ul><li>Erotomanic type (情慾型) - 認為自己被另一個人所愛。</li><li>Grandiose type (誇大型) - 認為自己有某些特殊能力、才能。</li><li>Jealous type (嫉妒型) - 認為自己的配偶或情人不忠。</li><li>Persecutory type (迫害型) - 認為自己遭到密謀、欺騙、跟蹤、誹謗等。</li><li>Somatic type (身體型) - 認為自己的身體有缺陷、生病。</li></ul></li><li><p>Schizophrenia (精神分裂症)</p><ul><li>特徵<ul><li>人格瓦解</li><li>思想和感知被扭曲</li><li>幻覺、妄想</li></ul></li></ul></li></ul><div class="note simple"><p>成因</p><ul><li>環境<ul><li>早期心理創傷</li><li>家庭環境不穩定</li><li>異常的溝通模式</li></ul></li><li>遺傳<ul><li>雙胞胎實驗</li></ul></li><li>腦部化學<ul><li>多巴胺過度活躍</li><li>谷氨酸</li></ul></li><li>腦部結構<ul><li>大腦縮小和腦室擴大。</li></ul></li><li>Stress-Vulnerability Model (壓力脆弱性模型)<ul><li>環境壓力和遺傳的結合導致精神障礙。</li></ul></li></ul></div><h2 id="anxiety-disorders-焦慮症">Anxiety disorders 焦慮症</h2><h3 id="generalized-anxiety-disorder-廣泛性焦慮疾患">Generalized Anxiety Disorder (廣泛性焦慮疾患)</h3><ul><li>有長達六個月的焦慮感，且沒有明顯的焦慮源。</li><li>有三個其他症狀<ul><li>肌肉緊張</li><li>疲勞</li><li>煩躁不安</li><li>注意力不集中</li><li>易怒</li><li>睡眠困難</li></ul></li></ul><h3 id="panic-disorder-恐慌症">Panic Disorder (恐慌症)</h3><p>Panic attack (恐慌發作)</p><ul><li>一開始是強烈的憂鬱，懼怕或驚恐。</li><li>伴隨生理症狀 - 快速心跳，昏眩，無力。</li><li>並非由環境中的具體事物引起。</li></ul><h3 id="phobias-恐懼症">Phobias (恐懼症)</h3><ul><li>對於某一事物不理性的懼怕</li></ul><h3 id="obsessive-compulsive-disorder-強迫症">Obsessive-compulsive Disorder (強迫症)</h3><ul><li>Obsession (強迫性意念)<ul><li>無法抑止的想法</li></ul></li><li>Compulsions (強迫性行為) - 為了降低強迫性意念而所做的強迫性行為<ul><li>清洗</li><li>檢查</li></ul></li></ul><h3 id="posttraumatic-stress-disorder-創傷後壓力疾患">Posttraumatic Stress Disorder (創傷後壓力疾患)</h3><p>重新經歷創傷事件的狀態</p><ul><li>Recollections (回憶)</li><li>Dreams</li><li>Hallucinations (幻覺)</li></ul><div class="note simple"><p>成因</p><ul><li>生理<ul><li>演化結果</li><li>神經傳導素 <code>GABA</code> 與 <code>serotonin</code></li></ul></li><li>心理動力學<ul><li><code>恐慌症</code>的發作是因為潛意識中的衝突進入意識層次。</li></ul></li><li>行為<ul><li><code>恐懼症</code>是<code>古典制約</code>造成的。</li></ul></li><li>認知<ul><li>當人們高估危險性時，就會產生焦慮。</li></ul></li></ul></div><h2 id="mood-disorders-情緒障礙">Mood disorders 情緒障礙</h2><ul><li>Major Depressive Disorder (重鬱病)</li><li>Bipolar Disorder (躁鬱症)<ul><li><code>Manic episode (躁症)</code> 與 <code>Depressive episode (憂鬱)</code> 交替出現。</li></ul></li><li>Postpartum depression (產後憂鬱)</li><li>Seasonal affective disorder (季節性情感障礙)<ul><li>光療 - 長時間暴露在明亮的光照下進行治療。</li></ul></li></ul><div class="note simple"><p>成因</p><ul><li>生物學<ul><li>過少的 Serotonin 以及 norepinephrine</li><li>雙胞胎實驗</li></ul></li><li>心理動力學<ul><li>童年時期造成的潛意識中的衝突或是敵意。</li><li>一開始是對於別人的厭惡或是憤怒，轉移到對於自己的憤怒。</li></ul></li><li>行為<ul><li>正回饋不夠 or 懲罰過多。</li></ul></li><li>認知<ul><li>自我批評和消極的想法是許多憂鬱症病例的根源。</li></ul></li></ul></div><h2 id="dissociative-disorders-解離性障礙">Dissociative disorders 解離性障礙</h2><ul><li>Formally known as multiple personality disorder (多重人格疾患)<ul><li>有兩個或以上的人格存在於個體中</li><li>心理動力學成因<ul><li>當個體經歷過創傷經驗，使用 <code>defense mechanisms</code> 將創傷經驗藏入潛意識中。</li></ul></li><li>沒有清楚的數據顯示發生率 - 有些人認為這疾病是被創造出來的。</li></ul></li></ul><h2 id="psychological-disorders-of-childhood-童年心理障礙">Psychological disorders of Childhood 童年心理障礙</h2><ul><li>Attention-deficit hyperactivity disorder (ADHD 注意力缺失/過動疾患)<ul><li>在七歲前連續六個月以上擁有以下行為：</li><li>注意力缺失 - 無法集中注意力</li><li>過動<ul><li>心神不寧，局促不安，不停地說話</li><li>衝動行為：搶話或打斷別人對話</li></ul></li></ul></li><li>Autistic Spectrum Disorder (泛自閉症障礙)<ul><li>有社交的困難 - 無法理解別人的心理狀態。<ul><li>語言有限制。</li><li>興趣很狹隘。</li><li>重複或是儀式性的行為。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L12</title>
      <link href="/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12/"/>
      <url>/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12/</url>
      
        <content type="html"><![CDATA[<h1>L12 人格</h1><h2 id="the-trait-approach">The trait approach</h2><p>Trait 特徵 - 人在不同環境中一致性的特質。</p><p>Five-factor model</p><ul><li>從英文形容詞中的同義字整理在一起 (200個字)。</li><li>建立出兩極 (kind vs cruel)。</li><li>給一群人施測並統計分析，相關高的形容詞擺在一起。</li><li>建立出五個 factors (O-C-E-A-N)。</li></ul><img src="/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12/Five-Factor-Model.png" class="" title="Five-Factor-Model"><div class="note primary no-icon flat"><ul><li>預設人的性格是靜態不變的。</li><li>缺點：無法解釋行為怎麼產生。</li></ul></div><h2 id="psychodynamic-theories">Psychodynamic theories</h2><p>Freudian Psychoanalysis 佛洛伊德精神分析</p><ul><li><p>所有行為都有背後成因。</p></li><li><p>沒有隨機的行為。</p></li><li><p>兩種基本驅力 (drives)</p><ul><li>Self preservation - 饑餓或口渴。</li><li>Eros - 性欲望 (試圖跟別人有生體接觸的欲望)。</li></ul>  <img src="/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12/Freudian-Psychoanalysis.png" class="" title="Freudian-Psychoanalysis"></li><li><p>Fixation - 在某個階段中太過滿足或是太過挫折。</p></li><li><p>Freudian slip (弗洛伊德式錯誤) - 潛意識的衝動會自己尋找出口。</p><ul><li>筆誤、口誤。</li><li>動機性遺忘、童年回憶遺忘。</li></ul></li></ul><div class="note primary no-icon flat"><ul><li>對於<code>潛意識</code>的描述。</li><li>缺點：<ul><li>概念缺乏明確的操作型定義。</li><li>不能被否證。</li><li>事後諸葛。</li><li>雖然它是個發展類的理論，但沒有對孩童的觀察。</li><li>男性中心。</li></ul></li></ul></div><h3 id="人格結構">人格結構</h3><ul><li>Id - 本我<ul><li>不理性的，衝動的。</li><li>Pleasure principle</li></ul></li><li>Superego - 超我<ul><li>跟道德良知有關。</li></ul></li><li>Ego - 自我<ul><li>協調 <code>Id</code> 和 <code>Superego</code> 的衝突。</li></ul></li></ul><p>決定行為的原因可能無法被意識到。</p><img src="/2024/11/22/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L12/Freudian-Psychoanalysis2.png" class="" title="Freudian-Psychoanalysis"><p>Ego defense mechanisms - <code>Ego</code> 用來協調 <code>Id</code> 和 <code>Superego</code> 衝突的手段。</p><ul><li>Repression - 極度的欲望被隱藏在潛意識中。</li><li>Reaction formation - 害怕欲望表現出來，因而採取相反態度。</li><li>Sublimation - 把不被社會接受的欲望用可被接受的行為表現出來。</li></ul><p>如果太過依賴 <code>defense mechanisms</code> 會造成心理疾病。<br>當在潛意識中的想法幾乎要 repress 不住時會產生 <code>Anxiety (焦慮)</code>。</p><ul><li>Superego - Moral anxiety (道德焦慮)。</li><li>Id - Neurotic anxiety (神經質焦慮)。</li></ul><h2 id="新佛洛伊德學派">新佛洛伊德學派</h2><p>沒有那麼強調本能與性。</p><ul><li>Afred Adler (阿德勒)<ul><li>自卑情節 - 行為出自于補償自卑。</li></ul></li><li>Carl Jung (榮格)<ul><li>Collective unconscious (集體無意識)。<ul><li>全人類共享的無意識想法和圖像的心理倉庫。</li></ul></li><li>Archetype (原型)。<ul><li>無意識的圖像使我們對出生、死亡、能量、動物、邪惡等象徵產生情感反應。</li></ul></li></ul></li></ul><h2 id="humanistic-theories">Humanistic theories</h2><ul><li>Carl Rogers<ul><li>追求自我實現。</li><li>我們會努力達到個人的最大潛力。</li></ul></li><li>Maslow (馬斯洛) - 需求層次理論。</li><li>有時候自我實現的目標可能跟社會期望不服。<ul><li>Unconditional positive regard (無條件的正向看待)<ul><li>孩子必須要覺得他們隨時都是被愛的。</li></ul></li></ul></li></ul><div class="note primary no-icon flat"><ul><li>缺點：模糊且難以探索 (自我實現的定義)。</li></ul></div><h2 id="learning-theories-of-personality">Learning Theories of Personality</h2><ul><li>Learning Theories<ul><li>學習會塑造我們的行為並解釋個性。</li><li>單純的 <code>Learning Theories</code> 難以解釋所有人類行為。</li></ul></li><li>Social learning theories<ul><li>Rotter’s expectancy theory。<ul><li>人的行為由 <code>expectancy (預期)</code> 以及 <code>the history of reinforcement</code> 決定。</li></ul></li><li>Bandura’s cognitive social-learning theory<ul><li><code>Person, Environment, Behavior</code> 互相影響。</li><li>Reciprocal determinism (相互決定論)。</li></ul></li></ul></li></ul><div class="note primary no-icon flat"><ul><li>缺點：<ul><li>忽略情緒以及潛意識動機。</li><li>忽略性格是如何造成的。</li></ul></li></ul></div><h2 id="assessing-personality">Assessing personality</h2><ul><li>Objective tests (客觀測驗)<ul><li>MMPI (明尼蘇達多項人格問卷)。</li><li>NEO-PI - 用在非臨床群體上。</li></ul></li><li>Projective tests (投射測驗)<ul><li>沒有預設的可能答案。</li><li>Rorschach test (羅夏克測驗)。</li><li>TAT (主題統覺測驗) - 看圖說故事。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L11</title>
      <link href="/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L11/"/>
      <url>/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L11/</url>
      
        <content type="html"><![CDATA[<h1>L11 情緒</h1><p>八種主要情緒 (Robert Plutchik)：</p><ul><li>Fear</li><li>Surprise</li><li>Sadness</li><li>Disgust</li><li>Anger</li><li>Anticipation</li><li>Joy</li><li>Trust (acceptance)</li></ul><h2 id="情緒與生理">情緒與生理</h2><ul><li>Autonomic nervous system 自主神經系統<ul><li><code>The sympathetic division 交感神經</code> - 危險情況</li><li><code>The parasympathetic division 副交感神經</code> - 放鬆</li></ul></li><li>Central nervous system 中央神經系統<ul><li>Hypothalamus 下視丘。</li><li>Amygdala 杏仁核 - <code>threat detector</code>：可以意識到危險。</li></ul></li></ul><div class="note primary no-icon flat"><ul><li>測謊儀<ul><li>記錄心率、血壓、呼吸和皮膚電阻變化的設備。</li><li>主要是測量說謊時交感神經活躍導致的結果，而不是說謊的本身，僅能做為參考。</li></ul></li><li>Guilty Knowledge Test (改良版的測謊方式)<ul><li>提出一系列多項選擇題，只一個答案是正確的，只有有罪的人才能知道答案，犯人可能會對該選項產生較強的反應。</li></ul></li></ul></div><h2 id="情緒來源">情緒來源</h2><p>情緒的來源：</p><ul><li><p>James-Lange：刺激 -&gt; 生理反應 -&gt; 情緒。</p></li><li><p>Cannon-Bard：刺激 -&gt; 生理反應/情緒 (同時)。</p></li><li><p>Schacter：刺激 -&gt; 生理反應 -&gt; 往四周尋找刺激來源 -&gt; 情緒。</p><ul><li>吊橋上的實驗：將吊橋上感受到的刺激歸因於異性。</li></ul></li><li><p>Facial Feedback Theory</p><ul><li>生理影響情緒。</li><li>笑臉的動作可以使人更容易感到快樂。</li></ul></li></ul><h2 id="情緒表達">情緒表達</h2><p>fear, anger, disgust, sadness, surprise, and happiness (enjoyment) 等情緒所對應的臉部表情在世界各地是通用的。</p><p>差異：</p><ul><li>文化 - 表達憤怒在西方文化中更容易被接受。</li><li>性別 - 男性更可能難以表達自己的情感。</li></ul><p><code>Alexithymia (情感失語症)</code>：難以表達情緒</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L10</title>
      <link href="/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/"/>
      <url>/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/</url>
      
        <content type="html"><![CDATA[<h1>L10 動機</h1><p>我們人類會做這些行為來求生存/繁衍？</p><ul><li>吃</li><li>性</li><li>其他…</li></ul><h2 id="吃">吃</h2><p>攝取食物的動機：</p><ul><li>周邊 (Peripherel)<ul><li>胃腸收縮 (Cannon,Washburn, 1912)。</li><li>在胃裡塞氣球來記錄胃收縮反應 - 當胃部收縮時，會有飢餓感。</li><li>注射糖液進入人體會降低收縮 - 但人還是會餓。</li></ul></li><li>中樞系統 (Central)<ul><li>Lateral Hypothalamus (LH) - 饑餓中樞。<ul><li>當葡萄糖濃度過低 - 肝會送信號到 <code>LH</code>。</li></ul></li><li>Ventromedial Hypothalamus (VMH) - 飽足中樞。<ul><li>脂肪細胞會釋放瘦蛋白刺激 <code>VMH</code>。</li></ul></li></ul></li><li>外在因素<ul><li>味覺<ul><li><code>Taste aversion</code> - 對某些特定食物的厭惡。</li><li>Bait shyness - 動物對於特定食物的厭惡。</li></ul></li><li>Emotional eating - 焦慮、憤怒或悲傷時容易暴飲暴食。</li><li>Cultural factors。</li></ul></li></ul><p>飲食失調：</p><ul><li>Anorexia nervosa 厭食症 - 對自己的身體不滿意(太胖)。</li><li>Muscle dysmorphia 肌肉上癮 - 對自己的身體不滿意(沒有肌肉)。</li><li>Bulimia nervosa 大量飲食之後催吐。</li><li>Binge eating disorder 暴食症。</li></ul><h2 id="性-性別與性取向">性、性別與性取向</h2><p>分類：</p><ul><li>物理 (生物)<ul><li>遺傳性別 - 分類。<ul><li>基因為 <code>XX</code> or <code>XY</code> (但是可能有例外情形 <code>X, XY, XXY...</code>)。</li></ul></li><li>賀爾蒙性別 - 連續。<ul><li><code>testosterone (睪固酮)</code> 濃度。</li><li>受孕後六周 - Y 染色體導致睪丸釋放睪固酮 -＞ 男性化。</li><li><code>Intersexuality 中間性</code> - 出生前荷爾蒙的變化可能導致性發育不明確。</li></ul></li><li>生殖器性別 - 分類。</li><li>性傾向 - 分類/連續。<ul><li>Sexual Orientation (for men)。</li></ul>  <img src="/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/Orientation.png" class="" title="Orientation"><ul><li>先天 or 後天 - 雙胞胎實驗 (兩人性傾向的一致性)。</li><li>同卵雙生：32%/異卵雙生：8%。</li></ul></li></ul></li><li>心理<ul><li>性別認同 - 分類。<ul><li>10 ~ 14 個月的兒童 - 會對於影片中跟自己同性的兒童有所偏好。</li><li>5 ~ 7 歲的兒童 - 對性別角色刻板印象僵化。</li></ul></li><li><code>Transsexual 跨性別</code> - 生理 &amp; 心理性別不匹配。</li><li>Gender dysphoria - 生理 &amp; 心理性別的不匹配影響正常生活。</li></ul></li></ul><h2 id="性行為">性行為</h2><p>一般來說，<code>成年人</code>之間任何<code>基於同意</code>的<code>無害</code>性行為都被認為是正常的。</p><h3 id="性傳染病">性傳染病</h3><ul><li>Chlamydia (衣原體感染)</li><li>Gonorrhea (淋病)</li><li>Hepatitis B (肝炎)</li><li>Genital herpes (生殖器皰疹)</li><li>Syphilis (梅毒)</li><li>HPV (human papillomavirus) (人乳頭瘤病毒)</li><li>PID (pelvic inflammatory disease) (骨盆腔發炎)</li><li><code>HIV</code> (human immunodeficiency virus)<ul><li>僅透過體液傳播。</li><li>有 4 ~ 12 個禮拜的空窗期 - 無法被檢測到。</li><li>預防：事前/事後/保險套。</li></ul></li><li>AIDS (acquired immune deficiency syndrome)</li></ul><h2 id="stimulus-motive-刺激動機">Stimulus motive 刺激動機</h2><p>每個人對於刺激的追求程度不同：</p><ul><li><p>High sensation seekers</p><ul><li>大膽、獨立、價值變化。</li></ul></li><li><p>Low sensation seekers</p><ul><li>有秩序、追求陪伴。</li></ul></li><li><p><code>Arousal theory 喚醒理論</code> - 人們更喜歡保持理想或舒適的刺激程度。</p><ul><li>刺激程度與表現的關係：</li></ul>  <img src="/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/arousal.png" class="" title="arousal"></li><li><p>Yerkes-Dodson law</p><ul><li>事件難度也會影響適合的刺激程度。</li></ul>  <img src="/2024/11/15/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L10/Yerkes-Dodson.png" class="" title="Yerkes-Dodson"></li></ul><h2 id="learned-motive-學習動機">Learned motive 學習動機</h2><ul><li>Opponent-process theory<ul><li>做一些刺激或危險的事情之後，會獲得正面的情緒反饋。</li><li>持續做該事情，正反饋的衰減速度會比恐懼衰減速度慢 (不會再感到恐懼，而還會獲得正反饋)。</li></ul></li><li>Social motives<ul><li>在社會與文化環境中成長而習得。</li><li>為了達成成就/獲得權力。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L9</title>
      <link href="/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/"/>
      <url>/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/</url>
      
        <content type="html"><![CDATA[<h1>L9 發展心理學</h1><p>探討在人一生中，心理功能的改變。</p><h2 id="cognitive-development-認知發展">Cognitive development 認知發展</h2><h3 id="piaget-s-developmental-theory">Piaget’s Developmental Theory</h3><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>發展時間軸</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(0-2) - Sensorimotor stage</p></div></div><div class='timeline-item-content'><p>習得 <code>object permanence (物體恆常性)</code></p><ul><li>1 個月大：嬰兒會追蹤物體，但是物體消失後他即刻轉頭。</li><li>3 個月大：即使物體消失，嬰兒會繼續追蹤物體。</li><li>8-12 個月大：他們會去找物體。</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(2-7) - Preoperational stage</p></div></div><div class='timeline-item-content'><p><code>Egocentrism</code> (自我中心) - 無法站在別人角度思考。<br>ex: 同樣多的水倒入不同寬度的瓶子，孩子會認為高度較高的水量較多。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(7-11) - Concrete operational stage</p></div></div><div class='timeline-item-content'><p>可以做具體的 <code>mental operations</code> (心理操作、推理)。<br>ex: 前一個範例已經可以推論兩邊水量相同。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(11-) - Formal operations stage</p></div></div><div class='timeline-item-content'><p>學會<code>抽象思考</code><br>ex: 若 A，則 B -&gt; 非 A，則非 B。</p></div></div></div><h3 id="vygotsky-s-sociocultural-theory">Vygotsky’s Sociocultural Theory</h3><img src="/2024/11/08/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L9/Vygotsky.png" class="" title="Vygotsky"><p><code>Zone of Proximal Development</code> 是可以透過教育來不斷擴張的。</p><ul><li>Scaffolding 搭鷹架<br>成人透過類似搭鷹架的方式幫助孩子學習如何思考解決問題。</li></ul><h3 id="erikson-s-psychosocial-stages">Erikson’s Psychosocial Stages</h3><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>發展時間軸</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(0-1.5) - Trust vs. mistrust</p></div></div><div class='timeline-item-content'><p>將世界視為一個安全、可靠的地方。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(1.5-3) - Autonomy vs. shame &amp; doubt</p></div></div><div class='timeline-item-content'><p>開始探索。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(3-6) - Initiative vs. guilt</p></div></div><div class='timeline-item-content'><p>開始可以做出某些行為。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(6-12) - Industry vs. inferiority</p></div></div><div class='timeline-item-content'><p>培養自信心。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(青春期) - Identity vs. role confusion</p></div></div><div class='timeline-item-content'><p>開始問自己是誰，產生身分認同。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(青年期) - Intimacy vs. isolation</p></div></div><div class='timeline-item-content'><p>形成穩定、親密的關係，或是感到孤獨和孤立。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(中年期) - Generativity vs. stagnation</p></div></div><div class='timeline-item-content'><p>在生活中找到價值，將精力投入家庭、工作或社區。</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>(老年期) - Integrity vs. despair</p></div></div><div class='timeline-item-content'><p>覺得自己活得很充實的人會有一種正直和平靜的感覺。</p></div></div></div><h2 id="acquiring-language-習得語言">Acquiring Language 習得語言</h2><ul><li>Phoneme (音位) – 語音當中可以造成意義不同的最小單位。<ul><li>不同的語言可能有不同的音位判定，導致不同國家的人對於語言中聲音的判斷不一致。</li></ul></li><li>Grammar (文法)<ul><li>某些研究者認為我們天生就有使用文法的本能。</li><li>ex:聽障兒童若沒有被教導手語，他們會自己發展出一套有規則的手語。</li></ul></li></ul><h2 id="social-development-人際發展">Social development 人際發展</h2><p>Attachment (依附) – 孩童和照顧者形成的情感關係。依附除了提供食物之外，也包含了 <code>Contact comfort</code>，有三種依附類型：</p><ul><li>Secure (安全): 表現出些許沮喪，但他們慢慢回到正常狀態。</li><li>Insecure-attached-avoidant (不安全迴避型): 幼兒忽略母親。</li><li>Insecure-attached-resistant (不安全抵抗型): 幼兒展現出生氣以及抵<br>抗。</li></ul><p>Parenting style (教養方式) 也會影響童年到青少年時期的依附關係。</p><h2 id="moral-development-道德發展">Moral development 道德發展</h2><h3 id="kohlberg-s-stages-of-moral-reasoning">Kohlberg’s stages of moral reasoning</h3><ul><li>Dilemmas （兩難）<ul><li>ex: 某年輕人闖進藥局偷藥來治療他的妻子。這是對的嗎?</li></ul></li><li>對與錯的判斷?</li></ul><p>道德是有階段性的，循序漸進，但是不一定每個人都會到達最高階段。</p><div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>道德的三個階段</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Preconventional morality</p></div></div><div class='timeline-item-content'><p>某件事情是對的，因為它可以讓你得到快樂或是遠離痛苦。</p><ul><li>Stage 1: pleasure/pain orientation</li><li>Stage 2: Cost-benefit orientation</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Conventional morality</p></div></div><div class='timeline-item-content'><p>某件事是對的，因為法律或是道德規範說它是對的。</p><ul><li>Stage 3: Good-child orientation</li><li>Stage 4: Law and order orientation</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Principle morality</p></div></div><div class='timeline-item-content'><p>某件事是對的，因為它符合正義/增加大多數人福祉/符合普世價值。</p><ul><li>Stage 5: Social contract orientation</li><li>Stage 6: Ethical principle orientation</li><li>Stage 7: Cosmic orientation</li></ul></div></div></div>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L8</title>
      <link href="/2024/11/01/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/"/>
      <url>/2024/11/01/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/</url>
      
        <content type="html"><![CDATA[<h1>L8 智力</h1><h2 id="測量">測量</h2><p>心理學相關的測量對於準確度的判斷方式：</p><ul><li>Reliability 信度 - 分數穩不穩定<ul><li>Test-retest reliability 再測信度 - 同一組人做相同的測驗兩次，這兩次的結果相關高不高。</li><li>Internal reliability 內部信度 - 把同一份測驗的單數題和偶數題做相關，這相關值高不高。</li></ul></li><li>Validity 效度 - 測驗是否能取得預期的測量結果<ul><li>Criterion-related validity 效標效度 - 這測驗跟效標是否相關。</li></ul></li></ul><div class="note primary no-icon flat"><p>效標：一個可以用來檢定你測驗好壞的標準。<br>ex:智力測驗常用的效標是學生日後的學習表現。</p></div><p>其他相關名詞：</p><ul><li>Norm 常模<ul><li>你必須要把你的分數跟其他人分數構成的分配 (常模) 做比較才有意義。</li></ul></li><li>Standardization 標準化<ul><li>每個人必須要在相同的情境下作測驗。</li></ul></li></ul><h2 id="智力測驗">智力測驗</h2><ul><li>The Stanford-Binet Intelligence Scale 兒童用<ul><li>Intelligence Quotient (IQ) 智商 = Mental age (心智年齡) / Chronological age (實際年齡)* 100</li></ul></li><li>The Wechsler Intelligence Scale 成人用 (16歲以上)<ul><li>包括語言 verbal 及非語言 non-verbal 量表。</li><li>目前版本 - WAIS-IV。</li><li>平均值 100，標準差 15。</li></ul></li></ul><img src="/2024/11/01/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L8/iq.png" class="" title="IQ"><h2 id="智力理論">智力理論</h2><h3 id="psychometric-theories-心理測量學">Psychometric theories 心理測量學</h3><p>從智力測驗分數去探測智力。</p><ul><li>Spearman - 人們在不同測驗的分數有高相關性。<ul><li>存在著一個 <code>General intelligence</code> 或是 <code>g</code>，與各種能力有相關性。</li></ul></li><li>Cattell - <code>General intelligence</code> 可以被分為：<ul><li>Crystallized intelligence 結晶智力 - 詞彙與基本知識。</li><li>Fluid Intelligence 流體智力 - 發現複雜聯繫、解決問題。</li></ul></li></ul><h3 id="sternberg-s-triarchic-theory-智力三元理論">Sternberg’s Triarchic theory 智力三元理論</h3><p>將智力分為三個面向：</p><ul><li>Analytical intelligence 分析智力<ul><li>知識獲取。</li><li>解決問題。</li><li>策略選擇。</li></ul></li><li>Creative intelligence 創造智力</li><li>Practical intelligence 實用智力<ul><li>適應新環境。</li></ul></li></ul><h3 id="gardner-s-theory-of-eight-multiple-intelligences">Gardner’s Theory of Eight Multiple Intelligences</h3><p>將智力分為八個部分：</p><ul><li>語言</li><li>邏輯與數學</li><li>視覺與空間</li><li>音樂</li><li>身體動覺</li><li>內在</li><li>人際</li><li>自然主義</li><li>存在主義</li></ul><h2 id="智力與遺傳-環境">智力與遺傳 &amp; 環境</h2><p>雙胞胎研究：利用同卵 &amp; 異卵雙胞胎的基因特性以及養育的環境區別做研究。</p><ul><li>基因的重要性：同卵 &amp; 異卵雙胞胎各一組一起養，觀察兩組的相關性。</li><li>環境的重要性：同卵雙胞胎，一組一起養，一組分開養，觀察兩組的相關性。</li></ul><p>結果：兩者都有相關，基因 &amp; 環境也許會互相影響 (不是獨立變量)。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-霍夫曼編碼</title>
      <link href="/2024/10/22/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%B7%A8%E7%A2%BC/"/>
      <url>/2024/10/22/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%B7%A8%E7%A2%BC/</url>
      
        <content type="html"><![CDATA[<h1>霍夫曼編碼</h1><p>一種編碼方式，使最常出現的字有最短的編碼，不常出現的字則有較長的編碼，使編碼後的字串長度減短進行壓縮，在壓縮時要確保每個字的編碼不能為其他字編碼的前綴，否則解碼時會出現錯誤。</p><h2 id="構建">構建</h2><p>一開始每個字都是一顆獨立的樹，根據其出現次數進行排序，每次從其中挑選出出現次數最少的兩棵樹，將其合併，分別做為新的樹的左右節點，並且新的樹出現次數為其兩者之和，重複以上步驟值到只剩下一棵樹。</p><h2 id="查詢">查詢</h2><p>在編碼的字串中，根據 <code>0</code> 或 <code>1</code> 在樹中往左或右節點前進，直到到達葉節點，葉節點代表的字即為編碼前的字。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L7</title>
      <link href="/2024/10/19/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/"/>
      <url>/2024/10/19/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L7/</url>
      
        <content type="html"><![CDATA[<h1>L7 認知、語言與創造力</h1><h2 id="thinking-思考">Thinking 思考</h2><ul><li>圖像</li><li>概念<ul><li>就算沒有看過某張照片，也能辨別其中的動物。</li><li>prototype approach to categorization 在腦中有動物的原型。</li></ul></li><li>語言<ul><li>根據有限的單字，產生無限的信息。</li><li>語言會影響你的思考方式。(ex:沒有未來式語言的國家的人通常比較勤奮)</li></ul></li></ul><h3 id="語言的結構">語言的結構</h3><ul><li>Phoneme 音素<ul><li>可以區別不同語意的最小語音單位，每個語言切分的方式不同。</li><li>中文的 ㄅ 與 ㄆ 為不同phonemes</li></ul></li><li>Morpheme 詞素<ul><li>有意義的最小語言單位</li><li>以中文來說，一個字就是一個 morpheme。</li></ul></li><li>Syntax 句法<ul><li>將單字組成句子的規則</li><li>中文基本上是主詞 -&gt; 動詞 -&gt; 受詞</li></ul></li></ul><h2 id="problem-solving-解題">Problem Solving 解題</h2><p>解不出問題可能的原因 - functional fixedness</p><ul><li>執著於每個東西都只有它被附屬的功能。</li></ul><p>想要增加問題解決能力 - Expertise 專家性</p><ul><li>在某個領域當中，由於長期訓練造成較佳的知識結構，使得其對於事物的組織方式不同。<br>ex:專家棋手跟生手一起看一盤棋局，並在之後回想該棋局。</li><li>棋局合理 - 專家表現較好</li><li>隨機產出的棋局 - 生手表現較好</li></ul><p>Memory chunking - 專家在記取知識的時候，不是以一個一個單一刺激為單位，而是以一群刺激為單位 (某些特定的棋類術語)。</p><h2 id="creativity-創造力">Creativity 創造力</h2><ul><li>產生某個原創性且有價值事物的歷程。</li><li>產生不同想法的能力。</li></ul><p>怎樣增加創造力 - 減少對事情的固著 (降低對於範例的依賴)</p><h2 id="judgment-and-decision-making-判斷與決策">Judgment and decision making 判斷與決策</h2><h3 id="judgment">Judgment</h3><p>Heuristics 捷思 - 解決複雜問題的捷徑<br>在做判斷時我們不一定每次都會理性地去一步步分析判斷，而是依賴 <code>捷思</code> 幫我們迅速地做出判斷。</p><ul><li>Availability heuristic 根據印象中比較容易取得的記憶做判斷。</li><li>Representativeness heuristic 根據某事物的典型印象做判斷。</li><li>Anchoring heuristic 根據初始值向上或向下調整。</li></ul><h3 id="decision-making">Decision making</h3><p>Framing 取景 - 如何敘述問題<br><code>Framing</code> 可能會影響人們對問題的判斷，正面或反面的描述 (ex:死亡率與存活率)。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L6</title>
      <link href="/2024/10/11/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L6/"/>
      <url>/2024/10/11/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L6/</url>
      
        <content type="html"><![CDATA[<h1>L6 記憶</h1><img src="/2024/10/11/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L6/memory.jpg" class="" title="memory"><h2 id="sensory-memory-感覺記憶">Sensory Memory 感覺記憶</h2><p>當客觀刺激停止作用之後，感覺訊息會在一個極短的時間內保存下來。</p><ul><li>Iconic memory 圖像記憶 - 視覺</li><li>Echoic memory 回聲記憶 - 聽覺</li></ul><h2 id="short-term-memory-短期記憶">Short-term Memory 短期記憶</h2><p>可以在頭腦中讓少量資訊保持啟用狀態，在短時間內可以使用。短期記憶的持續時間以秒計算，通常在 5－20 秒，可以透過 <code>Rehearsal (覆誦)</code> 增加其留在頭腦的時間，而短期記憶的容量約為 <code>7 ± 2</code> 個元素。</p><h2 id="long-term-memory-長期記憶">Long-term Memory 長期記憶</h2><p>能夠保持幾天到幾年的記憶。</p><h3 id="explicit-memory-外顯記憶">Explicit Memory 外顯記憶</h3><ul><li>Semantic 語言 - 一般的事實性知識。</li><li>Episodic 情節 - 特定事件觀察性的資訊。</li><li>Serial Position Effect 序位效應<br>人們傾向於對首先見到的事物和最後見到的事物有更好的記憶：<ul><li>primacy effect (一開始見到的)</li><li>recency effect (最後見到的)</li></ul></li></ul><h3 id="implicit-memory-內隱記憶">Implicit Memory 內隱記憶</h3><ul><li>Procedural memory 程序記憶 - 技術性知識。</li><li>Classical conditioning 古典制約</li><li>Priming 促發<br>接觸某刺激後這個刺激會對你之後的行為產生影響。</li></ul><h2 id="forgetting-遺忘">Forgetting 遺忘</h2><ul><li>Encoding failure<br>記憶在一開始沒有完全形成。</li><li>Storage Failure<br>記憶痕跡變弱，記憶力衰退。</li><li>Retrieval Failure<ul><li>干擾</li><li>狀態依賴的學習 - 學習時與測驗時保持相同的情緒 (傷心或快樂) 可能導致更好的成績。</li></ul></li></ul><h2 id="is-memory-always-real">Is memory always real?</h2><p>Elizabeth Loftus 的實驗：<br>受試者分為兩組人，觀看兩車對撞的影片，分別詢問</p><ul><li>請問這兩部車 <code>碰撞</code> 時，時速大約多少?</li><li>請問這兩部車 <code>猛烈撞擊</code> 時，時速大約多少?</li></ul><p>下組人比上組人事後更容易回憶地上有碎玻璃，<code>即使事實上沒有碎玻璃</code>。</p><h3 id="flashbulb-memories-閃光燈記憶">Flashbulb Memories 閃光燈記憶</h3><p>當重大的事件發生時，形成的永久性記憶，讓人有歷歷在目的感覺，雖然人們對自己的記憶充滿自信，但卻會遺忘記憶的細節，甚至產生虛假的記憶。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L5</title>
      <link href="/2024/10/04/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/"/>
      <url>/2024/10/04/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/</url>
      
        <content type="html"><![CDATA[<h1>L5 學習</h1><h2 id="associative-learning-聯想學習">Associative learning - 聯想學習</h2><p>刺激 -&gt; 反應<br>由兩種或以上刺激引起腦內的中樞興奮，而形成的連結實現的學習過程。</p><h3 id="classical-conditioning-古典制約">Classical Conditioning - 古典制約</h3><ul><li><p>巴夫洛夫的狗</p><ul><li>鈴鐺聲 &amp; 食物 -&gt; 流口水的關係</li></ul></li><li><p>制約的過程：</p>  <img src="/2024/10/04/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/conditioning.png" class="" title="conditioning"><p>Extinction 是逐漸遺忘的過程，在經過一段時間 (Rest Period) 後，如果經歷同樣的刺激，可能導致制約的恢復 (Spontaneous recovery)。</p></li><li><p>應用：系統減敏感法</p><ol><li>建立焦慮的等級層次。</li><li>學習放鬆或其他應對策略。</li><li>使用應對策略逐步克服焦慮等級中的每一個層次。</li></ol></li></ul><h3 id="operant-conditioning-操作制約">Operant conditioning - 操作制約</h3><ul><li>某反應導致了令人滿意的結果 -&gt; 你會繼續做它。</li><li>某反應導致了令人不滿的結果 -&gt; 你會不傾向做它。</li></ul><p>範例：</p><ul><li>史金納箱<ul><li>按鈕 -&gt; 食物對老鼠產生的制約</li></ul></li></ul><img src="/2024/10/04/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/Skinner.png" class="" title="Skinner"><p>操作方式：</p><ul><li><p>Reinforcement - 增強</p><ul><li>Positive 做對了，給你糖</li><li>Negative 做對了，不打你</li></ul></li><li><p>Punishment - 懲罰</p><ul><li>Positive 做錯了，打你</li><li>Negative 做錯了，不給你糖</li></ul></li><li><p>Shaping：把目標行為拆成很多小步驟，然後漸漸一步一步訓練個體。</p></li></ul><h3 id="partial-operant-conditioning-部分操作制約">Partial operant conditioning - 部分操作制約</h3><ul><li>Fixed Ratio Schedules<ul><li>每做三件衣服才有錢拿。</li></ul></li><li>Variable Ratio Schedules<ul><li>平均看手機十次，會有新的訊息。</li></ul></li><li>Fixed Interval Schedules<ul><li>每隔一段時間對按鈕有反應 (冷卻時間)。</li></ul></li><li>Variable Interval Schedules<ul><li>平均等三十分鐘會有一條魚。</li></ul></li></ul><h2 id="cognitive-learning-認知學習">Cognitive learning - 認知學習</h2><p>刺激 -&gt; 認知系統 -&gt; 反應<br>有些學習無法用 <code>classical conditioning</code> 或是 <code>operant conditioning</code> 解釋。</p><ul><li>Cognitive map<ul><li>提供現象在日常生活中或隱喻性空間環境中的相對位置和屬性的資訊。</li></ul>  <img src="/2024/10/04/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L5/Cognitive-map.png" class="" title="Cognitive-map"><ul><li>老鼠與迷宮的實驗：當老鼠被放置在十字迷宮的不同方向上時，由於老鼠在最初已經建好了迷宮的認知地圖，所以仍然會朝著正確的方向去獲取食物。</li></ul></li><li>Discovery learning - 發現式學習<ul><li>一種建構式教學法，促發學生主動解決問題的能力與興趣。希望讓學生將他已學到的基礎能力，擴展到解決未知的題目。</li></ul></li><li>Observational learning - 觀察學習<ul><li>Albert Bandura’s experiment 小孩會模仿大人所做的行為</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Graph</title>
      <link href="/2024/10/01/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Graph/"/>
      <url>/2024/10/01/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Graph/</url>
      
        <content type="html"><![CDATA[<p>本文主要關於使用 <code>DFS</code> 以及 <code>BFS</code> 遍歷圖的過程。</p><h1>DFS</h1><p>圖中的點有三種狀態：</p><ul><li>unvisited：尚未訪問</li><li>in progress：訪問其相鄰節點中</li><li>all done：已經訪問所有相鄰節點 (皆不是 <code>unvisited</code> 狀態)<br>初始狀態皆為 <code>unvisited</code>，而每個點除了各自的狀態之外，還儲存了兩個值，分別為 <code>startTime</code> 和 <code>finishTime</code>，這個等等在 <code>Topological Sort</code> 會用到。</li></ul><p>pseudocode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DFS(w, currentTime)&#123;</span><br><span class="line">    w.startTime = currentTime</span><br><span class="line">    currentTime ++</span><br><span class="line">    Mark w as `in progress`.</span><br><span class="line">    for (v in w.neighbors)&#123;</span><br><span class="line">        if (v is `unvisited`)&#123;</span><br><span class="line">            currentTime = DFS(v, currentTime)</span><br><span class="line">            currentTime ++</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    w.finishTime = currentTime</span><br><span class="line">    Mark w as `all done`</span><br><span class="line">    return currentTime</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="應用">應用</h2><h3 id="topological-sort">Topological Sort</h3><p>針對有向無環圖 (Directed Acyclic Graph, DAG) 的排序法，這個排序法可以讓圖中的所有邊朝向同一個方向，並且有以下特點：<code>當 p 點在 q 點之前，則不存在從 q 點到 p 點的路徑</code>。</p><p>之前 <code>DFS</code> 遍歷時產生每個點的 <code>finishTime</code>，具有以下的特性：<code>如果有 p 點指向 q 點，則 p.finishTime &gt; q.finishTime</code>，要證明的話可以透過 <code>DFS tree</code> 來觀察，如果有 p 點指向 q 點則可以分為兩種情況：</p><ol><li>在 <code>DFS tree</code> 中 q 點為 p 點的子孫節點： <div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>時間軸</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>p.startTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>q.startTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>q.finishTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>p.finishTime</p></div></div></div></li><li>在 <code>DFS tree</code> 中 q 點不為 p 點的子孫節點<br>此時必定會先經過並完成 q 點，不然 q 點就會是 p 點的子孫節點。 <div class="timeline undefined"><div class='timeline-item headline'><div class='timeline-item-title'><div class='item-circle'><p>時間軸</p></div></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>q.startTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>q.finishTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>p.startTime</p></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'></div></div><div class='timeline-item-content'><p>p.finishTime</p></div></div></div></li></ol><p>有了以上的特點，我們要進行 <code>Topological Sort</code> 就只要將各點的 <code>finishTime</code> 由大排到小即可，我們可以在遍歷的過程中，每完成一個節點，就將其放入 <code>list</code> 的頂端，最後 <code>list</code> 由頂端到底端就是已排序的結果。</p><h1>BFS</h1><p>每次向前推進一步，<code>L_i</code> 代表 <code>第 i 步可以走到的點</code>，<code>L_0</code> 為出發點，每次尋找 <code>L_i</code> 的相鄰節點，如果還沒訪問就將其放到 <code>L_i+1</code> 中。</p><p>pseudocode:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Set L_i = [] for i=1,...,n</span><br><span class="line">L0 = [w], where w is the start node</span><br><span class="line">Mark w as `visited`</span><br><span class="line">for (i = 0, ..., n-1)&#123;</span><br><span class="line">    for (u in L_i)&#123;</span><br><span class="line">        for (each v which is a neighbor of u)&#123;</span><br><span class="line">            If (v isn’t yet visited)&#123;</span><br><span class="line">                mark v as visited, and put it in L_i+1</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="應用">應用</h2><h3 id="shortest-path">Shortest path</h3><p>尋找兩個點 <code>u</code> 和 <code>v</code> 之間的最短距離與路徑 (不考慮邊的權重)，從 <code>u</code> 點開始執行 BFS，則對於每個點 <code>v</code> 在 <code>L_i</code> 中，<code>u</code> 和 <code>v</code> 之間的最短距離為 <code>i</code>，且可以在 <code>BFS tree</code> 中看到最短路徑。</p><h3 id="二分圖檢驗">二分圖檢驗</h3><p>二分圖指的是可以將圖分成兩群點，兩群點之間有邊，兩群點的內部則無邊。</p><p>選擇一個點開始進行 BFS，將點依序塗成兩種顏色 (ex: <code>i</code> 為奇數時，<code>L_i</code> 的點為紅色，反之為藍色)，如果有任何兩個相鄰的點為同色 (形成奇環：有奇數條邊的環)，則這個圖不是二分圖。</p><h1>Strongly Connected Components (SCC)</h1><p><code>Strongly Connected Components</code> 翻譯為強連通元件，出現在有向圖中，<code>SCC</code> 中的任兩個點 <code>u</code> 和 <code>v</code> 都可以找到 <code>u -&gt; v</code> 和 <code>v -&gt; u</code> 的路徑，一個有向圖中，可能包含多個不重疊的 <code>SCC</code>。</p><h2 id="尋找-scc">尋找 SCC</h2><ol><li><p>建立 <code>DFS forest</code><br>在有向圖中，不一定每個點都能到達另一個點，因此一次的 <code>DFS</code> 不一定能遍歷到所有點，進行完一次之後要在尚未遍歷到的點中找一個點在進行一次 <code>DFS</code>，直到所有點都遍歷到為止，這時候形成的就不只是一顆 <code>DFS tree</code> 了，而是由好幾棵樹組成的 <code>DFS forest</code>。</p><p>在建立時要記得紀錄每個點的 <code>startTime</code> 和 <code>finishTime</code>。</p></li><li><p>將原本有向圖中的每條邊反轉 (<code>u -&gt; v</code> 變為 <code>v -&gt; u</code>)。</p></li><li><p>依照 <code>finishTime</code> 的大小排序，由最大的點開始進行 <code>DFS</code>，結束之後由剩下的點中最大的再次進行 <code>DFS</code>，直到遍歷完所有點，這時候形成的 <code>DFS forest</code> 中的每一顆樹就是一個 <code>SCC</code> 了 (每進行一次 <code>DFS</code> 就會找到一個 <code>SCC</code>)。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Graph </tag>
            
            <tag> 資料結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L4</title>
      <link href="/2024/09/28/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L4/"/>
      <url>/2024/09/28/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L4/</url>
      
        <content type="html"><![CDATA[<h1>L4 意識狀態</h1><ul><li>清醒的意識 - 知覺</li><li>其他意識 - Altered State of Consciousness (意識的改變狀態)</li></ul><h2 id="催眠">催眠</h2><h3 id="起源">起源</h3><ul><li>Franz Mesmer：相信可以透過在身體上移動磁鐵 (透過動物磁性) 來治癒疾病 (mesmerize = hypnotize)。</li><li>James Braid：創造了術語 <code>hypnosis</code>，意為 <code>sleep</code>。</li></ul><h3 id="理論">理論</h3><ul><li>State theories<ul><li>催眠屬於意識的改變狀態。</li><li>Hidden observer：被催眠者意識中分離的部分，靜靜地觀察事件。</li></ul></li><li>Nonstate theories<ul><li>被催眠者不屬於特定的狀態。</li><li>是順從、放鬆、想像、服從和角色扮演的混合體。</li></ul></li><li>Hypnotic susceptibility (催眠敏感度)<ul><li>一個人有多容易被催眠。</li></ul></li></ul><h3 id="作用">作用</h3><ul><li>能夠<ul><li>增加記憶 (不管是否存在)</li><li>產生短暫的健忘</li><li>減輕疼痛</li><li>產生感覺的變化</li><li>放鬆</li></ul></li><li>不能<ul><li>產生超人類的力量</li><li>真正的年齡倒退</li><li>強迫做出違背意願之事</li></ul></li></ul><h2 id="冥想">冥想</h2><h3 id="類型">類型</h3><ul><li>集中冥想<ul><li>專注於一個焦點、物體、想法或你自己的呼吸。</li></ul></li><li>正念冥想<ul><li>通過專注當下的注意力，不做任何評斷地觀察自己的思緒、情感、身體感覺和周遭環境。</li></ul></li></ul><h3 id="作用">作用</h3><ul><li>能夠<ul><li>減輕壓力 - 去除令人不安的想法</li><li>提高意識</li></ul></li></ul><h2 id="睡眠">睡眠</h2><ul><li>睡眠的原因 - 節約能量。</li><li>快速動眼期 (REM)<ul><li>在此睡眠階段中，眼球會快速移動，同時身體肌肉放鬆，大多數的夢產生於這個階段。</li></ul></li></ul><h2 id="作夢">作夢</h2><ul><li>The psychodynamic dream theory (心理動力夢理論)<ul><li>願望實現 - 夢是無意識中對慾望的表達。</li><li>夢的象徵 - 夢中具有更深象徵意義的圖像。</li></ul></li><li>The activation-synthesis hypothesis (活化合成假說)<ul><li>低階大腦中樞的隨機活動導致高階大腦中樞製造出相對怪異、毫無意義的夢。</li></ul></li><li>Neurocognitive dream theory (神經認知夢理論)<ul><li>夢境反映日常工作的想法和情緒 - 整理、儲存日常經驗。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Tree-3</title>
      <link href="/2024/09/24/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-3/"/>
      <url>/2024/09/24/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-3/</url>
      
        <content type="html"><![CDATA[<h1>Self-Balancing Binary Search Trees</h1><h2 id="avl樹">AVL樹</h2><p>在 AVL 樹中，任一節點對應的兩棵子樹的最大高度差為 1，也被稱為高度平衡樹，增加和刪除元素的操作則可能需要藉由一次或多次樹旋轉，以實現樹的重新平衡。</p><img src="/2024/09/24/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-3/Tree_Rebalancing.png" class="" title="旋轉過程"><h2 id="紅黑樹">紅黑樹</h2><p>在某些屬性上形成平衡，不追求高度的完全平衡，犧牲了部分平衡性以換取插入和刪除操作時少量的旋轉操作，整體來說效能要優於 AVL 樹。</p><p>規則：</p><ol><li>節點是紅色或黑色。</li><li>根是黑色。</li><li>所有葉子都是黑色 (葉子是 NIL 節點)。</li><li>每個紅色節點必須有兩個黑色的子節點。</li><li>從任一節點到其每個葉子的所有簡單路徑都包含相同數目的黑色節點。</li></ol><img src="/2024/09/24/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-3/Red-black_tree_example.png" class="" title="範例">]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> 資料結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter-Formosa-2024心得</title>
      <link href="/2024/09/23/Flutter-Formosa-2024%E5%BF%83%E5%BE%97/"/>
      <url>/2024/09/23/Flutter-Formosa-2024%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1>關於</h1><p>距離 <code>Flutter Formosa 2024</code> 已經過了一段時間，<code>Flutter Formosa 2024</code> 是台灣第一次的 Flutter 研討會，有許多業界的大佬演講，很高興能夠報名參加，雖然交流時間我都只敢待在自己座位上偷聽(?)但是還是在精彩的演講中學到許多，得到很多寶貴的經驗，尤其是 Web 開發的部分特別有共鳴。</p><h1>概要與心得</h1><p>挑選了幾篇比較有興趣的演講做整理。</p><h2 id="利用-atdd-改善開發流程">利用 ATDD 改善開發流程</h2><p>這個演講邀請到了負責 LINE 購物 APP 開發的 Technical Project Lead，主要在分享透過 <code>ATDD (驗收測試驅動開發)</code> 來幫助改善開發流程。</p><h3 id="重點">重點</h3><p>使用 ATDD 之前可能會遇到的問題：</p><ul><li>Long-lived Feature Branches：跨 sprint 的功能開發，功能完成才 merge。<ul><li>合併時出現大量的衝突。</li><li>解決衝突耗費且易出錯。</li></ul></li><li>遺漏撰寫 Unit Tests：優先開發功能，接著才撰寫 unit tests。<ul><li>難以保證程式碼品質。</li><li>難以及時發現錯誤。</li><li>降低程式碼的可維護性。</li></ul></li></ul><p>而兩個問題的解決的方向如下：</p><ul><li>Long-lived Feature Branches<ul><li>利用驗收標準 (Acceptance Criteria, AC) 將 user story 拆解更小且可驗證的 subtasks。</li><li>使用 feature toggle 保護 merge 回 main 的 PRs。</li></ul></li><li>遺漏撰寫 Unit Tests<ul><li>功能的 PRs 一定要包含 unit tests。</li><li>Test-Driven Development (TDD)。</li></ul></li></ul><p><code>ATDD (驗收測試驅動開發)</code> 就是結合了 <code>驗收標準 (AC)</code> 以及 <code>Test-Driven Development (TDD)</code> ，強調在開發人員開始撰寫程式碼之前撰寫驗收測試，並將 user story 依照 <code>驗收標準 (AC)</code> 拆解成一個一個部份處理，因為每個 AC 的改動不大，因此開發之後可以放心的 merge，並且每個部份也都包含了 unit tests。</p><p>ATDD 的優點：</p><ul><li>明確的開發目標和流程一致性。</li><li>可操作且人性化的測試敘述。</li><li>縱向測試覆蓋和驗收標準對應性。</li><li>減少測試窮舉。</li></ul><h3 id="名詞解釋">名詞解釋</h3><ul><li>hybrid app：演講中提到 LINE 購物 APP 是 <code>hybrid app</code>，指的是原生App和Web App 的結合體，首頁和搜尋等功能是 native 的畫面，而點進去產品則是使用 WebView 來顯示。</li><li>Unit Tests：針對程式模組來進行正確性檢驗的測試工作，程式單元通常是指單個程式、函式、過程等，也有可能是針對某個特定功能做測試。</li><li>feature toggle：軟體開發中的一種技術，可以在在執行程式期間隱藏、啟用或禁用特定功能進行測試 (像是一個開關)，而其他使用者不會被啟用該功能和受到它的影響。</li><li>PRs：Pull Request，請求合併。</li><li>驗收測試：從系統的外部視角做檢查，確保產品符合業務需求和用戶期望，通常包含 <code>Given (前提條件)</code>、<code>When (操作)</code> 以及 <code>Then (預期結果)</code>。</li></ul><h2 id="ai-x-flutter-新時代的交互體驗">AI x Flutter 新時代的交互體驗</h2><p>此演講由 KryptoGO 的 Flutter Team Lead 主講，提到了如何將 LLM 與 Flutter 結合使用。</p><h3 id="重點">重點</h3><ul><li>集成型 AI (ex: Github Copilot, Memo, Cursor)<ul><li>語言的局限性終究會帶來 UX 體驗的破壞</li></ul></li></ul><p>要將 AI 整合進入產品中，主要有兩個面向，<code>改善輸入方式</code> 和 <code>提升輸出質量</code>。<br>改善輸入方式：</p><ul><li>自然語言輸入：簡化操作步驟。<ul><li>語音輸入 (ex:<code>Speech to Text</code>, <code>Whisper</code> package)。</li></ul></li><li>多模態輸入：支持文本、語音、圖片等多種輸入方式。<ul><li>語音輸入的不同語調。</li><li>圖片輸入：OCR 判斷人物情緒或是環境訊息。</li></ul></li><li>意圖釐清：協助使用者提升輸入的質量。<ul><li>可以幫助用戶釐清自己的問題，甚至讓用戶得到意料之外的答案。</li></ul></li></ul><p>提升輸出質量：</p><ul><li>優化 AI 輸出：Fine Tune。<ul><li>優化 System Prompt<ul><li>明確定義角色和目標。</li><li>設定行為準則。</li><li>指定輸出格式。</li><li>設置知識範圍。</li><li>錯誤處理指南。</li></ul></li><li>Fine Tune 模型<ul><li>準備高質量對話範例進行訓練。</li></ul></li></ul></li><li>動態畫面渲染。<ul><li>配合 <code>dynamic_widget</code> library，可以實時的讓 AI 幫我們產生 widget。</li><li>優點：可以隨時生產新畫面。</li><li>缺點：畫面、風格不容易控制。</li></ul></li><li>Function Call：與 AI 功能串連。<ul><li>賦予 AI 可以去呼叫的程式中的方法的能力 (ex: Rive 互動式動畫)。</li></ul></li></ul><p>架構建議：AI 進步的速度實在太快，盡量讓設計可以多兼容更多 AI 模型。</p><h3 id="名詞解釋">名詞解釋</h3><ul><li>UX：User Experience，使用者體驗。</li><li>System Prompt：系統指令或背景設定，定義 AI 助手的行為、知識範圍、人格特徵等。</li></ul><h2 id="關於-mobile-developer-用-flutter-去寫-web-這檔事">關於 Mobile Developer 用 Flutter 去寫 Web 這檔事</h2><p>這個演講主要關於使用 Flutter 去寫 Web 的一些細節與開發軟體的差異等。</p><h3 id="重點">重點</h3><ul><li>網頁前端不能隨便打後端的 API - CORS error<ul><li>解決方式：<ul><li><pre><code>flutter run -d chrome --web-browser-flag &quot;--disable-web-security&quot;</code></pre></li><li>將網頁框架改為 <code>html</code>。</li></ul></li></ul></li><li>麵包屑 - 導覽標記。</li><li>瀏覽器的分頁功能引發問題<ul><li>多個分頁重複登入。</li></ul></li><li>版面設計<ul><li>必須滿足不同分頁大小。</li></ul></li><li>善用開發者工具 (DevTool)<ul><li>看 print</li><li>看 API call</li><li>看 shared preferences</li></ul></li></ul><h2 id="democratizing-flutter-ci-cd-build-sustainable-workflows-with-openci">Democratizing Flutter CI-CD Build Sustainable Workflows with OpenCI</h2><p>此演講請來了日本的講者以英文演講，內容關於 CI/CD 的使用以及各種好處。</p><h3 id="重點">重點</h3><p>CI/CD 簡介：</p><ul><li>CI：Continuous Integration (持續整合)</li><li>CD：Continuous Delivery (持續部屬)</li></ul><p>如果沒有使用 CI/CD 可能會產生以下問題：</p><ul><li>Without CI<ul><li>程式碼品質下降</li><li>程式碼不一致</li><li>延後發現 bug</li></ul></li><li>Without CD<ul><li>不穩定且低效率的部署 (人工)</li><li>因為環境不同而建置 (build) 失敗</li><li>回饋延遲</li></ul></li></ul><p>使用 CI/CD 的優點：</p><ul><li>快速</li><li>更好的工作環境</li><li>多種不同選擇 ex: Github Actions, Codemagic, Bitrise and fastlane</li></ul><p>使用 CI/CD 的缺點：</p><ul><li>Flutter 的 CI/CD 花費較高 (相較於其他平台)</li><li>學習門檻 (寫 <code>yaml</code>)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L3</title>
      <link href="/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/"/>
      <url>/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/</url>
      
        <content type="html"><![CDATA[<h1>L3 知覺</h1><h2 id="視覺">視覺</h2><h3 id="視覺系統">視覺系統</h3><p>眼睛 + (大腦)<br>ex:視覺失認症 (雖然可以看到東西，但認不出來是什麼)</p><h3 id="視網膜">視網膜</h3><ul><li>光受器<ul><li>視錐細胞 Cone</li><li>視柱細胞 Rod</li></ul></li><li>雙極細胞 Bipolar cell</li><li>節細胞 Ganglion cell</li></ul><p>傳遞過程：</p><img src="/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/eye.png" class="" title="傳遞過程"><div class="note primary no-icon flat"><p>盲點：視神經從視網膜離開的地方，大腦可以會自動的幫我們 <code>想像</code> 來補充該點。</p></div><h3 id="彩色視覺">彩色視覺</h3><ul><li>三色論<ul><li>所有顏色都由三種基本色 (紅、綠、藍) 組合而成。</li><li>證據：有三種視錐細胞，分別對於不同顏色的敏感程度不同，形成不同的參數，構造出各種不同的顏色。</li><li>無法解釋 <code>後像</code> 的產生。</li></ul></li><li>對比論<ul><li>有三種系統 (黑白、紅綠、藍黃)，其中一種顏色受到持續性的刺激，會產生疲勞，導致我們之後看到另一種顏色。</li><li>證據：Opponent neurons 對於不同顏色產生不同反應。</li></ul></li><li>兩種論點的結合</li></ul><img src="/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L3/2sys.png" class="" title="結合"><h3 id="深度知覺">深度知覺</h3><ul><li>單眼線索<ul><li>Linear Perspective 線性透視</li><li>Relative Size 相對大小</li><li>Interposition (overlapping) 遮擋、重疊</li><li>Light &amp; Shadow 光影</li><li>Texture Gradient 紋理漸變</li><li>Aerial Perspective 空中透視</li><li>Relative Motion 相對運動</li></ul></li><li>雙眼線索<ul><li>Convergence 匯聚：看近物時雙眼視覺向正中聚合，提供物體遠近的線索。</li><li>Retinal Disparity 視差：左右視網膜所看到的物體位置差異，可以用來判断深度。</li></ul></li></ul><h3 id="格式塔學派">格式塔學派</h3><p>一個心理學的分支，致力於尋找物體辨識的原則。</p><ul><li>閉合法則 (完成圖形的傾向)</li><li>相似法則 (相似的圖形構成)</li><li>接近法則 (相近的圖形構成)</li><li>連續法則 (簡單且規則的圖形)</li></ul><h2 id="聽覺">聽覺</h2><h3 id="聲音">聲音</h3><ul><li>Pitch (音調)<ul><li>聲波頻率：20 ~ 20000 Hz (人可以聽到的範圍)</li></ul></li><li>Loudness (響度)<ul><li>聲波振福</li></ul></li><li>Timbre (音色)<ul><li>聲波波型</li></ul></li></ul><h3 id="聽覺系統">聽覺系統</h3><p>將空氣震動轉換為神經訊號<br><a href="https://www.youtube.com/watch?v=PeTriGTENoc">https://www.youtube.com/watch?v=PeTriGTENoc</a></p><ul><li>Place theory - 解釋高音<ul><li>每種音頻會讓 <code>basilar membrane</code> 特定區域的 <code>hair cells</code> 反應。</li><li>高音靠近  <code>base ofcochlea</code> (入口處)；低音在對面。</li></ul></li><li>Frequency theory - 解釋 4000 Hz 以下音<ul><li>100 Hz 的音會讓 <code>basilar membrane</code> 每秒震盪100次，讓神經也每秒反應100次。</li></ul></li></ul><h3 id="其他知覺">其他知覺</h3><ul><li>Somatosensation (身體感覺)<ul><li>皮膚的 <code>receptor</code> 把訊息送到大腦感覺皮質 - 臉部 &amp; 手敏感程度 &gt;&gt; 身體。</li></ul></li><li>Pain (痛覺)<ul><li><code>Gate Control Theory</code> - 某些情況會打開痛覺的 <code>Gate</code> 產生疼痛感，其他非痛的感覺則可以關閉痛覺的 <code>Gate</code> 減低疼痛的感覺。</li></ul></li><li>Kinesthetic Sense (動覺)<ul><li>對身體各部位的位置和運動狀況的感覺。</li></ul></li><li>Vestibular Sense (前庭覺)<ul><li>對位置、加速度和旋轉運動敏感。</li><li>暈車 - 視覺訊息跟前庭覺訊息不一致。</li></ul></li><li>嗅覺 - 大腦內部的 <code>Olfactory bulb (嗅球)</code> 可以感知氣味。</li><li>味覺 - 舌頭上對不同味道敏感的味蕾。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L2</title>
      <link href="/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L2/"/>
      <url>/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L2/</url>
      
        <content type="html"><![CDATA[<h1>L2 心與腦</h1><h2 id="心智與生理基礎">心智與生理基礎</h2><h3 id="相關證據">相關證據</h3><ul><li>Phineas Gage<br>被一支長鐵棍貫穿腦部，導致性格大變，讓科學家確定前額葉皮質受損會使人容易產生衝動、反社會行為。</li><li>Paul Broca<br>對病人 <code>Tan</code> 做研究。Tan 有發出語音的困難，發現其左前方的腦有損傷，將此區域命名為<code>布若卡氏區 (Broca's area)</code>，這個區域主管語言訊息的處理、話語的產生。</li></ul><h3 id="相關工具">相關工具</h3><ul><li>Electroencephalogram (EEG), Event related potential (ERP)<br>腦電描記術：高時間解析度，低空間解析度。<br><a href="https://en.wikipedia.org/wiki/Electroencephalography">https://en.wikipedia.org/wiki/Electroencephalography</a></li><li>Functional Magnetic resonance imaging (fMRI)<br>功能性磁振造影：高空間解析度，低時間解析度。</li><li>Transcranial magnetic stimulation (TMS)<br>非侵入性的腦刺激方式，利用變化的磁場透過電磁感應在大腦的特定區域感應出電流。</li></ul><h2 id="大腦">大腦</h2><h3 id="腦側化">腦側化</h3><p>左半邊多半由右腦控制。<br>ex:左視野訊息傳到右腦，右視野訊息傳到左腦 (左眼和右眼都有分左右視野)。<br>ex:左右腦分工。</p><h2 id="神經系統">神經系統</h2><h3 id="神經元">神經元</h3><ul><li>樹突 (類似樹根)</li><li>軸突 (類似樹幹)</li></ul><h3 id="膠細胞">膠細胞</h3><ul><li>導引讓新生的神經生長在正確的地方 (鷹架)。</li><li>形成髓鞘。</li><li>構成血腦障蔽。</li></ul><h2 id="訊息傳導">訊息傳導</h2><h3 id="動作電位">動作電位</h3><p>藉由細胞膜上離子通道的開關，讓細胞內外的鉀、鈉離子流動，造成膜電位的改變，產生<code>動作電位</code>，並在這個過程過程中引發鄰近細胞也產生動作電位，形成信息的傳遞。</p><div class="note primary no-icon flat"><p>髓鞘：具有絕緣效果，纏繞著軸突，讓動作電位只能在髓鞘之間的空隙 <code>蘭氏節</code> 上傳導，產生跳躍傳導，加快傳導速度並減少能量耗損。</p></div><h3 id="突觸傳遞">突觸傳遞</h3><p>神經元之間以 <code>突觸</code> 連接，傳遞信息的流程</p><ul><li>形成囊泡，釋放神經傳導素。</li><li>與另一個神經的受器結合。</li><li>打開離子通道，產生動作電位。<ul><li>正離子閘門：引發產生動作電位 (促進性)。</li><li>負離子閘門：減少產生動作電位 (抑制性)。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>心理學筆記-L1</title>
      <link href="/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L1/"/>
      <url>/2024/09/21/%E5%BF%83%E7%90%86%E5%AD%B8%E7%AD%86%E8%A8%98-L1/</url>
      
        <content type="html"><![CDATA[<h1>L1 心理學簡介與方法學</h1><h2 id="目前的心理學">目前的心理學</h2><p>以 <code>科學</code> 的方式探討人的行為，科學方法：</p><ul><li>建立假設</li><li>檢驗假設<ul><li>收集資料</li><li>解釋資料</li></ul></li><li>下結論</li></ul><h2 id="研究方法">研究方法</h2><div class="note primary no-icon flat"><p>變項：會改變的事項。<br>操作型定義：將變量以某種操作或觀測的方式表示出來。</p></div><h3 id="實驗法">實驗法</h3><p>操弄自變項，觀察依變項<br>ex:聽古典音樂與否會不會影響智力?</p><ul><li>自變項：聽古典音樂與否。</li><li>依變項：智力。<br>將受試者隨機分派至兩個組中，一組聽古典音樂，一組不聽，觀察一段時間後對智力的影響。</li></ul><div class="note primary no-icon flat"><p>在使用實驗法時也要注意避免 <code>混淆變項</code>。<br>ex:古典音樂通常包含的高頻音較高，可能是這些高頻音刺激腦部讓人變得聰明?</p></div><p>優缺點：</p><ul><li>優點<ul><li>較能保證因果關係</li></ul></li><li>缺點<ul><li>不自然</li><li>受試者知道你的目的</li><li>倫理問題</li></ul></li></ul><h3 id="相關法">相關法</h3><p>當遇到一些無法操弄的變項時，將統計出來的值進行相關性的分析，透過相關係數的大小說明其相關性。</p><div class="note primary no-icon flat"><p>有相關性 ≠ 有因果關係</p></div><h3 id="其他方法">其他方法</h3><ul><li>調查法：單純描述統計。</li><li>類實驗法(逼近實驗法的相關法)。<ul><li>盡可能控制受試者的變項一致。</li></ul></li></ul><h2 id="邏輯謬誤">邏輯謬誤</h2><ul><li>訴諸人身：對人不對事。</li><li>訴諸權威：過度相信權威所認定的敘述。</li><li>訴諸無知：認為某事為真，因為沒有證據反駁它。<ul><li>ex:因為沒有證據證明某遺跡為人類建造，因此外星人來過地球。</li></ul></li><li>乞題：講廢話，將欲證明的結論換到前提的論證。<ul><li>ex:左撇子比較聰明，因為右撇子的智商比較低。</li></ul></li><li>觀察選擇：只看到了事物的一面而忽略另一面。<ul><li>ex:某產品有 10 位見證人來證明它的有效性。</li></ul></li><li>不一致：前後敘述邏輯不一致。</li><li>滑坡謬誤：在證據不足的前提下，預設某事件Ａ一定會造成某結果B。</li><li>混淆相關性與因果關係</li><li>稻草人論證：錯誤敘述對方論點，並對其進行攻擊。</li><li>含糊用語：使用一些模棱兩可且容易造成誤會的語言。<ul><li>ex:<code>大多數人認為</code>、<code>研究人員相信</code>…</li></ul></li><li>The pragmatic fallacy：某事為真，因為它有效。</li><li>排中律：非黑即白。<ul><li>ex:最近有研究顯示吃蔬菜對健康沒有顯著助益，所以明天開始我不吃蔬菜了。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 心理學 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 心理學 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-排序</title>
      <link href="/2024/09/03/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E6%8E%92%E5%BA%8F/"/>
      <url>/2024/09/03/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>Selection Sort</h1><h2 id="the-champion-problem">The Champion Problem</h2><p>給定一個陣列，求出陣列中最小數字的下標。<br>Input: an array A of n integers.<br>Output: an index k so that A[k] is the minimum value in A.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">champion</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &lt; s[ret]) ret = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort">Sort</h2><p>給定一個陣列，將其排序為遞增的陣列。<br>Input: an array A of n integers.<br>Output: the same array with the n integers ordered nondecrementally.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">selection_sort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">champion</span>(s+i, n-i);</span><br><span class="line">        <span class="type">int</span> swap = s[i];</span><br><span class="line">        s[i] = s[k];</span><br><span class="line">        s[k] = swap;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>champion</code> 找出剩餘陣列中最小數字的下標，將其放到對應的位置。</p><h1>Insertion Sort</h1><h2 id="insert-a-number-into-a-sorted-array">Insert a number into a sorted array</h2><p>將一個整數 <code>x</code> 插入一個已排序陣列 <code>A</code> 中，並且保持 <code>A</code> 是排序的狀態。<br>Input: a sorted array A of n integers and an integer x.<br>Output: a sorted array that comprises all elements in A and x.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n, <span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> placed = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>; i&gt;=<span class="number">0</span> &amp;&amp; !placed; --i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] &gt; x) s[i+<span class="number">1</span>] = s[i];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            s[i+<span class="number">1</span>] = x;</span><br><span class="line">            placed = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!placed) s[<span class="number">0</span>] = x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由後向前檢查合適的插入位置，如果到最後還沒有找到，則置於 <code>s[0]</code>。</p><h2 id="sort">Sort</h2><p>給定一個陣列，將其排序為遞增的陣列。<br>Input: an array A of n integers.<br>Output: the same array with the n integers ordered nondecrementally.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion_sort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="built_in">insert</span>(s, i, s[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由 <code>s[1]</code> 開始，依序將數字插入其前方已排序的陣列中。</p><h1>Merge Sort</h1><h2 id="merge-two-sorted-arrays">Merge two sorted arrays</h2><p>將兩個已排序的陣列 <code>A</code> 和 <code>B</code> 合併為一個排序的陣列。<br>Input: two sorted arrays A and B of integers.<br>Output: a sorted array that comprises all elements in A and B.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>* <span class="title">merge</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n, <span class="type">int</span> *r, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *ret = <span class="keyword">new</span> <span class="type">int</span> [n+m];</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( i &lt; n || j &lt; m )&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; n &amp;&amp; j &lt; m) ret[k++] = ((s[i] &lt; r[j]) ? s[i++] : r[j++]);</span><br><span class="line">        <span class="keyword">else</span> ret[k++] = ((i &lt; n) ? s[i++] : r[j++]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort">Sort</h2><p>給定一個陣列，將其排序為遞增的陣列。<br>Input: an array A of n integers.<br>Output: the same array with the n integers ordered nondecrementally.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> *s, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> k = n/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(s, k);</span><br><span class="line">    <span class="built_in">merge_sort</span>(s+k, n-k);</span><br><span class="line">    <span class="type">int</span> *r = <span class="built_in">merge</span>(s, k, s+k, n-k);</span><br><span class="line">    <span class="built_in">memcpy</span>(s, r, <span class="built_in">sizeof</span>(<span class="type">int</span>)*n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用遞迴的方式不斷將陣列分為兩部分進行排序，之後進行合併。</p><h1>2D Sorted Arrays - Young Tableau</h1><p>這裡要介紹的不是排序演算法，而是一個資料結構 <code>Young Tableau (楊表)</code>，<code>Young Tableau</code> 是一個 m * n 的矩陣，其特性是矩陣的每一行與列都是以遞增排序的 (由上而下、由左至右)，並且能在 <code>O(m + n)</code> 的時間複雜度下進行插入及查詢資料。</p><img src="/2024/09/03/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E6%8E%92%E5%BA%8F/Young-Tableau.png" class="" title="Young-Tableau"><h2 id="查詢">查詢</h2><p>由二維陣列的右上角開始進行比對，每次與目標數字 <code>x</code> 比較有三種結果：</p><ol><li>大於 <code>x</code>：將比對的格子向左移動，如果無法左移則結束。</li><li>等於 <code>x</code>：找到目標，結束。</li><li>小於 <code>x</code>：將比對的格子向下移動，如果無法下移則結束。</li></ol><h2 id="插入">插入</h2><p>將要插入的數字先放在二維陣列的右下角，檢查是否滿足 <code>Young Tableau</code>，如果不滿足則進行比較，每次比較其上方的數字 <code>T</code> 與左方的數字 <code>L</code>，如果該位置為空白則代表無限，比較有兩種結果：</p><ol><li><code>L &gt;= T</code>：將插入的數字與 <code>L</code> 交換。</li><li><code>L &lt; T</code>：將插入的數字與 <code>T</code> 交換。<br>當滿足 <code>Young Tableau</code> 或是數字到達頂端或最左方時結束。</li></ol><h1>Heap Sort</h1><h2 id="max-heapify">Max-Heapify</h2><p>調整指定的根結點與左右子結點，並且向下遞迴，使根結點為最大。<br>Max-Heapify(A, i)<br>convert the subtree rooted at node i into a max heap assuming that<br>(1) the subtree rooted at node Left(i) is a max heap, and<br>(2) the subtree rooted at node Right(i) is a max heap.</p><h2 id="build-max-heap">Build-Max-Heap</h2><p>使指定的子樹滿足 <code>Max Heap</code>。<br>Convert the subtree rooted at node i into a max heap without the<br>assumption that heapification uses.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Build-Max-<span class="built_in">Heap</span>(A, i)&#123;</span><br><span class="line">    Build-Max-<span class="built_in">Heap</span>(A, <span class="built_in">Left</span>(i));</span><br><span class="line">    Build-Max-<span class="built_in">Heap</span>(A, <span class="built_in">Right</span>(i));</span><br><span class="line">    Max-<span class="built_in">Heapify</span>(A, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="extract-max">Extract-Max</h2><p>取出 <code>Max Heap</code> 裡面的最大值。<br>Extract-Max(A, n)<br>Remove the maximum from an n-element array A and keep the rest of A<br>as a max heap.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Extract-<span class="built_in">Max</span>(A, <span class="type">int</span>&amp; n)&#123;</span><br><span class="line">    <span class="type">int</span> ret = A[<span class="number">1</span>]; A[<span class="number">1</span>] = -∞;</span><br><span class="line">    Max-<span class="built_in">Heapify</span>(A, <span class="number">1</span>);</span><br><span class="line">    n --;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sort">Sort</h2><p>給定一個陣列，將其排序為遞增的陣列。<br>Input: an array A of n integers.<br>Output: the same array with the n integers ordered nondecrementally.</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">HeapSort</span>(A, n)&#123;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>)&#123;</span><br><span class="line">        k = Extract-<span class="built_in">Max</span>(A, n);</span><br><span class="line">        A[n+<span class="number">1</span>] = k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不斷從 <code>Max Heap</code> 中取出最大值構成新的陣列。</p><h1>Quick Sort</h1><p>使用分治的方式進行排序，在陣列中選擇一個 <code>pivot</code>，並將陣列分成 <code>小於等於 pivot</code> 以及 <code>大於 pivot</code> 兩個部分，再以遞迴的方式接著處理兩個陣列，直到排序結束。</p><h2 id="sort">Sort</h2><p>使用了長度為 <code>n</code> 的額外空間。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> n, <span class="type">int</span> *buf)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> sfirst = <span class="number">0</span>, llast = n<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> pivot = A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] ≤ pivot) buf[sfirst++] = A[i];</span><br><span class="line">        <span class="keyword">else</span> buf[llast--] = A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(A, buf, <span class="built_in">sizeof</span>(A[<span class="number">0</span>])*n);</span><br><span class="line">    <span class="built_in">QuickSort</span>(A, sfirst, buf); <span class="built_in">QuickSort</span>(A+sfirst, n-sfirst, buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="in-place-sort">In-Place Sort</h2><p>不使用額外空間。</p><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">QuickSort</span><span class="params">(<span class="type">int</span> *A, <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> slast = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> pivot = A[n<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(A[i] ≤ pivot)&#123;</span><br><span class="line">            <span class="type">int</span> swap = A[i];</span><br><span class="line">            A[i] = A[slast];</span><br><span class="line">            A[slast++] = swap;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">QuickSort</span>(A, slast); <span class="built_in">QuickSort</span>(A+slast, n-slast);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Counting Sort</h1><p>根據資料的範圍，建立 <code>k</code> 個 <code>bucket</code> (通常是先進先出的容器)，遍歷整個陣列<br>並將各個元素分配到對應的 <code>bucket</code> 中，之後將各個 <code>bucket</code> 串起來就完成排序了，通常 <code>k</code> 的值不能太大。</p><h1>Radix Sort</h1><p>通常用於數字較大的排序 (可以比 <code>Counting Sort</code> 省空間) 或是將字串按照字典序進行排序，原理主要是利用 <code>Counting Sort</code> 對數字的各個位數 (或是字串的各個元素) 進行操作。</p><h2 id="base-10">base 10</h2><p>由最低位數 (最右邊的數字) 開始，對該位數進行 <code>Counting Sort</code>，形成新的陣列，接著對第二低的位數排序，如果元素的長度不夠可以補 0，重複直到所有元素的最高位數，最後型的的陣列就是已排序的結果。</p><h2 id="base-100-優化">base 100 (優化)</h2><p>與 <code>base 10</code> 的操作類似，不過一次是對兩個位數進行操作，每次建立 100 個 <code>bucket</code> 進行排序，可以減少操作的次數。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> 陣列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SD-AMD顯卡安裝</title>
      <link href="/2024/08/31/SD-AMD%E9%A1%AF%E5%8D%A1%E5%AE%89%E8%A3%9D/"/>
      <url>/2024/08/31/SD-AMD%E9%A1%AF%E5%8D%A1%E5%AE%89%E8%A3%9D/</url>
      
        <content type="html"><![CDATA[<div class="note info flat"><p>資料取自：<a href="https://github.com/CS1o/Stable-Diffusion-Info/wiki/Webui-Installation-Guides#amd-automatic1111-with-zluda">Stable-Diffusion-Info</a> by CS1o</p></div><h1>[AMD] Automatic1111 with ZLUDA</h1><ul><li>顯卡：AMD VEGA, Vii, APUs, RX5500XT, RX5600XT, 5700XT, RX 6600, 7700S 以及更高階顯卡。</li><li>驅動程式：24.1.1 及以上版本。</li></ul><h2 id="下載適用於-amd-顯卡的-autoamatic1111">下載適用於 AMD 顯卡的 Autoamatic1111</h2><ol><li>在目標資料夾內開啟終端機，輸入以下代碼</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/lshqqytiger/stable-diffusion-webui-amdgpu &amp;&amp; cd stable-diffusion-webui-amdgpu &amp;&amp; git submodule init &amp;&amp; git submodule update</span><br></pre></td></tr></table></figure><ol start="2"><li>在下載下來的資料夾內找到 <code>webui-user.bat</code> 右鍵以記事本打開，在 <code>COMMANDLINE_ARGS=</code> 後方加入 <code>--use-zluda --update-check --skip-ort</code>。</li><li>執行 <code>webui-user.bat</code> 檔案，在運行時可能發生錯誤，直接關閉進行後續步驟。</li></ol><h2 id="zluda-設定">Zluda 設定</h2><h3 id="rx6800-及以上顯卡">RX6800 及以上顯卡</h3><ol><li>下載並安裝 <a href="https://www.amd.com/en/developer/resources/rocm-hub/hip-sdk.html">AMD HIP SDK 6.1.2</a>。</li><li>下載最新版本的 <a href="https://github.com/lshqqytiger/ZLUDA/releases/">ZLUDA</a>，解壓縮之後將資料夾重新命名為 <code>ZLUDA</code> 並將其置於 <code>C 槽</code>內。</li><li>把 <code>C:\ZLUDA</code> 以及 <code>%HIP_PATH%bin</code> 加入 <code>環境變數 &gt; 系統變數 &gt; Path</code> 中。</li><li>執行 <code>webui-user.bat</code>，第一次產生圖像可能需要 15 至 40 分鐘載入。</li></ol><h3 id="rx6800-以下顯卡">RX6800 以下顯卡</h3><ol><li><p>下載並安裝 <a href="https://www.amd.com/en/developer/resources/rocm-hub/hip-sdk.html">AMD HIP SDK 5.7.1</a>。</p></li><li><p>下載相容版本的 <a href="https://github.com/lshqqytiger/ZLUDA/releases/download/rel.11cc5844514f93161e0e74387f04e2c537705a82/ZLUDA-windows-amd64.zip">ZLUDA</a>，解壓縮之後將資料夾重新命名為 <code>ZLUDA</code> 並將其置於 <code>C 槽</code>內。</p></li><li><p>根據顯卡下載相應的檔案</p><ul><li>RX 6700 or 6700XT: <a href="https://github.com/brknsoul/ROCmLibs/blob/main/Optimised_ROCmLibs_gfx1031.7z?download=">Optimised_ROCmLibs_gfx1031.7z</a></li><li>RX 6600 or 6600XT: <a href="https://github.com/brknsoul/ROCmLibs/raw/main/Optimised_ROCmLibs_gfx1032.7z?download=">Optimised_ROCmLibs_gfx1032.7z</a></li><li>RX 580, 5600/XT, 5700/XT, VEGA 56, VEGA 64 and Radeon VII or RX7700S: <a href="https://github.com/brknsoul/ROCmLibs/raw/main/ROCmLibs.7z">ROCmLibs.7z</a></li></ul><p>如果使用 <code>AMD 780M-APU</code> 可以參考 <a href="https://github.com/likelovewant/ROCmLibs-for-gfx1103-AMD780M-APU-">https://github.com/likelovewant/ROCmLibs-for-gfx1103-AMD780M-APU-</a></p></li><li><p>在 <code>C:\Program Files\AMD\ROCm\5.7\bin\rocblas</code> 中複製 <code>library</code> 資料夾並重新命名為 <code>old_library</code>，把剛剛下載下來的檔案解壓縮後放入<code>library</code> 資料夾，之後將電腦重新開機。</p></li><li><p>把 <code>C:\ZLUDA</code> 以及 <code>%HIP_PATH%bin</code> 加入 <code>環境變數 &gt; 系統變數 &gt; Path</code> 中。</p></li><li><p>執行 <code>webui-user.bat</code>，第一次產生圖像可能需要 15 至 40 分鐘載入。</p></li></ol><div class="note simple"><p>RX580 顯卡需要進行額外步驟：<br>在 <code>stable-diffusion-webui-amdgpu</code> 中打開終端機，輸入以下三行代碼：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">venv\scripts\activate</span><br><span class="line">pip uninstall torch torchvision torchaudio -y</span><br><span class="line">pip install torch==2.2.1 torchvision==0.17.1 torchaudio==2.2.1 --index-url https://download.pytorch.org/whl/cu118</span><br></pre></td></tr></table></figure></div>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 雜七雜八 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Tree-2</title>
      <link href="/2024/08/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-2/"/>
      <url>/2024/08/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-2/</url>
      
        <content type="html"><![CDATA[<h1>Binary Search Tree</h1><p>二元搜尋樹有以下特性：</p><ul><li>一個節點的左子樹只包含鍵值小於該節點的節點。</li><li>一個節點的右子樹只包含鍵值大於該節點的節點。</li><li>左子樹和右子樹也都是二分搜尋樹。<br>而且以中序遍歷二元搜尋樹會得到一個遞增的數列。</li></ul><h2 id="操作">操作</h2><h3 id="搜索">搜索</h3><p>根據待查元素<code>val</code> 與當前 <code>root -&gt; val</code> 的關係判斷：</p><ul><li><code>root -&gt; val == val</code> 回傳當前 <code>root</code>。</li><li><code>root -&gt; val &gt; val</code> 查找左子樹。</li><li><code>root -&gt; val &lt; val</code> 查找右子樹。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">searchBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val == val) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &gt; val) <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; left, val);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">searchBST</span>(root -&gt; right, val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入">插入</h2><p>根據待查元素<code>val</code> 與當前 <code>root -&gt; val</code> 的關係判斷：</p><ul><li><code>root == nullptr</code> 插入新節點。</li><li><code>root -&gt; val &gt; val</code> 重新構造左子樹。</li><li><code>root -&gt; val &lt; val</code> 重新構造右子樹。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &gt; val) root -&gt; left = <span class="built_in">insertIntoBST</span>(root -&gt; left, val);</span><br><span class="line">    <span class="keyword">else</span> root -&gt; right = <span class="built_in">insertIntoBST</span>(root -&gt; right, val);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="刪除">刪除</h2><p>先用遞迴的方式找到要刪除的節點，並根據其左右子樹的情況做處理：</p><ul><li>左右子樹皆為空：直接刪除節點，回傳 <code>nullptr</code>。</li><li>左子樹為空：以右子樹取代該節點，回傳 <code>root -&gt; right</code>。</li><li>右子樹為空：以左子樹取代該節點，回傳 <code>root -&gt; left</code>。</li><li>左右子樹皆不為空：把左子樹插入<code>右子樹最小的節點的左邊</code>，以右子樹取代該節點，回傳 <code>root -&gt; right</code>。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">deleteNode</span><span class="params">(TreeNode* root, <span class="type">int</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(root -&gt; val &gt; key) root -&gt; left = <span class="built_in">deleteNode</span>(root -&gt; left, key);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; val &lt; key) root -&gt; right = <span class="built_in">deleteNode</span>(root -&gt; right, key);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root -&gt; right == <span class="literal">nullptr</span>) <span class="keyword">return</span> root -&gt; left;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode* tmp = root -&gt; right;</span><br><span class="line">            <span class="keyword">while</span>(tmp -&gt; left != <span class="literal">nullptr</span>) tmp = tmp -&gt; left;</span><br><span class="line">            tmp -&gt; left = root -&gt; left;</span><br><span class="line">            <span class="keyword">return</span> root -&gt; right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="還原">還原</h2><h3 id="前序">前序</h3><p>因為二元搜尋樹的特性，在區分左、右子樹時不需要利用到中序遍歷，只要在前序遍歷中找到鍵值大於根結點的地方就是右子樹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt; preorder, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> preord_root = left;</span><br><span class="line">    <span class="type">int</span> size_left_subtree = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到右子樹在前序遍歷中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left+<span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(preorder[i] &gt; preorder[preord_root]) <span class="keyword">break</span>;</span><br><span class="line">        size_left_subtree++;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[preord_root], <span class="built_in">buildTree</span>(preorder, left + <span class="number">1</span>, left + size_left_subtree), <span class="built_in">buildTree</span>(preorder, left + size_left_subtree + <span class="number">1</span>, right));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="後序">後序</h3><p>和前序遍歷類似，只是根節點的位置要從最後面找。</p><h3 id="中序">中序</h3><p>因為無法確定根結點所在的位置 (一定為遞增數列)，因此無法構造出唯一的樹。</p><h1>Segment Tree</h1><p>線段樹是二元平衡樹的一種，用以儲存區間或線段，每個節點代表一個區間，而根結點代表區間的全部範圍，葉節點代表長度為 1 的區間，而編號方式以及代表的區間規則如下：</p><ul><li>根結點編號為 0，並且代表整個區間的範圍。</li><li>假設當前節點編號為 <code>i</code>，代表的區間為 <code>[left, right]</code>，假設 <code>mid = (left + right) / 2</code> 則：<ul><li>左節點編號為 <code>i * 2</code>，代表的區間為 <code>[left, mid]</code>。</li><li>右節點編號為 <code>i * 2 + 1</code>，代表的區間為 <code>[mid + 1, right]</code>。</li></ul></li></ul><h2 id="構造">構造</h2><p>假設有一數組 <code>v</code>，要建構一個線段樹來<code>儲存每個區間的數字和</code>，我們利用 <code>tree</code> 來儲存該線段樹的資料，建構的方式是使用遞迴不斷建立左右子節點，直到長度為 1 的葉節點。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right) tree[node] = v[left];</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">build</span>(node * <span class="number">2</span>, left, mid);</span><br><span class="line">        <span class="built_in">build</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="comment">// 下面這一行可以替換為其他規則，建立不同的線段樹</span></span><br><span class="line">        tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="查詢">查詢</h2><p>查詢的過程依舊是由上而下進行遞迴，根據查詢的區間 <code>[q_left, q_right]</code> 以及結點所儲存的資料區間 <code>[left, mid]</code>，來決定回傳的結果，可以分為三種情況：</p><ul><li><code>查詢區間</code>和<code>節點區間</code>沒有交集，則回傳 <code>0</code>。</li><li><code>查詢區間</code>包含<code>節點區間</code>，則回傳節點的值。</li><li><code>查詢區間</code>與<code>節點區間</code>有部分交集，則分別對左右子樹進行查詢，接著將結果進行聚合 (聚合的方式視線段樹的規則而訂)。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> q_left, <span class="type">int</span> q_right)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(q_right &lt; left || q_left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(q_left &lt;= left &amp;&amp; q_right &gt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line">    <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">int</span> res_left = <span class="built_in">query</span>(node * <span class="number">2</span>, left, mid, q_left, q_right);</span><br><span class="line">    <span class="type">int</span> res_right = <span class="built_in">query</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right, q_left, q_right)</span><br><span class="line">    <span class="comment">// 下面這一行可以替換為其他規則，建立不同的線段樹</span></span><br><span class="line">    <span class="keyword">return</span> res_left + res_right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="更新">更新</h2><p>由上而下遞迴進行更新，不斷更新節點儲存的值，並且對子樹也進行更新，直到目標節點時才停止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> index, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">        tree[node] = val;</span><br><span class="line">        v[left] = val;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(index &lt;= mid) <span class="built_in">update</span>(node * <span class="number">2</span>, left, mid, index, val);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">update</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right, index, val);</span><br><span class="line">        <span class="comment">// 下面這一行可以替換為其他規則，建立不同的線段樹</span></span><br><span class="line">        tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>Disjoint set &amp; Union-find algorithm</h1><p>並查集是一種資料結構，用於處理一些不交集的合併及查詢問題，而使用的 <code>Union-find algorithm</code> 主要包含了以下功能：</p><ul><li>查找 (Find)：查詢元素屬於哪個集合。</li><li>合併 (Union)：將兩個集合合併為一個。<br>使用樹的概念儲存每個集合，樹的根結點就用來代表該集合，而所有樹所形成的森林則是所有的元素。</li></ul><h2 id="查找">查找</h2><p>因為樹的根結點代表該集合，因此在查找的時候只要不斷往回推，直到該節點指向自己 (根節點) 就好。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Find</span>(p[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="合併">合併</h2><p>合併兩個集合其實就是把兩棵樹接起來，首先要先判斷各自的根結點，如果根結點相同則代表是相同集合，否則則要進行合併，將一個集合的根結點指向另一個集合的根結點即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> f1 = <span class="built_in">Find</span>(a);</span><br><span class="line">    <span class="type">int</span> f2 = <span class="built_in">Find</span>(b);</span><br><span class="line">    <span class="keyword">if</span>(f1 != f2) p[f2] = f1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="優化">優化</h2><h3 id="路徑壓縮">路徑壓縮</h3><p>經過路徑壓縮後，可以減少回推根結點時的迭代次數，增加效率，通常在查詢時順便進行壓縮。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> p[x] = <span class="built_in">Find</span>(p[x]); <span class="comment">//把元素指向根結點</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="按秩合併">按秩合併</h3><p>每次進行合併時，把<code>秩</code>比較小的樹根結點指向<code>秩</code>較大的樹根結點，<code>秩</code>主要有兩種定義方式，分別是樹的<code>深度</code>以及<code>元素個數</code>。</p><h1>練習</h1><h2 id="leetcode-110-balanced-binary-tree"><a href="https://leetcode.com/problems/balanced-binary-tree/description/">LeetCode 110. Balanced Binary Tree</a></h2><p>Given a binary tree, determine if it is height-balanced.</p><p>Example 1:</p><img src="/2024/08/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-2/ex-1-1.jpg" class="" title="ex-1"><p>Input: root = [3,9,20,null,null,15,7]<br>Output: true</p><p>Example 2:</p><img src="/2024/08/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-2/ex-1-2.jpg" class="" title="ex-2"><p>Input: root = [1,2,2,3,3,null,null,4,4]<br>Output: false</p><p>Example 3:<br>Input: root = []<br>Output: true</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">treeHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> l = <span class="built_in">treeHeight</span>(root -&gt; left), r = <span class="built_in">treeHeight</span>(root -&gt; right);</span><br><span class="line">        <span class="keyword">if</span>(l == <span class="number">-1</span> || r == <span class="number">-1</span> || <span class="built_in">abs</span>(l - r) &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(l, r) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeHeight</span>(root) != <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立一個 <code>treeHeight</code> 函數，在所在子樹為平衡二元樹時回傳其高度，否則回傳 <code>-1</code>，因此最終只要傳入根結點並判斷其回傳值是否為 <code>-1</code> 就好。</p><h2 id="leetcode-307-range-sum-query-mutable"><a href="https://leetcode.com/problems/range-sum-query-mutable/description/">LeetCode 307. Range Sum Query - Mutable</a></h2><p>Given an integer array <code>nums</code>, handle multiple queries of the following types:</p><ol><li>Update the value of an element in <code>nums</code>.</li><li>Calculate the sum of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> inclusive where <code>left &lt;= righ</code>t.</li></ol><p>Implement the <code>NumArray</code> class:</p><ul><li><code>NumArray(int[] nums)</code> Initializes the object with the integer array <code>nums</code>.</li><li><code>void update(int index, int val)</code> Updates the value of <code>nums[index]</code> to be <code>val</code>.</li><li><code>int sumRange(int left, int right)</code> Returns the sum of the elements of <code>nums</code> between indices <code>left</code> and <code>right</code> inclusive (i.e. <code>nums[left] + nums[left + 1] + ... + nums[right]</code>).</li></ul><p>Example 1:<br>Input<br>[“NumArray”, “sumRange”, “update”, “sumRange”]<br>[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]<br>Output<br>[null, 9, null, 8]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tree;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right) tree[node] = v[left];</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">build</span>(node * <span class="number">2</span>, left, mid);</span><br><span class="line">            <span class="built_in">build</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> q_left, <span class="type">int</span> q_right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(q_right &lt; left || q_left &gt; right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(q_left &lt;= left &amp;&amp; q_right &gt;= right) <span class="keyword">return</span> tree[node];</span><br><span class="line">        <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(node * <span class="number">2</span>, left, mid, q_left, q_right) + <span class="built_in">query</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right, q_left, q_right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">updateN</span><span class="params">(<span class="type">int</span> node, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> index, <span class="type">int</span> val)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(left == right)&#123;</span><br><span class="line">            tree[node] = val;</span><br><span class="line">            v[left] = val;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(index &lt;= mid) <span class="built_in">updateN</span>(node * <span class="number">2</span>, left, mid, index, val);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">updateN</span>(node * <span class="number">2</span> + <span class="number">1</span>, mid + <span class="number">1</span>, right, index, val);</span><br><span class="line">            tree[node] = tree[node * <span class="number">2</span>] + tree[node * <span class="number">2</span> + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">NumArray</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">       v = nums;</span><br><span class="line">       tree.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() * <span class="number">4</span>);</span><br><span class="line">       <span class="keyword">if</span>(!nums.<span class="built_in">empty</span>()) <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!v.<span class="built_in">empty</span>()) <span class="built_in">updateN</span>(<span class="number">1</span>, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>, index, val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (v.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">query</span>(<span class="number">1</span>, <span class="number">0</span>, v.<span class="built_in">size</span>() - <span class="number">1</span>, left, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用線段樹的方式儲存各區間的數字和，使用構造、查詢、更新三個函數。</p><h2 id="leetcode-399-evaluate-division"><a href="https://leetcode.com/problems/evaluate-division/description/">LeetCode 399. Evaluate Division</a></h2><p>You are given an array of variable pairs <code>equations</code> and an array of real numbers <code>values</code>, where <code>equations[i] = [Ai, Bi]</code> and <code>values[i]</code> represent the equation <code>Ai / Bi = values[i]</code>. Each Ai or Bi is a string that represents a single variable.</p><p>You are also given some <code>queries</code>, where <code>queries[j] = [Cj, Dj]</code> represents the j<sup>th</sup> query where you must find the answer for <code>Cj / Dj = ?</code>.</p><p>Return the answers to all queries. If a single answer cannot be determined, return <code>-1.0</code>.</p><p>Note: The input is always valid. You may assume that evaluating the queries will not result in division by zero and that there is no contradiction.</p><p>Note: The variables that do not occur in the list of equations are undefined, so the answer cannot be determined for them.</p><p>Example 1:<br>Input: equations = [[“a”,“b”],[“b”,“c”]], values = [2.0,3.0], queries = [[“a”,“c”],[“b”,“a”],[“a”,“e”],[“a”,“a”],[“x”,“x”]]<br>Output: [6.00000,0.50000,-1.00000,1.00000,-1.00000]</p><p>Example 2:<br>Input: equations = [[“a”,“b”],[“b”,“c”],[“bc”,“cd”]], values = [1.5,2.5,5.0], queries = [[“a”,“c”],[“c”,“b”],[“bc”,“cd”],[“cd”,“bc”]]<br>Output: [3.75000,0.40000,5.00000,0.20000]</p><p>Example 3:<br>Input: equations = [[“a”,“b”]], values = [0.5], queries = [[“a”,“b”],[“b”,“a”],[“a”,“c”],[“x”,“y”]]<br>Output: [0.50000,2.00000,-1.00000,-1.00000]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string, string&gt; p;</span><br><span class="line">    unordered_map&lt;string, <span class="type">double</span>&gt; t;</span><br><span class="line">    <span class="function">string <span class="title">Find</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(s != p[s]) s = p[s];</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">FindTimes</span><span class="params">(string s)</span></span>&#123;</span><br><span class="line">        <span class="type">double</span> ti = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(s != p[s])&#123;</span><br><span class="line">            ti *= t[s];</span><br><span class="line">            s = p[s];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ti;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(string x, string y, <span class="type">double</span> ti)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!p.<span class="built_in">count</span>(x))&#123;</span><br><span class="line">            p[x] = x;</span><br><span class="line">            t[x] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!p.<span class="built_in">count</span>(y))&#123;</span><br><span class="line">            p[y] = y;</span><br><span class="line">            t[y] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string f1 = <span class="built_in">Find</span>(x), f2 = <span class="built_in">Find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2) <span class="keyword">return</span>;</span><br><span class="line">        t[f2] = ti * <span class="built_in">FindTimes</span>(x) / <span class="built_in">FindTimes</span>(y);</span><br><span class="line">        p[f2] = f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">calcEquation</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; equations, vector&lt;<span class="type">double</span>&gt;&amp; values, vector&lt;vector&lt;string&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">double</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; equations.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="built_in">Union</span>(equations[i][<span class="number">0</span>], equations[i][<span class="number">1</span>], values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; queries.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(p.<span class="built_in">count</span>(queries[i][<span class="number">0</span>]) == <span class="number">0</span> || p.<span class="built_in">count</span>(queries[i][<span class="number">1</span>]) == <span class="number">0</span>) ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">Find</span>(queries[i][<span class="number">0</span>]) != <span class="built_in">Find</span>(queries[i][<span class="number">1</span>])) ans.<span class="built_in">push_back</span>(<span class="number">-1</span>);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(<span class="built_in">FindTimes</span>(queries[i][<span class="number">1</span>]) / <span class="built_in">FindTimes</span>(queries[i][<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用並查集以及一個 <code>unordered map</code> 來儲存變數之間的關係以及倍數，<code>FindTimes</code> 函數則是往回推算該變數與其根結點變數之間的倍數關係，在進行查詢時，可以分為幾種情況：</p><ul><li>查詢變數不在並查集中：回傳 <code>-1</code>。</li><li>查詢變數不在相同的樹中 (根結點相異)：回傳 <code>-1</code>。</li><li>查詢變數在相同的樹中 (根結點相同)：回傳兩變數分別與根節點的倍數關係相除 <code>FindTimes(queries[i][1]) / FindTimes(queries[i][0])</code>。</li></ul><h2 id="leetcode-765-couples-holding-hands"><a href="https://leetcode.com/problems/couples-holding-hands/description/">LeetCode 765. Couples Holding Hands</a></h2><p>There are <code>n</code> couples sitting in <code>2n</code> seats arranged in a row and want to hold hands.</p><p>The people and seats are represented by an integer array <code>row</code> where <code>row[i]</code> is the ID of the person sitting in the i<sup>th</sup> seat. The couples are numbered in order, the first couple being <code>(0, 1)</code>, the second couple being <code>(2, 3)</code>, and so on with the last couple being <code>(2n - 2, 2n - 1)</code>.</p><p>Return the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.</p><p>Example 1:<br>Input: row = [0,2,1,3]<br>Output: 1</p><p>Example 2:<br>Input: row = [3,2,0,1]<br>Output: 0</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(v[x] == x) <span class="keyword">return</span> x;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Find</span>(v[x]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> f1 = <span class="built_in">Find</span>(x), f2 = <span class="built_in">Find</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(f1 == f2) <span class="keyword">return</span>;</span><br><span class="line">        v[f2] = f1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSwapsCouples</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>() / <span class="number">2</span>; i++)&#123;</span><br><span class="line">            v.<span class="built_in">push_back</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; row.<span class="built_in">size</span>(); i += <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="built_in">Union</span>(row[i] / <span class="number">2</span>, row[i + <span class="number">1</span>] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            v[i] = <span class="built_in">Find</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(v.begin(), v.end())</span></span>;</span><br><span class="line">        <span class="keyword">return</span> v.<span class="built_in">size</span>() - s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><a href="https://algo.itcharge.cn/Solutions/0700-0799/couples-holding-hands/">題解</a></p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> 資料結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Tree-1</title>
      <link href="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/"/>
      <url>/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/</url>
      
        <content type="html"><![CDATA[<h1>Tree</h1><p>由 n 個有限節點組成一個具有層次關係的集合，形狀類似一顆倒著的樹，具有以下幾個特點：</p><ul><li>沒有環 (cycle)。</li><li>所有點之間連通，且只有唯一路徑。</li><li>邊數 = 點數 - 1。</li></ul><h1>Binary Tree</h1><p>每個節點的度數不大於 2 的樹，左右的分支分別稱為 <code>左子樹</code>與<code>右子樹</code>，並且左右子樹有次序關係，不能隨意交換。</p><h2 id="遍歷">遍歷</h2><ul><li>前序遍歷 (根結點 -&gt; 左子樹 -&gt; 右子樹)</li><li>中序遍歷 (左子樹 -&gt; 根結點 -&gt; 右子樹)</li><li>後序遍歷 (左子樹 -&gt; 右子樹 -&gt; 根結點)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//對根節點的操作 - 前序</span></span><br><span class="line">    <span class="built_in">treeTraversal</span>(root -&gt; left);</span><br><span class="line">    <span class="comment">//對根節點的操作 - 中序</span></span><br><span class="line">    <span class="built_in">treeTraversal</span>(root -&gt; right);</span><br><span class="line">    <span class="comment">//對根節點的操作 - 後序</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>層序遍歷<br>紀錄 <code>queue</code> 的大小，每次處理一整層的元素。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">levelOrder</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        <span class="type">int</span> n;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            n = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">                <span class="comment">//對節點的操作</span></span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">front</span>() -&gt; left != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>() -&gt; left);</span><br><span class="line">                <span class="keyword">if</span>(q.<span class="built_in">front</span>() -&gt; right != <span class="literal">nullptr</span>) q.<span class="built_in">push</span>(q.<span class="built_in">front</span>() -&gt; right);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="還原">還原</h2><p>透過二叉樹的遍歷結果回推原始二叉樹的結構。</p><h3 id="前序-中序">前序 + 中序</h3><p>前序遍歷的順序為 [根結點、左子樹、右子樹]，而中序遍歷的順序為 [左子樹、根結點、右子樹]，因此我們可以透過前序遍歷的第一個元素找到根結點，將其帶入中序遍歷，就可以找到左、右子樹，對左、右子樹遞迴進行此行為就可以構造出原始樹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; inorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), preorder[<span class="number">0</span>]) - inorder.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre_left</span><span class="params">(preorder.begin() + <span class="number">1</span>, preorder.begin() + <span class="number">1</span> + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre_right</span><span class="params">(preorder.begin() + <span class="number">1</span> + len, preorder.end())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in_left</span><span class="params">(inorder.begin(), inorder.begin() + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in_right</span><span class="params">(inorder.begin() + <span class="number">1</span> + len, inorder.end())</span></span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>], <span class="built_in">buildTree</span>(pre_left, in_left), <span class="built_in">buildTree</span>(pre_right, in_right));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="後序-中序">後序 + 中序</h3><p>與<code>前序 + 中序</code>類似，因此我們可以透過後序遍歷的最後一個元素找到根結點，將其帶入中序遍歷，就可以找到左、右子樹，對左、右子樹遞迴進行此行為就可以構造出原始樹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">buildTree</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; inorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(inorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">find</span>(inorder.<span class="built_in">begin</span>(), inorder.<span class="built_in">end</span>(), postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>]) - inorder.<span class="built_in">begin</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post_left</span><span class="params">(postorder.begin(), postorder.begin() + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post_right</span><span class="params">(postorder.begin() + len, postorder.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in_left</span><span class="params">(inorder.begin(), inorder.begin() + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">in_right</span><span class="params">(inorder.begin() + <span class="number">1</span> + len, inorder.end())</span></span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>], <span class="built_in">buildTree</span>(in_left, post_left), <span class="built_in">buildTree</span>(in_right, post_right));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前序-後序">前序 + 後序</h3><p>因為無法確定左右子樹的區分，因此構造出的樹不唯一，這邊假設前序遍歷的第二個元素 <code>preorder[1]</code> 是左子樹的根結點，可以構造出其中一種樹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructFromPrePost</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; preorder, vector&lt;<span class="type">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(preorder.<span class="built_in">size</span>() == <span class="number">1</span>)&#123;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">find</span>(postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>(), preorder[<span class="number">1</span>]) - postorder.<span class="built_in">begin</span>() + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre_left</span><span class="params">(preorder.begin() + <span class="number">1</span>, preorder.begin() + <span class="number">1</span> + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pre_right</span><span class="params">(preorder.begin() + <span class="number">1</span> + len, preorder.end())</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post_left</span><span class="params">(postorder.begin(), postorder.begin() + len)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">post_right</span><span class="params">(postorder.begin() + len, postorder.end() - <span class="number">1</span>)</span></span>;</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preorder[<span class="number">0</span>], <span class="built_in">constructFromPrePost</span>(pre_left, post_left), <span class="built_in">constructFromPrePost</span>(pre_right, post_right));</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>練習</h1><h2 id="leetcode-112-path-sum"><a href="https://leetcode.com/problems/path-sum/description/">LeetCode 112. Path Sum</a></h2><p>Given the root of a binary tree and an integer <code>targetSum</code>, return <code>true</code> if the tree has a root-to-leaf path such that adding up all the values along the path equals <code>targetSum</code>.</p><p>A leaf is a node with no children.</p><p>Example 1:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-1-1.jpg" class="" title="ex-1"><p>Input: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22<br>Output: true</p><p>Example 2:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-1-2.jpg" class="" title="ex-2"><p>Input: root = [1,2,3], targetSum = 5<br>Output: false</p><p>Example 3:<br>Input: root = [], targetSum = 0<br>Output: false</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(root -&gt; left == <span class="literal">nullptr</span> &amp;&amp; root -&gt; right == <span class="literal">nullptr</span> &amp;&amp; t - root -&gt; val == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root -&gt; left, t - root -&gt; val) || <span class="built_in">hasPathSum</span>(root -&gt; right, t - root -&gt; val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果當前節點為葉節點且離 <code>targetSum</code> 的差距為 0，代表滿足目標，否則將 <code>targetSum - root -&gt; val</code> 作為參數傳入左右節點，並遞迴判斷是否成立。</p><h2 id="leetcode-236-lowest-common-ancestor-of-a-binary-tree"><a href="https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/description/">LeetCode 236. Lowest Common Ancestor of a Binary Tree</a></h2><p>Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.</p><p>According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in <code>T</code> that has both <code>p</code> and <code>q</code> as descendants (where we allow a node to be a descendant of itself).”</p><p>Example 1:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-2-1.jpg" class="" title="ex-1"><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1<br>Output: 3</p><p>Example 2:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-2-2.jpg" class="" title="ex-2"><p>Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4<br>Output: 5</p><p>Example 3:<br>Input: root = [1,2], p = 1, q = 2<br>Output: 1</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">nullptr</span>)&#123;</span><br><span class="line">            TreeNode* l = <span class="built_in">lowestCommonAncestor</span>(root -&gt; left, p, q);</span><br><span class="line">            TreeNode* r = <span class="built_in">lowestCommonAncestor</span>(root -&gt; right, p, q);</span><br><span class="line">            <span class="keyword">if</span>(l != <span class="literal">nullptr</span> &amp;&amp; r != <span class="literal">nullptr</span>) <span class="keyword">return</span> root;</span><br><span class="line">            <span class="keyword">if</span>(l == <span class="literal">nullptr</span>) <span class="keyword">return</span> r;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果函數回傳的值為<code>nullptr</code> 代表 <code>p,q</code> 都不在這個子樹中，因此根據左右子樹帶入函數的值，可以區分為以下幾種情形：</p><ul><li><code>l != nullptr &amp;&amp; r != nullptr</code> 代表 <code>p,q</code> 分別位於左右子樹，則該節點為最低共同祖先。</li><li><code>l == nullptr &amp;&amp; r != nullptr</code> 代表 <code>p,q</code> 都位於右子樹。</li><li><code>l != nullptr &amp;&amp; r !== nullptr</code> 代表 <code>p,q</code> 都位於左子樹。</li><li><code>l != nullptr &amp;&amp; r != nullptr</code> 代表 <code>p,q</code> 不在這個子樹中。</li></ul><h2 id="leetcode-124-binary-tree-maximum-path-sum"><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/description/">LeetCode 124. Binary Tree Maximum Path Sum</a></h2><p>A path in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence at most once. Note that the path does not need to pass through the root.</p><p>The path sum of a path is the sum of the node’s values in the path.</p><p>Given the <code>root</code> of a binary tree, return the maximum path sum of any non-empty path.</p><p>Example 1:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-3-1.jpg" class="" title="ex-1"><p>Input: root = [1,2,3]<br>Output: 6</p><p>Example 2:</p><img src="/2024/08/08/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Tree-1/ex-1-3-2.jpg" class="" title="ex-2"><p>Input: root = [-10,9,20,null,null,15,7]<br>Output: 42</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">pathSum</span>(root -&gt; left));</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">pathSum</span>(root -&gt; right));</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, left + right + root -&gt; val);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(left, right) + root -&gt; val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pathSum</span>(root);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>pathSum</code> 函數代表<code>以此節點為根的最大貢獻路徑長</code>，每次遞迴包含以下過程：</p><ul><li>如果此點為空節點，返回 0。</li><li>計算 <code>left</code> 為左子樹貢獻的最大長度，如果值為負數則直接捨棄 (路徑不包含左子樹)。</li><li>計算 <code>right</code> 為右子樹貢獻的最大長度，如果值為負數則直接捨棄 (路徑不包含右子樹)。</li><li><code>以此節點為根的最大路徑和</code>為 <code>left + right + root -&gt; val</code>，並且與當前最大值比較。</li><li>回傳<code>以此節點為根的最大貢獻路徑長</code>，值為 <code>max(left, right) + root -&gt; val</code>。</li></ul><h2 id="leetcode-297-serialize-and-deserialize-binary-tree"><a href="https://leetcode.com/problems/serialize-and-deserialize-binary-tree/description/">LeetCode 297. Serialize and Deserialize Binary Tree</a></h2><p>Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.</p><p>Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.</p><p>Clarification: The input/output format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.</p><p>Example 1:</p><p>Input: root = [1,2,3,null,null,4,5]<br>Output: [1,2,3,null,null,4,5]</p><p>Example 2:<br>Input: root = []<br>Output: []</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(root -&gt; val) + <span class="string">&quot; &quot;</span> + <span class="built_in">serialize</span>(root -&gt; left) + <span class="string">&quot; &quot;</span> + <span class="built_in">serialize</span>(root -&gt; right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">dfs</span><span class="params">(queue&lt;string&gt;* q)</span></span>&#123;</span><br><span class="line">        string s = (*q).<span class="built_in">front</span>();</span><br><span class="line">        (*q).<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(s == <span class="string">&quot;null&quot;</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">        root -&gt; left = <span class="built_in">dfs</span>(q);</span><br><span class="line">        root -&gt; right = <span class="built_in">dfs</span>(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="function">stringstream <span class="title">ss</span><span class="params">(data)</span></span>;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="keyword">while</span>(ss &gt;&gt; tmp) q.<span class="built_in">push</span>(tmp);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dfs</span>(&amp;q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>編碼<br>使用前序遍歷，將二叉樹的值儲存為字串，如果遇到空節點，則加入 <code>&quot;null&quot;</code>。</p></li><li><p>解碼<br>使用<code>queue</code> 儲存每個字串，並且利用 <code>dfs</code> 將值依序填入根結點、左子樹、右子樹中。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tree </tag>
            
            <tag> 資料結構 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-String</title>
      <link href="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/"/>
      <url>/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/</url>
      
        <content type="html"><![CDATA[<h1>String</h1><p>用於儲存字串的資料類型，內部為一個個的字元構成，可以進行很多類似陣列的操作，有以下幾個常見的操作：</p><ul><li>size 回傳字串長度</li><li>[] 存取對應下標的字元</li><li>find 回傳指定字元的位置</li><li>substr 取出指定的子字串</li><li>reverse 反轉指定的字串</li></ul><h1>Stringstream</h1><p>經常在操作字串時會使用到的類別，常用於<code>類型轉換</code>或是<code>分割字串</code>。</p><h2 id="型態轉換">型態轉換</h2><h3 id="使用-stringstream">使用 stringstream</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; str</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line">string s;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; i;</span><br><span class="line">ss &gt;&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//str -&gt; int</span></span><br><span class="line">string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">stringstream ss;</span><br><span class="line">ss &lt;&lt; s;</span><br><span class="line">ss &gt;&gt; i;</span><br></pre></td></tr></table></figure><h3 id="使用函數">使用函數</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//int -&gt; str</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">123</span>;</span><br><span class="line">string s;</span><br><span class="line">s = <span class="built_in">to_string</span>(i);</span><br><span class="line"></span><br><span class="line"><span class="comment">//str -&gt; int</span></span><br><span class="line">string s = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">i = <span class="built_in">stoi</span>(s);</span><br></pre></td></tr></table></figure><h2 id="分割字串">分割字串</h2><h3 id="空白分割">空白分割</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;Welcome to my blog&quot;</span>, tmp;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; tmp)&#123;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Welcome</span></span><br><span class="line"><span class="comment">to</span></span><br><span class="line"><span class="comment">my</span></span><br><span class="line"><span class="comment">blog</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="其他分割符">其他分割符</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;discuss.leetcode.com&quot;</span>, tmp;</span><br><span class="line"><span class="function">stringstream <span class="title">ss</span><span class="params">(str)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (std::<span class="built_in">getline</span>(ss, tmp, <span class="string">&#x27;.&#x27;</span>)) &#123;</span><br><span class="line">    cout &lt;&lt; tmp &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">discuss</span></span><br><span class="line"><span class="comment">leetcode</span></span><br><span class="line"><span class="comment">com</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1>字串匹配問題</h1><p>給定一個主串 <code>T</code> 以及子串 <code>p</code>，在主串中尋找子串是否存在，以及其所在的位置。</p><h2 id="樸素演算法">樸素演算法</h2><p>最容易想到的演算法，不需要進行預處理，從 <code>T[0]</code> 以及 <code>p[0]</code> 開始比較，如果相同就接著往下比較，如果出現相異的情況就退回到 <code>T[1]</code> 以及 <code>p[0]</code> 比較，直到主串的結尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">bruteForce</span><span class="params">(string T, string p)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; T.<span class="built_in">size</span>() &amp;&amp; j &lt; p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(T[i] == p[j])&#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            i -= (j - <span class="number">1</span>);</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> i - j;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>這種演算法因為每次都要退回，效率較差，因此比較不推薦使用。</p><h2 id="kmp-演算法">KMP 演算法</h2><p>透過提前建立的 <code>部分匹配表</code> 可以在匹配失敗時利用失敗的資訊將子串的下標進行移動，進而繼續匹配，避免了之前的重複情形。</p><h3 id="部分匹配表">部分匹配表</h3><p>通常會以 <code>next</code> 作為命名，其中每個位置 <code>next[j]</code> 的意義是<code>子串 [0,j] 之間的最長相同前後綴</code>，同時也是在之後 <code>p[j + 1]</code> 發生錯誤匹配時可以跳過檢查的長度。</p><p>範例：</p><table><thead><tr><th>i</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody><tr><td>p[j]</td><td>A</td><td>B</td><td>C</td><td>D</td><td>A</td><td>B</td><td>D</td></tr><tr><td>next[j]</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>2</td><td>0</td></tr></tbody></table><ul><li>i = 4 時，“ABCDA” 有相同前後綴 “A”，長度為 1。</li><li>i = 5 時，“ABCDAB” 有相同前後綴 “AB”，長度為 2。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildNext</span><span class="params">(string p)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(p.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt; p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="keyword">if</span>(p[i] == p[len]) next[i++] = ++len;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(len) len = next[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">else</span> next[i++] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配原則">匹配原則</h3><p>和樸素演算法一樣，從 <code>T[0]</code> 以及 <code>p[0]</code> 開始比較，如果相同就接著往下比較，不同的是在發生錯誤匹配時的處理，此時不用回退 <code>i</code> 的值，而是將 <code>j</code> 移到 <code>next[j - 1]</code> 對應的位置。因為我們知道<code>相同前後綴</code>的長度，因此就可以不用檢查對應的前綴長度，在不用回退的情況下執行至主串的結尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">KMP</span><span class="params">(string T, string p)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; next = <span class="built_in">buildNext</span>(p);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; T.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(j &gt; <span class="number">0</span> &amp;&amp; T[i] != p[j])  j = next[j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(T[i] == p[j]) j++;</span><br><span class="line">        <span class="keyword">if</span>(j == p.<span class="built_in">size</span>()) <span class="keyword">return</span> i - j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="bm-演算法">BM 演算法</h2><p>利用兩種規則來跳過無法匹配的情況，節省比較的時間，移動的方向是由左往右，但是匹配時的方向是從後方開始匹配。</p><ul><li>壞字符規則<ul><li>壞字符：匹配失敗時主字串的字符。</li></ul></li><li>好後綴規則<ul><li>好後綴：已經匹配成功的字串 (由後往前匹配，所以是後綴)。</li></ul></li></ul><h3 id="壞字符規則">壞字符規則</h3><ol><li>匹配失敗時，將子串向右移動，使得<code>主串的壞字符</code>與<code>子串中最右方的壞字符</code>對齊，移動位數 = <code>子串的錯誤匹配位置 - 壞字符在子串中的最右位置</code>。</li></ol><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM-1-1.png" class="" title="type1-1"><ol start="2"><li>如果壞字符在子串中不存在，設定出現位置為 <code>-1</code>，即將整個子串右移 1 位。</li></ol><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM-1-2.png" class="" title="type1-2"><p><code>壞字符位置表</code> (紀錄每個字符出現的最右位置)：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; <span class="title">buildBadCharTable</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; badCharTable;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">        badCharTable[p[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> badCharTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="好後綴規則">好後綴規則</h3><ol><li>找到子串中前一個<code>好後綴</code>出現的位置，將其與主串中的<code>好後綴</code>對齊，右移的位數 = <code>好後綴的位置 - 好後綴在子串中的上一個位置</code>。</li></ol><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM-2-1.png" class="" title="type2-1"><ol start="2"><li>尋找子串中最長的相同前後綴 (子串的前綴 = 好後綴的後綴)，將兩者對齊，右移的位數 = <code>好後綴的位置 - 最長前綴的位置</code>。</li></ol><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM-2-2.png" class="" title="type2-2"><ol start="3"><li>如果以上兩個條件都不存在，可以直接將整個子串右移，右移的位數 = <code>子串的長度</code>。</li></ol><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM-2-3.png" class="" title="type2-3"><p>定義一個後綴數組 <code>suffix</code> 儲存最大相同後綴的長度，每個值 <code>suffix[i]</code> 的意義是<code>以下標 i 為結尾與子串匹配的最大相同後綴長</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildSuffix</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">suffix</span><span class="params">(p.size(), p.size())</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="type">int</span> start = i;</span><br><span class="line">        <span class="keyword">while</span>(start &gt;= <span class="number">0</span> &amp;&amp; p[start] == p[p.<span class="built_in">size</span>() - <span class="number">1</span> - (i - start)]) start--;</span><br><span class="line">        suffix[i] = i - start;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> suffix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>suffix</code> 數組，可以提前建立<code>好後綴規則位移表</code>，每個值 <code>goodSuffixTable[j]</code> 代表在下標 <code>j</code> 處遇到錯誤匹配時，根據好後綴規則所要右移的距離。</p><ul><li>Type3</li></ul><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM2-2-3.png" class="" title="type3"><ul><li>Type2</li></ul><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM2-2-2.png" class="" title="type2"><ul><li>Type1</li></ul><img src="/2024/08/06/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-String/BM2-2-1.png" class="" title="type1"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">buildGoodSuffixTable</span><span class="params">(string p)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">goodSuffixTable</span><span class="params">(p.size(), p.size())</span></span>;</span><br><span class="line">    <span class="comment">//Type3</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; suffix = <span class="built_in">buildSuffix</span>(p);</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Type2 </span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = p.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">        <span class="comment">//相同前後綴</span></span><br><span class="line">        <span class="keyword">if</span>(suffix[i] == i + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">while</span>(j &lt; p.<span class="built_in">size</span>() - <span class="number">1</span> - i)&#123;</span><br><span class="line">                <span class="comment">//好後綴的位置 - 最長前綴的位置</span></span><br><span class="line">                <span class="keyword">if</span>(goodSuffixTable[j] == p.<span class="built_in">size</span>()) goodSuffixTable[j] = p.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Type1</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; p.<span class="built_in">size</span>() - <span class="number">2</span>; i++)&#123;</span><br><span class="line">        goodSuffixTable[p.<span class="built_in">size</span>() - <span class="number">1</span> - suffix[i]] = p.<span class="built_in">size</span>() - <span class="number">1</span> - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> goodSuffixTable;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果同時有兩種情況成立，會選擇移動距離較小者，因此取值的順序是由 <code>Type3</code>、<code>Type2</code> 到 <code>Type1</code>。</p><h3 id="合併使用">合併使用</h3><p>由主串的開頭開始，逐步將子串右移，每次從子串的後方開始比對，比對失敗時比較兩種規則產生的右移距離，取距離較大者進行移動，直到成功匹配為止。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">BM</span><span class="params">(string T, string p)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T.<span class="built_in">size</span>() &lt; p.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//避免主串比子串短</span></span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; bcTable = <span class="built_in">buildBadCharTable</span>(p);</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; gsTable = <span class="built_in">buildGoodSuffixTable</span>(p);</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= T.<span class="built_in">size</span>() - p.<span class="built_in">size</span>())&#123;</span><br><span class="line">        <span class="type">int</span> j = p.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">//由後往前匹配</span></span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; T[i + j] == p[j]) j--;</span><br><span class="line">        <span class="keyword">if</span>(j &lt; <span class="number">0</span>) <span class="keyword">return</span> i; <span class="comment">//成功匹配</span></span><br><span class="line">        <span class="type">int</span> bcMove = j - bcTable[T[i + j]];</span><br><span class="line">        <span class="type">int</span> gsMove = gsTable[j];</span><br><span class="line">        i += <span class="built_in">max</span>(bcMove, gsMove);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="內建-find-函數">內建 find 函數</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">find</span> <span class="params">(<span class="type">const</span> <span class="type">char</span>* s, <span class="type">size_t</span> pos, <span class="type">size_t</span> n)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p><code>&lt;string&gt;</code> 內的 <code>find</code> 函數也可以在字串裡面尋找子串是否出現，如果有則會返回出現的位置，否則返回 <code>string::npos</code>，<code>pos</code> 為尋找的主串起始位置，<code>n</code> 為子串的匹配字元數 (前 n 位)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">size_t</span> found = T.<span class="built_in">find</span>(p);</span><br><span class="line"><span class="keyword">if</span>(found != std::string::npos) cout &lt;&lt; found &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h1>練習</h1><h2 id="leetcode-5-longest-palindromic-substring"><a href="https://leetcode.com/problems/longest-palindromic-substring/description/">LeetCode 5. Longest Palindromic Substring</a></h2><p>Given a string <code>s</code>, return the longest palindromic substring in <code>s</code>.</p><p>Example 1:<br>Input: s = “babad”<br>Output: “bab”</p><p>Example 2:<br>Input: s = “cbbd”<br>Output: “bb”</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">v</span>(s.<span class="built_in">size</span>(), <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(s.<span class="built_in">size</span>(), <span class="literal">false</span>));</span><br><span class="line">        <span class="type">int</span> ms, ml = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= i; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s[i] == s[j])&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i - j &lt;= <span class="number">2</span>) v[i][j] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">else</span> v[i][j] = v[i - <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(v[i][j] &amp;&amp; i - j + <span class="number">1</span> &gt; ml)&#123;</span><br><span class="line">                    ml = i - j + <span class="number">1</span>;</span><br><span class="line">                    ms = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(ms, ml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立一個二維的陣列 <code>v</code> 儲存字串的每個子串是否是對稱的，當子串的開頭與結尾相同時：</p><ul><li>長度 &lt;= 3：此子串必定對稱。</li><li>長度 &gt; 3：檢查<code>去除頭尾的子串</code>是否對稱。<br>之後記錄下最長的對稱子串。</li></ul><h2 id="leetcode-28-find-the-index-of-the-first-occurrence-in-a-string"><a href="https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/description/">LeetCode 28. Find the Index of the First Occurrence in a String</a></h2><p>Given two strings <code>needle</code> and <code>haystack</code>, return the index of the first occurrence of <code>needle</code> in <code>haystack</code>, or <code>-1</code> if <code>needle</code> is not part of <code>haystack</code>.</p><p>Example 1:<br>Input: haystack = “sadbutsad”, needle = “sad”<br>Output: 0</p><p>Example 2:<br>Input: haystack = “leetcode”, needle = “leeto”<br>Output: -1</p><p>Solution:<br>使用前面的樸素演算法、KMP 演算法以及 BM 演算法都能通過，不過需要注意主串比子串短時有的演算法可能會有錯誤。</p><h2 id="leetcode-459-repeated-substring-pattern"><a href="https://leetcode.com/problems/repeated-substring-pattern/description/">LeetCode 459. Repeated Substring Pattern</a></h2><p>Given a string <code>s</code>, check if it can be constructed by taking a substring of it and appending multiple copies of the substring together.</p><p>Example 1:<br>Input: s = “abab”<br>Output: true</p><p>Example 2:<br>Input: s = “aba”<br>Output: false</p><p>Example 3:<br>Input: s = “abcabcabcabc”<br>Output: true</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">repeatedSubstringPattern</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">next</span><span class="params">(s.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">1</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == s[len]) next[i++] = ++len;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(len) len = next[len - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">else</span> next[i++] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l = next[s.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> l &gt; <span class="number">0</span> &amp;&amp; (s.<span class="built_in">size</span>() % (s.<span class="built_in">size</span>() - l) == <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立 KMP 算法中的 <code>next</code> 陣列，如果字串是由重複的子串構成，<code>字串長度 - 最大相同前後綴長</code>會是最小的重複子串長度，檢查字串長度是否為子串的整數倍即可。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料結構 </tag>
            
            <tag> String </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Map</title>
      <link href="/2024/08/05/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Map/"/>
      <url>/2024/08/05/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Map/</url>
      
        <content type="html"><![CDATA[<h1>Map</h1><p>可以儲存 <code>key</code> 以及其對應 <code>value</code> 的容器，內部會按照 <code>key</code> 的值進行排序，有以下幾個常見的操作：</p><ul><li>insert 加入元素</li><li>erase 刪除元素</li><li>count 確認該元素是否存在</li><li>find 回傳元素位置</li><li>empty 確認是否為空</li><li>size 回傳元素個數</li><li>clear 清空所有元素</li></ul><h1>Unordered Map</h1><p>可以儲存 <code>key</code> 以及其對應 <code>value</code> 的容器，內部不會進行排序，而是使用雜湊表的方式進行一對一的對應，利於查詢對應元素的關係，可以使用的函數與 <code>map</code> 類似。</p><p>比較：</p><table><thead><tr><th>容器</th><th>map</th><th>unordered_map</th></tr></thead><tbody><tr><td>結構</td><td>紅黑樹</td><td>雜湊表</td></tr><tr><td>內部資料</td><td>有序</td><td>無序</td></tr><tr><td>查詢速度</td><td>較低</td><td>較高</td></tr></tbody></table><p>通常在不要求內部元素有排序的情況下，會使用查詢效率較高的 <code>unordered_map</code>。</p><h1>操作</h1><h2 id="遍歷">遍歷</h2><p>使用指針指向開頭，進行遍歷，使用 <code>first</code> 取 <code>key</code>、<code>second</code> 取 <code>value</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); i != m.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;key &quot;</span> &lt;&lt; i -&gt; first &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value &quot;</span> &lt;&lt; i -&gt; second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="替代">替代</h2><p>在某些 <code>key</code> 值數量較少的情況下，例如 <code>a ~ z 字母</code> 或是 <code>1 ~ 100 的數字</code>，可以直接使用 <code>vector</code> 等容器，直接以索引值代表 <code>key</code> 並且儲存對應的 <code>value</code>。</p><h1>練習</h1><h2 id="leetcode-49-group-anagrams"><a href="https://leetcode.com/problems/group-anagrams/description/">LeetCode 49. Group Anagrams</a></h2><p>Given an array of strings <code>strs</code>, group the anagrams together. You can return the answer in any order.</p><p>An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.</p><p>Example 1:<br>Input: strs = [“eat”,“tea”,“tan”,“ate”,“nat”,“bat”]<br>Output: [[“bat”],[“nat”,“tan”],[“ate”,“eat”,“tea”]]</p><p>Example 2:<br>Input: strs = [&quot;&quot;]<br>Output: [[&quot;&quot;]]</p><p>Example 3:<br>Input: strs = [“a”]<br>Output: [[“a”]]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;string&gt;&gt; <span class="built_in">groupAnagrams</span>(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        unordered_map&lt;string, vector&lt;string&gt;&gt; m;</span><br><span class="line">        vector&lt;vector&lt;string&gt;&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; strs.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="function">string <span class="title">tmp</span><span class="params">(strs[i])</span></span>;</span><br><span class="line">            <span class="built_in">sort</span>(tmp.<span class="built_in">begin</span>(), tmp.<span class="built_in">end</span>());</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">count</span>(tmp)) m[tmp].<span class="built_in">push_back</span>(strs[i]);</span><br><span class="line">            <span class="keyword">else</span> m[tmp] = &#123;strs[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i = m.<span class="built_in">begin</span>(); i != m.<span class="built_in">end</span>(); i++)&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(i -&gt; second);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用<code>同字母異序詞</code>中字母經過排序之後會變為相同字串的特性，將其作為 <code>key</code> 值就可以將他們分組。</p><h2 id="leetcode-149-max-points-on-a-line"><a href="https://leetcode.com/problems/sliding-window-maximum/description/">LeetCode 149. Max Points on a Line</a></h2><p>Given an array of <code>points</code> where <code>points[i] = [xi, yi]</code> represents a point on the X-Y plane, return the maximum number of points that lie on the same straight line.</p><p>Return the max sliding window.</p><p>Example 1:</p><img src="/2024/08/05/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Map/ex-2-1.jpg" class="" title="ex1"><p>Input: points = [[1,1],[2,2],[3,3]]<br>Output: 3</p><p>Example 2:</p><img src="/2024/08/05/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Map/ex-2-2.jpg" class="" title="ex2"><p>Input: points = [[1,1],[3,2],[5,3],[4,1],[2,3],[1,4]]<br>Output: 4</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPoints</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; points.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            unordered_map&lt;<span class="type">double</span>, <span class="type">int</span>&gt; m;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; points.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == j) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="type">double</span> k;</span><br><span class="line">                <span class="keyword">if</span>((points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>])) k = (<span class="type">double</span>)(points[i][<span class="number">1</span>] - points[j][<span class="number">1</span>]) / (<span class="type">double</span>)(points[i][<span class="number">0</span>] - points[j][<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">else</span> k = <span class="number">20001</span>;</span><br><span class="line">                <span class="keyword">if</span>(m.<span class="built_in">count</span>(k)) m[k]++;</span><br><span class="line">                <span class="keyword">else</span> m[k] = <span class="number">1</span>;</span><br><span class="line">                ans = <span class="built_in">max</span>(ans, m[k] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用雙重迴圈遍歷所有點，每次固定一個點，以他與其他點之間連線的斜率作為 <code>key</code> 值，<code>value</code> 儲存連線斜率相同的點數量，在判斷時要注意避免分母為 0 的情況。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料結構 </tag>
            
            <tag> Map </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Queue</title>
      <link href="/2024/08/02/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Queue/"/>
      <url>/2024/08/02/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Queue/</url>
      
        <content type="html"><![CDATA[<h1>Queue</h1><p>先進先出的容器，有以下幾個常見的操作：</p><ul><li>push 尾端加入元素</li><li>pop 頂端刪除元素</li><li>front 回傳頂端元素</li><li>back 回傳尾端元素</li><li>empty 確認是否為空</li><li>size 回傳元素個數</li></ul><h1>Priority Queue</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Container</span> = vector&lt;T&gt;,  <span class="keyword">class</span> Compare = less&lt;<span class="keyword">typename</span> Container::value_type&gt; &gt; <span class="keyword">class</span> priority_queue;</span><br></pre></td></tr></table></figure><p>容器內部的元素依照一定順序排列，每次取出位於排列頂端的元素，預設為遞減排序 (由頂部至尾部遞減)，如果要改為遞增可以加上 <code>greater&lt;T&gt;</code>，或是使用自己寫的 cmp 排序，其餘操作與普通的 Queue 相同。</p><h1>練習</h1><h2 id="leetcode-703-kth-largest-element-in-a-stream"><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/description/">LeetCode 703. Kth Largest Element in a Stream</a></h2><p>Design a class to find the k<sup>th</sup> largest element in a stream. Note that it is the k<sup>th</sup> largest element in the sorted order, not the k<sup>th</sup> distinct element.</p><p>Implement KthLargest class:</p><ul><li><code>KthLargest(int k, int[] nums)</code> Initializes the object with the integer <code>k</code> and the stream of integers <code>nums</code>.</li><li><code>int add(int val)</code> Appends the integer <code>val</code> to the stream and returns the element representing the k<sup>th</sup> largest element in the stream.</li></ul><p>Example 1:<br>Input<br>[“KthLargest”, “add”, “add”, “add”, “add”, “add”]<br>[[3, [4, 5, 8, 2]], [3], [5], [10], [9], [4]]<br>Output<br>[null, 4, 5, 5, 8, 8]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KthLargest</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;<span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="type">int</span> k, vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        len = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; len) pq.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        pq.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(pq.<span class="built_in">size</span>() &gt; len) pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> pq.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立一個遞增的 Priority Queue，並且限制其長度為 k，當長度大於 k 的時候就把頂端較小的元素刪除，這樣就可以保持尾端剛好是第 k 大的元素。</p><h2 id="leetcode-239-sliding-window-maximum"><a href="https://leetcode.com/problems/sliding-window-maximum/description/">LeetCode 239. Sliding Window Maximum</a></h2><p>You are given an array of integers <code>nums</code>, there is a sliding window of size <code>k</code> which is moving from the very left of the array to the very right. You can only see the <code>k</code> numbers in the window. Each time the sliding window moves right by one position.</p><p>Return the max sliding window.</p><p>Example 1:<br>Input: nums = [1,3,-1,-3,5,3,6,7], k = 3<br>Output: [3,3,5,5,6,7]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; pq;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = k; i &lt; nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(&#123;nums[i], i&#125;);</span><br><span class="line">            <span class="keyword">while</span>((pq.<span class="built_in">top</span>()).second &lt; i - k + <span class="number">1</span> || (pq.<span class="built_in">top</span>()).second &gt; i) pq.<span class="built_in">pop</span>();</span><br><span class="line">            ans.<span class="built_in">push_back</span>(pq.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立一個 Priority Queue 裡面儲存的是一個 pair，pair 內的數字分別表示<code>元素的數值以及所在位置</code>，每次 sliding window 移動時，加入新元素，之後判斷位於頂端的元素位置是否在區間內部，否則將其去除，這樣就可以找到區間內的最大值。</p><h2 id="leetcode-295-find-median-from-data-stream"><a href="https://leetcode.com/problems/find-median-from-data-stream/description/">LeetCode 295. Find Median from Data Stream</a></h2><p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p><p>For example, for <code>arr = [2,3,4]</code>, the median is <code>3</code>.<br>For example, for <code>arr = [2,3]</code>, the median is <code>(2 + 3) / 2 = 2.5</code>.<br>Implement the MedianFinder class:</p><p><code>MedianFinder()</code> initializes the <code>MedianFinder</code> object.<br><code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure.<br><code>double findMedian()</code> returns the median of all elements so far. Answers within 10<sup>-5</sup> of the actual answer will be accepted.</p><p>Example 1:<br>Input<br>[“MedianFinder”, “addNum”, “addNum”, “findMedian”, “addNum”, “findMedian”]<br>[[], [1], [2], [], [3], []]<br>Output<br>[null, null, null, 1.5, null, 2.0]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="type">double</span>, vector&lt;<span class="type">double</span>&gt;, greater&lt;<span class="type">double</span>&gt;&gt; pq1;</span><br><span class="line">    priority_queue&lt;<span class="type">double</span>&gt; pq2;</span><br><span class="line">    <span class="built_in">MedianFinder</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNum</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pq2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            pq2.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">double</span> m;</span><br><span class="line">        <span class="keyword">if</span>((pq1.<span class="built_in">size</span>() + pq2.<span class="built_in">size</span>()) % <span class="number">2</span> == <span class="number">0</span>) m = (pq1.<span class="built_in">top</span>() + pq2.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">else</span> m = pq2.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span>(num &gt; m)&#123;</span><br><span class="line">            pq1.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(pq1.<span class="built_in">size</span>() == pq2.<span class="built_in">size</span>() + <span class="number">1</span>)&#123;</span><br><span class="line">                pq2.<span class="built_in">push</span>(pq1.<span class="built_in">top</span>());</span><br><span class="line">                pq1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            pq2.<span class="built_in">push</span>(num);</span><br><span class="line">            <span class="keyword">if</span>(pq1.<span class="built_in">size</span>() + <span class="number">2</span> == pq2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                pq1.<span class="built_in">push</span>(pq2.<span class="built_in">top</span>());</span><br><span class="line">                pq2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">findMedian</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>((pq1.<span class="built_in">size</span>() + pq2.<span class="built_in">size</span>()) % <span class="number">2</span> == <span class="number">0</span>) <span class="keyword">return</span> (pq1.<span class="built_in">top</span>() + pq2.<span class="built_in">top</span>()) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> pq2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>建立兩個 Priority Queue 分別以遞增、遞減排序，分別代表<code>大於中位數</code>以及<code>小於等於中位數</code>的數字，取中位數時會有以下情況：</p><ul><li>長度為奇數：取 pq2 (小於等於中位數的數字) 的頂端 <code>pq2.top()</code>。</li><li>長度為偶數：取中間兩數的平均 <code>(pq1.top() + pq2.top()) / 2</code>。</li></ul><p>而在加入數字的時候也要根據加入數字的大小 (與中位數的關係) 判斷要加到哪一區，並且平衡兩區的數字數量。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料結構 </tag>
            
            <tag> Queue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-Stack</title>
      <link href="/2024/07/31/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Stack/"/>
      <url>/2024/07/31/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-Stack/</url>
      
        <content type="html"><![CDATA[<h1>Stack</h1><p>先進後出的容器，有以下幾個常見的操作：</p><ul><li>push 頂端加入元素</li><li>pop 頂端刪除元素</li><li>top 回傳頂端元素</li><li>empty 確認是否為空</li><li>size 回傳元素個數</li></ul><h1>Monotonic Stack</h1><p>解題時常用的技巧，保持 Stack 裡面的元素是單調遞減或遞增，也有可能是儲存對應的下標，本文章中的遞增或遞減順序是由 Stack <code>底部至頂部</code>，有的文章中偏好使用頂部至底部，故在此做區分。</p><h2 id="分類">分類</h2><h3 id="遞增-stack">遞增 Stack</h3><p>內部的值由底部至頂部為遞增。</p><ul><li>當前值大於 Stack 頂部值：直接插入 Stack 中。</li><li>當前值小於 Stack 頂部值：不斷移除頂部值，直到當前值大於 Stack 頂部值或是 Stack 為空，最後插入當前值。</li></ul><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &gt; input[i])&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">push</span>(input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遞減-stack">遞減 Stack</h3><p>內部的值由底部至頂部為遞減。</p><ul><li>當前值小於 Stack 頂部值：直接插入 Stack 中。</li><li>當前值大於 Stack 頂部值：不斷移除頂部值，直到當前值小於 Stack 頂部值或是 Stack 為空，最後插入當前值。</li></ul><p>Code:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; input;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; input.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">    <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; stk.<span class="built_in">top</span>() &lt; input[i])&#123;</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    stk.<span class="built_in">push</span>(input[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="應用">應用</h2><p>Monotonic Stack 主要用來尋找 <code>某元素左/右兩邊，第一個比該元素大/小的元素</code>，簡單來說可以分為以下四類，而他們也都有自己對應的處理方式。</p><ul><li>元素左側，第一個比該元素大的元素：<br>建立一個遞減的 Stack，由左向右遍歷，插入當前元素時，位於頂部的元素即為所求，如果 Stack 為空，代表左側沒有比該元素大的元素。</li><li>元素左側，第一個比該元素小的元素：<br>建立一個遞增的 Stack，由左向右遍歷，插入當前元素時，位於頂部的元素即為所求，如果 Stack 為空，代表左側沒有比該元素小的元素。</li><li>元素右側，第一個比該元素大的元素：<ul><li>建立一個遞減的 Stack，由左向右遍歷，當元素自 Stack 中移除時，要插入的元素即為所求，如果沒有被移除，代表右側沒有比該元素大的元素。</li><li>建立一個遞增的 Stack，由右向左遍歷，插入當前元素時，位於頂部的元素即為所求，如果 Stack 為空，代表右側沒有比該元素大的元素。</li></ul></li><li>元素右側，第一個比該元素小的元素：<ul><li>建立一個遞增的 Stack，由左向右遍歷，當元素自 Stack 中移除時，要插入的元素即為所求，如果沒有被移除，代表右側沒有比該元素小的元素。</li><li>建立一個遞增的 Stack，由右向左遍歷，插入當前元素時，位於頂部的元素即為所求，如果 Stack 為空，代表右側沒有比該元素大的元素。</li></ul></li></ul><p>可以統整如下：</p><table><thead><tr><th>類型</th><th>Stack 類型</th><th>遍歷方向</th><th>取值時機</th></tr></thead><tbody><tr><td>左側/大</td><td>遞減</td><td>左至右</td><td>插入時取頂部值</td></tr><tr><td>左側/小</td><td>遞增</td><td>左至右</td><td>插入時取頂部值</td></tr><tr><td>右側/大</td><td>遞減</td><td>左至右</td><td>移除時取插入值</td></tr><tr><td>右側/大</td><td>遞增</td><td>右至左</td><td>插入時取頂部值</td></tr><tr><td>右側/小</td><td>遞增</td><td>左至右</td><td>移除時取插入值</td></tr><tr><td>右側/小</td><td>遞減</td><td>右至左</td><td>插入時取頂部值</td></tr></tbody></table><h1>練習</h1><h2 id="leetcode-32-longest-valid-parentheses"><a href="https://leetcode.com/problems/longest-valid-parentheses/description/">LeetCode 32. Longest Valid Parentheses</a></h2><p>Given a string containing just the characters <code>'('</code> and <code>')'</code>, return the length of the longest valid (well-formed) parentheses substring.</p><p>Example 1:<br>Input: s = “(()”<br>Output: 2</p><p>Example 2:<br>Input: s = “)()())”<br>Output: 4</p><p>Example 3:<br>Input: s = “”<br>Output: 0</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestValidParentheses</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        stk.<span class="built_in">push</span>(<span class="number">-1</span>);</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i] == <span class="string">&#x27;(&#x27;</span>) stk.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(stk.<span class="built_in">empty</span>()) stk.<span class="built_in">push</span>(i);</span><br><span class="line">                <span class="keyword">else</span> ans = <span class="built_in">max</span>(ans, i - stk.<span class="built_in">top</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Stack 在這裡是用來儲存 <code>上一組成功匹配的括號的尾端</code> 的下標，一開始先 push -1 進去，並且遵循以下邏輯：</p><ul><li>輸入為 <code>'('</code> 則將下標放入 Stack 中。</li><li>輸入為 <code>')'</code> 則 pop Stack 頂端下標，如果：<ul><li>Stack 為空：pop 的元素為 <code>上一組成功匹配的括號的尾端</code> 的下標，將此時的下標存入 Stack 中。</li><li>Stack 不為空：成功匹配前一個括號，計算當前最長子字串的長度儲存到 ans 中。</li></ul></li></ul><p>每次位於 Stack 底部的元素都會是 <code>上一組成功匹配的括號的尾端</code> 的下標，如果把它 pop 了就代表當前的子字串匹配完畢，因此要把當前的下標儲存入 Stack 中。</p><h2 id="leetcode-739-daily-temperatures"><a href="https://leetcode.com/problems/daily-temperatures/description/">LeetCode 739. Daily Temperatures</a></h2><p>Given an array of integers <code>temperatures</code> represents the daily temperatures, return an array <code>answer</code> such that <code>answer[i]</code> is the number of days you have to wait after the i<sup>th</sup> day to get a warmer temperature. If there is no future day for which this is possible, keep <code>answer[i] == 0</code> instead.</p><p>Example 1:<br>Input: temperatures = [73,74,75,71,69,72,76,73]<br>Output: [1,1,4,2,1,1,0,0]</p><p>Example 2:<br>Input: temperatures = [30,40,50,60]<br>Output: [1,1,1,0]</p><p>Example 3:<br>Input: temperatures = [30,60,90]<br>Output: [1,1,0]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; temperatures)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(temperatures.size())</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; temperatures.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; temperatures[stk.<span class="built_in">top</span>()] &lt; temperatures[i])&#123;</span><br><span class="line">                ans[stk.<span class="built_in">top</span>()] = i - stk.<span class="built_in">top</span>();</span><br><span class="line">                stk.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            stk.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>這一題是要找元素右側第一個比該元素大的元素，因此建構了一個遞減 Stack，不過 Stack 內部儲存的是對應的下標值，用來計算相隔的天數。</p><h2 id="leetcode-316-remove-duplicate-letters"><a href="https://leetcode.com/problems/remove-duplicate-letters/description/">LeetCode 316. Remove Duplicate Letters</a></h2><p>Given a string <code>s</code>, remove duplicate letters so that every letter appears once and only once. You must make sure your result is<br>the smallest in lexicographical orderamong all possible results.</p><p>Example 1:<br>Input: s = “bcabc”<br>Output: “abc”</p><p>Example 2:<br>Input: s = “cbacdcbc”<br>Output: “acdb”</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">removeDuplicateLetters</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">inStk</span><span class="params">(<span class="number">26</span>, <span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; stk;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            c[s[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!inStk[s[i] - <span class="string">&#x27;a&#x27;</span>])&#123;</span><br><span class="line">                <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>() &amp;&amp; c[stk.<span class="built_in">top</span>() - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span> &amp;&amp; stk.<span class="built_in">top</span>() &gt; s[i])&#123;</span><br><span class="line">                    inStk[stk.<span class="built_in">top</span>() - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                    stk.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                stk.<span class="built_in">push</span>(s[i]);</span><br><span class="line">                inStk[s[i] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            c[s[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        string ans = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!stk.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            ans = stk.<span class="built_in">top</span>() + ans;</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>為了讓 Stack 裡面的元素以最小的字典序儲存，同時又要確保每個字母只出現一次，因此建立了兩個 vector 分別用來儲存 <code>該字母是否已經在 Stack 中</code> 以及 <code>在字串中的出現次數</code>。<br>遍歷整個字串，如果該字母在 Stack 中，重複判斷<code>頂部元素出現次數是否大於 0 且字母序比該字母大</code>，如果是則移除頂部元素，直到條件不成立時就可以將當前字母放入 Stack 中，並且把出現次數減一。</p><h2 id="leetcode-155-min-stack"><a href="https://leetcode.com/problems/min-stack/description/">LeetCode 155. Min Stack</a></h2><p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p><p>Implement the <code>MinStack</code> class:</p><ul><li><code>MinStack()</code> initializes the stack object.</li><li><code>void push(int val)</code> pushes the element <code>val</code> onto the stack.</li><li><code>void pop()</code> removes the element on the top of the stack.</li><li><code>int top()</code> gets the top element of the stack.</li><li><code>int getMin()</code> retrieves the minimum element in the stack.</li><li>You must implement a solution with <code>O(1)</code> time complexity for each function.</li></ul><p>Example 1:<br>Input<br>[“MinStack”,“push”,“push”,“push”,“getMin”,“pop”,“top”,“getMin”]<br>[[],[-2],[0],[-3],[],[],[],[]]<br>Output<br>[null,null,null,null,-3,null,0,-2]</p><p>Solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stkMin;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(stkMin.<span class="built_in">empty</span>() || val &lt;= stkMin.<span class="built_in">top</span>()) stkMin.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stkMin.<span class="built_in">top</span>() == stk.<span class="built_in">top</span>()) stkMin.<span class="built_in">pop</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stkMin.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用遞減 Stack <code>stkMin</code> 儲存最小值，如果 push 的值小於或等於 <code>stkMin</code> 的頂端值則將其放入，如果在 pop 的時候剛好是移除最小值，則要將 <code>stkMin</code> 的頂端值移除。</p><p>Solution 2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; stk;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        stk.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span>(v.<span class="built_in">empty</span>()) v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">else</span> v.<span class="built_in">push_back</span>(<span class="built_in">min</span>(val, v[v.<span class="built_in">size</span>() - <span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        stk.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> v[v.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用 vector 紀錄 Stack 每個位置作為結尾的最小值。</p><div class="note primary no-icon flat"><p>更多關於單調 Stack 的細節可以參考 <a href="https://medium.com/@deserter/monotonic-stack-deque-770fcc94c145">Monotonic Stack/Deque</a></p></div>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料結構 </tag>
            
            <tag> Stack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google人工智慧要點筆記</title>
      <link href="/2024/07/28/Google%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E8%A6%81%E9%BB%9E%E7%AD%86%E8%A8%98/"/>
      <url>/2024/07/28/Google%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E8%A6%81%E9%BB%9E%E7%AD%86%E8%A8%98/</url>
      
        <content type="html"><![CDATA[<h1>Google AI Essentials</h1><h2 id="證書簡介">證書簡介</h2><div class="note primary no-icon flat"><p>官網介紹：<br>Google AI Essentials 是一門自定進度的課程，目的是幫助不同角色和行業的人們獲得基本的人工智慧技能，並且應用到工作以及生活中，以提高生產力。</p></div><p>本證書只包含一個課程，主要內容是介紹 AI 工具的使用，以及如何應用到工作以及日常生活之中，大約十個小時以內可以完成，實作的部分都是可選的，大多可以使用 <code>Gemini</code> 等工具幫助完成，測驗也只有幾個，整體來說難度不會太高。</p><blockquote><p>和資料分析課程一樣為全英文，影片都有字幕。</p></blockquote><h2 id="章節大綱">章節大綱</h2><ol><li>Introduction to AI<br>了解 AI 的工作原理以及基本知識，學習如何利用它來執行任務。</li><li>Maximize Productivity With AI Tools<br>學習利用生成式 AI 工具加快工作任務並提高工作效率。</li><li>Discover the Art of Prompt Engineering<br>學習編寫有效的提示以獲得想要的輸出，並且將提示技術融入工作中。</li><li>Use AI Responsibly<br>了解如何負責任且有效地使用人工智慧，減少偏見和不準確性。</li><li>Stay Ahead of the AI Curve<br>跟上未來人工智慧的發展，並且持續精進 AI 技能。</li></ol><h2 id="內容筆記">內容筆記</h2><h3 id="人工智慧-機器學習">人工智慧 &amp; 機器學習</h3><p>人工智慧是指能夠完成與人類智慧相關的認知任務的電腦程式，其主要包含了兩種技術：</p><ul><li>基於規則：嚴格遵循預定義規則來做出決策，使用垃圾郵件過濾器可能會使用預先定義的邏輯來封鎖包含特定關鍵字的電子郵件。</li><li>機器學習：創建可以分析資料模式並學習以做出獨立決策的人工智慧程式，以郵件過濾為例，如果收件者將來自受信任來源的電子郵件標記為安全，垃圾郵件過濾器就會學習並調整其邏輯。機器學習又可以分為監督式學習、非監督式學習以及強化學習。</li></ul><h3 id="人工智慧的侷限性">人工智慧的侷限性</h3><ul><li>無法處理需要人性化 (敏感) 的問題。</li><li>可能因為資料集老舊導致結果有誤。</li><li>可能放大資料集的偏見，導致不真實的結果。</li></ul><p>考慮到以上幾點甚至更多的問題，在使用人工智慧時必須確保要有人類的監督，以確保產生正確且沒有危害的結果。</p><h3 id="ai-工具-ai-模型">AI 工具 &amp; AI 模型</h3><p>AI 工具是 AI 所驅動的軟體，可以自動執行或協助使用者完成各種任務，而 AI 模型是一種電腦程序，經過資料集訓練以識別模式並執行特定任務。可以以汽車與引擎來比喻兩者之間的關係，汽車擁有方向盤和儀表板等介面，代表了 AI 工具，而 AI 模型這個看不見的引擎會負責處理輸入的信息。</p><img src="/2024/07/28/Google%E4%BA%BA%E5%B7%A5%E6%99%BA%E6%85%A7%E8%A6%81%E9%BB%9E%E7%AD%86%E8%A8%98/AI-models.png" class="" title="AI models"><h3 id="使用生成式-ai-的時機">使用生成式 AI 的時機</h3><ul><li>任務是否是生成性的 (需要產生新東西)?</li><li>是否能迭代以獲得更好的結果?</li><li>是否能提供足夠的人力監督?</li></ul><h3 id="大型語言模型-llm-與提示詞">大型語言模型 (LLM) 與提示詞</h3><p>LLM 是一個經過大量訓練的 AI 模型，接受數百萬文本的訓練，包括書籍、文章、網站等，用來辨識單字、概念之間的模式，並且產生對提示詞的回應。</p><p>為了能夠讓 LLM 有更精準地回答，在使用提示詞的時候可以注意幾個要點：</p><ul><li>提供背景資訊</li><li>提供範例</li><li>迭帶改進提示詞</li><li>在提示中包含特定指令（如 create、summarise、classify、extract、translate、edit、solve）</li></ul><h3 id="ai-可能造成的傷害">AI 可能造成的傷害</h3><p>當 AI 因為系統性錯誤或偏見而產生了不準確的資訊，可能會對人和社會造成多種類型的傷害。</p><ul><li>分配性傷害：因為 AI 的使用剝奪了個人的機會、資源或資訊。</li><li>服務品質傷害：AI 對於特定人群表現不佳的情況。</li><li>代表性傷害：AI 強化社會群體的從屬關係 (對立)。</li><li>社會系統傷害： 由於 AI 的開發或使用而產生的宏觀社會影響，擴大現有的階級、權力或特權差距，或造成人身傷害。</li><li>人際傷害：利用科技對某些人造成不利影響，對他們的人際互動或其他方面產生傷害。</li></ul><h3 id="負責任的使用-ai">負責任的使用 AI</h3><ul><li>審查輸出：透過提供背景以及範例，並且利用自身的知識評估結果，以確保輸出的準確性。</li><li>公開使用：公開對於 AI 的使用目的以及方式讓資料提供者了解，並且不直接複製貼上 AI 所產生的輸出作為自己的成果。</li><li>分享之前評估所有內容：確保內容是合法的，並且利用搜尋引擎檢查內容的準確性，在發現內容有誤時也要及時修正並檢討。</li><li>隱私和安全影響：考慮是否會對其他人造成負面影響，或是洩漏他人的隱私。</li></ul><h2 id="總結">總結</h2><p>訂閱<a href="https://douobb.github.io/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E5%BF%83%E5%BE%97/">資料分析</a>的課程的時候附贈的，內容不多但是挺有趣的，不僅說明了 AI 對於工作上的幫助，還介紹了可能造成的危害，以及正確合理的使用方式，幫助學生更好的利用 AI。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程心得</title>
      <link href="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E5%BF%83%E5%BE%97/"/>
      <url>/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1>Google Data Analytics Certificate</h1><h2 id="證書簡介">證書簡介</h2><div class="note primary no-icon flat"><p>官網介紹：<br>無論你是剛起步還是想在數據分析領域邁出下一步，Google 的專業證書都可以幫助您獲得必備的技能，學習 R 程式設計、SQL、Python、Tableau 等知識。</p></div><p>本證書總共包含八個課程，雖然官網上的規劃是用六個月來完成，不過因為是訂閱制度，因此可以依照自己的進度自行調整，省下一筆錢，這次總共用了三十多天來完成 (包含七天的試用期)，詳細的時間分配之後也會提到。</p><p>課程的知識不算太過於深入，但是涵蓋了許多面向，如同官網所提到的，介紹了從資料清理、分析到視覺化的各種工具，除此之外也與職場做了許多連結，包括之後的更多應用以及求職、面試等內容都有提到，就算沒有太多的先備知識學起來也不算太困難，非常適合新手參與。</p><blockquote><p>課程為全英文，不過大部分的影片都有字幕，理解上不會太困難，只是有些專業的名詞需要多注意。</p></blockquote><h2 id="各課程內容-時間分配">各課程內容 &amp; 時間分配</h2><p>分配時間為個人經驗，主要是為了在一個月內完成，需依照實際情況分配。</p><table><thead><tr><th>課程</th><th>主要內容</th><th>分配時間</th><th>筆記</th></tr></thead><tbody><tr><td>Foundations: Data, Data, Everywhere</td><td>課程簡介、工作流程以及常用工具介紹</td><td>3 天</td><td><a href="https://douobb.github.io/2024/06/26/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-1/">Link</a></td></tr><tr><td>Ask Questions to Make Data-Driven Decisions</td><td>如何進行提問、試算表的使用</td><td>3 天</td><td><a href="https://douobb.github.io/2024/06/28/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-2/">Link</a></td></tr><tr><td>Prepare Data for Exploration</td><td>如何挑選資料、SQL 的使用</td><td>3 天</td><td><a href="https://douobb.github.io/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/">Link</a></td></tr><tr><td>Process Data from Dirty to Clean</td><td>如何利用工具清理資料、學習製作簡歷</td><td>4 天</td><td><a href="https://douobb.github.io/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/">Link</a></td></tr><tr><td>Analyze Data to Answer Questions</td><td>如何利用試算表、SQL 進行分析</td><td>5 天</td><td><a href="https://douobb.github.io/2024/07/10/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-5/">Link</a></td></tr><tr><td>Share Data Through the Art of Visualization</td><td>資料視覺化技巧、Tableau 使用以及簡報技巧</td><td>5 天</td><td><a href="https://douobb.github.io/2024/07/15/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-6/">Link</a></td></tr><tr><td>Data Analysis with R Programming</td><td>使用 R 語言進行資料分析、視覺化</td><td>5 天</td><td><a href="https://douobb.github.io/2024/07/20/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-7/">Link</a></td></tr><tr><td>Google Data Analytics Capstone: Complete a Case Study</td><td>案例分析、求職面試技巧</td><td>5 天</td><td><a href="https://douobb.github.io/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/">Link</a></td></tr></tbody></table><h2 id="總結">總結</h2><p>相當推薦給新手的課程，難易度適中，可以對資料分析有更多的了解，學習到許多實用工具，其他的面試以及工作技巧在未來也許會有幫助，註冊時還送了一門 <code>Google AI Essentials</code> 的課程，之後也會將課程的筆記與心得上傳。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-8</title>
      <link href="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/"/>
      <url>/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/</url>
      
        <content type="html"><![CDATA[<h1>Course 8 - Google Data Analytics Capstone</h1><h2 id="簡介">簡介</h2><p>This course is the eighth and final course in the Google Data Analytics Certificate. You’ll have the opportunity to complete a case study, which will help prepare you for your data analytics job hunt. Case studies are commonly used by employers to assess analytical skills. For your case study, you’ll choose an analytics-based scenario. You’ll then ask questions, prepare, process, analyze, visualize and act on the data from the scenario. You’ll also learn about useful job hunting skills, common interview questions and responses, and materials to build a portfolio online.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Learn about capstone basics<br>了解綜整專案、案例研究和作品集，並使用它們如何讓雇主更好地了解你的技能和能力。</li><li>Optional: Build your portfolio<br>進行案例研究，並將其放到平台上託管。</li><li>Optional: Use your portfolio<br>學習在面試的過程中善用自己的作品集。</li><li>Put your certificate to work<br>獲取課程證書，介紹求職平台。</li></ol><h1>內容筆記</h1><h2 id="case-study">Case Study</h2><p>我挑選的是 Case Study 1 作為我的案例研究，此案例的主要內容是作為分析師為芝加哥的自行車共享公司 Cyclistic 進行資料分析，了解休閒騎士和年度會員使用自行車的方式有什麼不同，並且根據結果設計新的行銷策略。主要利用之前提到過的數據分析六階段 ask、prepare、process、analyze、share、act 進行。</p><h3 id="step-1-ask">Step 1 - Ask</h3><p>主管指派了你一個問題： <code>休閒騎士和年度會員使用自行車的方式有什麼不同?</code></p><p>Guiding questions</p><ul><li>你要解決的問題是什麼?<ul><li>利用資料找出休閒騎士和年度會員之間的差異。</li></ul></li><li>你的見解會如何影響決策?<ul><li>幫助設計策略，將休閒騎士轉化為年度會員。</li></ul></li></ul><h3 id="step-2-prepare">Step 2 - Prepare</h3><p>Cyclistic 的歷史行程數據</p><ul><li>資料來源： Lyft Bikes and Scooters, LLC</li><li>網址： <a href="https://divvy-tripdata.s3.amazonaws.com/index.html">https://divvy-tripdata.s3.amazonaws.com/index.html</a></li><li>授權： <a href="https://divvybikes.com/data-license-agreement">https://divvybikes.com/data-license-agreement</a></li><li>時間段： 2015 - 2024</li></ul><blockquote><p>我選擇了 <code>202307</code> 到 <code>202406</code> 的資料作為我的案例分析。</p></blockquote><h3 id="step-3-process">Step 3 - Process</h3><p>利用 <code>R</code> 進行資料合併、除缺失值，在表內增加了四個欄位，最後進行篩選。</p><ul><li>ride_length: 行程的時間 (單位為分鐘)。</li><li>day_of_week: 行程結束時是星期幾。</li><li>ended_month: 行程結束時的月份。</li><li>ended_hour: 行程結束時是幾點。</li></ul><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">setwd<span class="punctuation">(</span><span class="string">&quot;G:/projects/Google Data Analytics Certificate Case Study/Case Study 1 - How does a bike-share navigate speedy success/data&quot;</span><span class="punctuation">)</span></span><br><span class="line">weekDay <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;Sun&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Mon&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Tue&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Wed&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Thu&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Fri&quot;</span><span class="punctuation">,</span> <span class="string">&quot;Sat&quot;</span><span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Import &amp; Aggregate</span></span><br><span class="line">aggregate_files <span class="operator">&lt;-</span> list.files<span class="punctuation">(</span>pattern <span class="operator">=</span> <span class="string">&quot;*.csv&quot;</span><span class="punctuation">)</span></span><br><span class="line">aggregate_data <span class="operator">&lt;-</span> map_df<span class="punctuation">(</span>aggregate_files<span class="punctuation">,</span> read_csv<span class="punctuation">)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Clean</span></span><br><span class="line">divvyTrips <span class="operator">&lt;-</span> aggregate_data <span class="operator">%&gt;%</span> </span><br><span class="line">  select<span class="punctuation">(</span>ride_id<span class="punctuation">,</span> started_at<span class="punctuation">,</span> ended_at<span class="punctuation">,</span> start_station_name<span class="punctuation">,</span> end_station_name<span class="punctuation">,</span> member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  drop_na<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  mutate<span class="punctuation">(</span>ride_length <span class="operator">=</span> <span class="built_in">as.numeric</span><span class="punctuation">(</span>difftime<span class="punctuation">(</span>ended_at<span class="punctuation">,</span> started_at<span class="punctuation">,</span> units <span class="operator">=</span> <span class="string">&quot;mins&quot;</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span>day_of_week <span class="operator">=</span> weekDay<span class="punctuation">[</span>wday<span class="punctuation">(</span>ended_at<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span>ended_month <span class="operator">=</span> <span class="built_in">month.abb</span><span class="punctuation">[</span>month<span class="punctuation">(</span>ended_at<span class="punctuation">)</span><span class="punctuation">]</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  mutate<span class="punctuation">(</span>ended_hour <span class="operator">=</span> hour<span class="punctuation">(</span>ended_at<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  select<span class="punctuation">(</span>ride_id<span class="punctuation">,</span> ended_hour<span class="punctuation">,</span> ended_month<span class="punctuation">,</span> day_of_week<span class="punctuation">,</span> ride_length<span class="punctuation">,</span> member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span> </span><br><span class="line">  filter<span class="punctuation">(</span>ride_length <span class="operator">&gt;=</span><span class="number">1</span><span class="punctuation">,</span> ride_length <span class="operator">&lt;=</span> <span class="number">1440</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>清理後的表格：</p><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Cleaned-Table.png" class="" title="Cleaned Table"><h3 id="step-4-analyze-step-5-share">Step 4 - Analyze &amp; Step 5 - Share</h3><ol><li>每月騎乘次數<br>比較各個月份的騎乘次數。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numbers of rides by month</span></span><br><span class="line">divvyTrips <span class="operator">%&gt;%</span> count<span class="punctuation">(</span>ended_month<span class="punctuation">,</span>member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> reorder<span class="punctuation">(</span>ended_month<span class="punctuation">,</span>match<span class="punctuation">(</span>ended_month<span class="punctuation">,</span><span class="built_in">month.abb</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>y <span class="operator">=</span> n<span class="punctuation">,</span>fill <span class="operator">=</span> member_casual<span class="punctuation">)</span><span class="punctuation">,</span> stat<span class="operator">=</span><span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Numbers of rides by month&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;month&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;rides&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Numbers-of-rides-by-month.png" class="" title="Plot"><p>騎乘次數在六月到九月時最高，且休閒騎士的數量成長明顯，我認為可能是因為這個時間段有較好的天氣，並且遊客數量較多。</p><ol start="2"><li>星期內每日騎乘次數<br>比較星期內每日的騎乘次數。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numbers of rides by days of week</span></span><br><span class="line">divvyTrips <span class="operator">%&gt;%</span> count<span class="punctuation">(</span>day_of_week<span class="punctuation">,</span>member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> reorder<span class="punctuation">(</span>day_of_week<span class="punctuation">,</span>match<span class="punctuation">(</span>day_of_week<span class="punctuation">,</span>weekDay<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">,</span>y <span class="operator">=</span> n<span class="punctuation">)</span><span class="punctuation">,</span> stat<span class="operator">=</span><span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>member_casual<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Numbers of rides by days of week&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;days of week&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;rides&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Numbers-of-rides-by-days-of-week.png" class="" title="Plot"><p>在圖中可以發現兩種使用者的騎乘趨勢是不同的，會員通常在工作日騎乘，而休閒騎士則在周末騎乘較多。</p><ol start="3"><li>各小時騎乘次數<br>比較每個小時的騎乘次數。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numbers of rides by hour</span></span><br><span class="line">divvyTrips <span class="operator">%&gt;%</span> count<span class="punctuation">(</span>ended_hour<span class="punctuation">,</span>member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> ended_hour<span class="punctuation">,</span>y <span class="operator">=</span> n<span class="punctuation">)</span><span class="punctuation">,</span> stat<span class="operator">=</span><span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>member_casual<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Numbers of rides by hour&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;hour&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;rides&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Numbers-of-rides-by-hour.png" class="" title="Plot"><p>在會員的圖中可以看到兩個峰值，分別是早上八點以及下午五點，而休閒騎士只有一個峰值在下午五點，綜合前一點可以推測，會員通常在通勤時間騎車上下班，休閒騎士則是在周末下午騎車休閒較多。</p><ol start="4"><li>星期內各日各小時騎乘次數<br>比較星期內每日每小時的騎乘次數。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numbers of rides by days of week and hours</span></span><br><span class="line">divvyTrips <span class="operator">%&gt;%</span> count<span class="punctuation">(</span>ended_hour<span class="punctuation">,</span>member_casual<span class="punctuation">,</span>day_of_week<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  ggplot<span class="punctuation">(</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> ended_hour<span class="punctuation">,</span>y <span class="operator">=</span> n<span class="punctuation">)</span><span class="punctuation">,</span> stat<span class="operator">=</span><span class="string">&quot;identity&quot;</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span>member_casual<span class="operator">~</span>day_of_week<span class="punctuation">,</span>nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Numbers of rides by days of week and hours&quot;</span><span class="punctuation">,</span> x <span class="operator">=</span> <span class="string">&quot;hour&quot;</span><span class="punctuation">,</span> y <span class="operator">=</span> <span class="string">&quot;rides&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Numbers-of-rides-by-days-of-week-and-hours.png" class="" title="Plot"><p>在假日時兩者的趨勢是相同的，但是在工作日時就有明顯的不同，符合我們之前的假設。</p><ol start="5"><li>平均騎乘時間<br>比較兩種使用者的平均騎乘時間。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Average ride length</span></span><br><span class="line">View<span class="punctuation">(</span>divvyTrips <span class="operator">%&gt;%</span> group_by<span class="punctuation">(</span>member_casual<span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">       summarise<span class="punctuation">(</span>rides <span class="operator">=</span> n<span class="punctuation">(</span><span class="punctuation">)</span><span class="punctuation">,</span> avg_ride_length <span class="operator">=</span> mean<span class="punctuation">(</span>ride_length<span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><img src="/2024/07/25/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-8/Average-ride-length.png" class="" title="Plot"><p>雖然會員的騎乘次數比休閒騎士要多，但是休閒騎士的平均騎乘時間較高，如同我們之前假設的，原因可能是會員通勤時間較短，而休閒騎士主要是騎車進行休閒活動，因此騎乘時間較長。</p><ol start="6"><li>總結</li></ol><ul><li>在<code>六月到九月</code>期間有較高的騎乘次數.</li><li>會員與休閒騎士的差異：</li></ul><table><thead><tr><th>差異</th><th>會員</th><th>休閒騎士</th></tr></thead><tbody><tr><td>周</td><td>工作日較高</td><td>周末較高</td></tr><tr><td>小時</td><td>通勤時間有兩個峰值</td><td>單一個峰值在下午</td></tr><tr><td>騎乘次數</td><td>較高</td><td>較低</td></tr><tr><td>平均騎乘時間</td><td>較低</td><td>較高</td></tr></tbody></table><h3 id="step-6-act">Step 6 - Act</h3><p>建議:</p><ul><li>將預算集中在有較多客戶的月份 (<code>六月到九月</code>) 去吸引更多會員。</li><li>在<code>工作日的通勤時間</code>提供折扣，吸引更多人騎車通勤，並且轉化為會員。</li><li>同時在<code>周末</code>也提供折扣，讓更多人騎車進行休閒活動，接觸到這項服務。</li></ul><div class="note primary no-icon flat"><p>詳細的內容以及檔案可以在 <a href="https://github.com/douobb/Google-Data-Analytics-Certificate-Case-Study">Github</a> 上面看到。</p></div>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-7</title>
      <link href="/2024/07/20/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-7/"/>
      <url>/2024/07/20/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-7/</url>
      
        <content type="html"><![CDATA[<h1>Course 7 - Data Analysis with R Programming</h1><h2 id="簡介">簡介</h2><p>This course is the seventh course in the Google Data Analytics Certificate. In this course, you’ll learn about the programming language known as R. You’ll find out how to use RStudio, the environment that allows you to work with R, and the software applications and tools that are unique to R, such as R packages. You’ll discover how R lets you clean, organize, analyze, visualize, and report data in new and more powerful ways.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Programming and data analytics<br>了解 R 和 RStudio。</li><li>Programming using RStudio<br>了解 R 語言中資料型態，並且學習套件如何安裝以及使用。</li><li>Working with data in R<br>學習利用 R 語言中的函數幫助篩選、排序資料，並且操作 data frames。</li><li>More about visualizations, aesthetics, and annotations<br>學習使用 ggplot2 建立圖表並且匯出。</li><li>Documentation and reports<br>學習使用 R Markdown 建立動態文檔。</li></ol><h1>內容筆記</h1><h2 id="module-2-programming-using-rstudio">Module 2 - Programming using RStudio</h2><h3 id="vectors">vectors</h3><p>一組相同類型的資料元素</p><ol><li>建立</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">c</span><span class="punctuation">(</span><span class="number">2.5</span><span class="punctuation">,</span> <span class="number">48.5</span><span class="punctuation">,</span> <span class="number">101.5</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">c</span><span class="punctuation">(</span><span class="number">1L</span><span class="punctuation">,</span> <span class="number">5L</span><span class="punctuation">,</span> <span class="number">15L</span><span class="punctuation">)</span> <span class="comment">#如果內容是整數，要在後面加上 L</span></span><br><span class="line"><span class="built_in">c</span><span class="punctuation">(</span>“Sara” <span class="punctuation">,</span> “Lisa” <span class="punctuation">,</span> “Anna”<span class="punctuation">)</span></span><br><span class="line"><span class="built_in">c</span><span class="punctuation">(</span><span class="literal">TRUE</span><span class="punctuation">,</span> <span class="literal">FALSE</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>命名</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">names</span><span class="punctuation">(</span>x<span class="punctuation">)</span> <span class="operator">&lt;-</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="string">&quot;b&quot;</span><span class="punctuation">,</span> <span class="string">&quot;c&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="list">list</h3><p>可以包含各種類型的資料元素</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span><span class="punctuation">(</span><span class="string">&quot;a&quot;</span><span class="punctuation">,</span> <span class="number">1L</span><span class="punctuation">,</span> <span class="number">1.5</span><span class="punctuation">,</span> <span class="literal">TRUE</span><span class="punctuation">)</span></span><br><span class="line"><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="built_in">list</span><span class="punctuation">(</span><span class="number">1</span> <span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">,</span> <span class="number">5</span><span class="punctuation">)</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="matrices">matrices</h3><p>二維矩陣，<code>nrow</code> 和 <code>ncol</code> 用於控制列和行的個數</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="operator">:</span><span class="number">8</span><span class="punctuation">)</span><span class="punctuation">,</span> nrow <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br><span class="line">matrix<span class="punctuation">(</span><span class="built_in">c</span><span class="punctuation">(</span><span class="number">3</span><span class="operator">:</span><span class="number">8</span><span class="punctuation">)</span><span class="punctuation">,</span> ncol <span class="operator">=</span> <span class="number">2</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="data-frames">Data frames</h3><p>二維資料格式，有以下特點：</p><ol><li>可以包含各種類型的資料。</li><li>每個單元格只有一個元素。</li><li>每個欄位都需要被命名。</li><li>每欄只包含相同類型的資料。</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">data.frame<span class="punctuation">(</span>x <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1</span><span class="punctuation">,</span> <span class="number">2</span><span class="punctuation">,</span> <span class="number">3</span><span class="punctuation">)</span> <span class="punctuation">,</span> y <span class="operator">=</span> <span class="built_in">c</span><span class="punctuation">(</span><span class="number">1.5</span><span class="punctuation">,</span> <span class="number">5.5</span><span class="punctuation">,</span> <span class="number">7.5</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="pipe">Pipe</h3><p><code>%&gt;%</code> 運算子可以用於連接兩個函數，將前面函數的輸出作為下一個函數的輸入使用，可以讓編寫程式更為省力，並且增加易讀性。</p><p>範例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onlineta_city_hotels_v2 <span class="operator">&lt;-</span> hotel_bookings <span class="operator">%&gt;%</span></span><br><span class="line">  filter<span class="punctuation">(</span>hotel<span class="operator">==</span><span class="string">&quot;City Hotel&quot;</span><span class="punctuation">)</span> <span class="operator">%&gt;%</span></span><br><span class="line">  filter<span class="punctuation">(</span>market_segment<span class="operator">==</span><span class="string">&quot;Online TA&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>將 <code>hotel_bookings</code> 作為輸入放到第一個 <code>filter</code> 之後的結果再次作為輸入放入第二個 <code>filter</code> 中，最後存入 <code>onlineta_city_hotels_v2</code>。</p><h3 id="lubridate-套件">lubridate 套件</h3><p>包含在 <code>tidyverse</code> 套件之中，使用前必須先安裝並且引入，主要是與時間、日期操有關的套件。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">install.packages<span class="punctuation">(</span><span class="string">&quot;tidyverse&quot;</span><span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>tidyverse<span class="punctuation">)</span></span><br><span class="line">library<span class="punctuation">(</span>lubridate<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>時間資料類型：</p><ul><li>date (“2016-08-16”)</li><li>time (“20:11:59 UTC&quot;)</li><li>date-time (“2018-03-31 18:15:48 UTC”)</li></ul><p>相關函數：</p><ul><li>today() 返回當前日期</li><li>now() 返回當前時間 (包含日期)</li></ul><ol><li>轉換為 date</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ymd<span class="punctuation">(</span><span class="string">&quot;2021-01-20&quot;</span><span class="punctuation">)</span></span><br><span class="line">mdy<span class="punctuation">(</span><span class="string">&quot;January 20th, 2021&quot;</span><span class="punctuation">)</span></span><br><span class="line">ymd<span class="punctuation">(</span><span class="number">20210120</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ol start="2"><li>轉換為 date-time</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ymd_hms<span class="punctuation">(</span><span class="string">&quot;2021-01-20 20:11:59&quot;</span><span class="punctuation">)</span></span><br><span class="line">mdy_hm<span class="punctuation">(</span><span class="string">&quot;01/20/2021 08:01&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>date-time 轉換為 date</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">as_date<span class="punctuation">(</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h3 id="檔案操作">檔案操作</h3><ol><li>建立</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">file.create<span class="punctuation">(</span><span class="string">&quot;new_text_file.txt&quot;</span><span class="punctuation">)</span> </span><br><span class="line">file.create<span class="punctuation">(</span><span class="string">&quot;new_word_file.docx&quot;</span><span class="punctuation">)</span> </span><br><span class="line">file.create<span class="punctuation">(</span><span class="string">&quot;new_csv_file.csv&quot;</span><span class="punctuation">)</span> </span><br></pre></td></tr></table></figure><ol start="2"><li>複製</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file.copy<span class="punctuation">(</span><span class="string">&quot;new_text_file.txt&quot;</span><span class="punctuation">,</span> <span class="string">&quot;destination_folder&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><ol start="3"><li>刪除</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlink<span class="punctuation">(</span><span class="string">&quot;some_.file.csv&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><h2 id="module-3-working-with-data-in-r">Module 3 - Working with data in R</h2><h3 id="data-frames-操作-檢視">Data frames 操作-檢視</h3><ol><li><p>head(<code>data</code>)<br>顯示前六列資料。</p></li><li><p>str(<code>data</code>)<br>逐欄顯示資料的內部結構。</p></li><li><p>colnames(<code>data</code>)<br>列出各欄的名稱。</p></li></ol><h3 id="data-frames-清理">Data frames 清理</h3><ol><li><p>clean_names(<code>data</code>, <code>case</code>)<br>將欄位名稱改為特定格式，包含 “snake”, “lower_camel”…。</p></li><li><p>rename(<code>data</code>, …), rename_with(<code>data</code>, <code>case</code>, …)<br>重新命名欄位，<code>rename_with</code> 的 <code>case</code> 可以選擇 <code>tolower</code> 或是 <code>toupper</code> 將欄位名稱轉換為小寫或大寫，也可以指定轉換某些欄位。</p></li><li><p>drop_na(<code>data</code>)<br>清除包含缺失值的列。</p></li></ol><h3 id="data-frames-摘要">Data frames 摘要</h3><ol><li><p>glimpse(<code>data</code>)<br>快速摘要資料集內容。</p></li><li><p>skim_without_charts(<code>data</code>)<br>全面的資料集摘要。</p></li></ol><h3 id="data-frames-篩選與排序">Data frames 篩選與排序</h3><ol><li><p>select(<code>data</code>, …)<br>篩選出要顯示的欄位 (與 SQL 中的類似)。</p></li><li><p>filter(<code>data</code>, …)<br>篩選符合特定條件的列。</p></li><li><p>arrange(<code>data</code>, …)<br>根據給定的欄位排序，預設為升序排列，如果要改為降序則要改為 <code>desc(col)</code>，缺失值會被排在最後。</p></li><li><p>group_by(<code>data</code>, …), summarize(<code>data</code>, …)<br><code>group_by</code> 可以根據給予的欄位進行分組，通常會配合 <code>summarize</code> 使用，<code>summarize</code> 可以將整個表格整理為單一個列，底下以統計各班級平均身高為例，以班級進行分組後，使用 <code>mean()</code> 函數計算平均身高。</p></li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">summarize<span class="punctuation">(</span>data<span class="punctuation">,</span> <span class="built_in">class</span><span class="punctuation">,</span> avg_height <span class="operator">=</span> mean<span class="punctuation">(</span>height<span class="punctuation">,</span>na.rm <span class="operator">=</span> <span class="literal">TRUE</span><span class="punctuation">)</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># na.rm 代表計算平均時忽略缺失值</span></span><br></pre></td></tr></table></figure><h3 id="data-frames-其他操作">Data frames 其他操作</h3><ol><li><p>separate(<code>data</code>, <code>col</code>, <code>into</code>, <code>sep</code>)<br>將一欄的數據拆分成多個欄位，<code>into</code> 代表新的欄位名稱，<code>sep</code> 代表分隔符。</p></li><li><p>unite(<code>data</code>, <code>col</code>, …, <code>sep</code>)<br>將多個欄位的資料透過分隔符合併為一欄，<code>col</code> 為新欄位名稱，<code>sep</code> 代表分隔符。</p></li><li><p>mutate(<code>data</code>, …)<br>對原有欄位進行操作，並將結果儲存到新欄位，以單位轉換為例：</p></li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mutate<span class="punctuation">(</span>data<span class="punctuation">,</span> height_cm <span class="operator">=</span> height <span class="operator">*</span> <span class="number">100</span><span class="punctuation">)</span></span><br><span class="line"><span class="comment"># 將原本的身高 (單位為公尺) 乘以 100 之後儲存到新欄位 height_cm</span></span><br></pre></td></tr></table></figure><h3 id="tibbles">Tibbles</h3><p>Tibbles 類似 Data frames 的進階版本，每次只會顯示資料的前十列，包含在 <code>tidyverse</code> 庫中，可以使用 <code>as_tibble()</code> 將 Data frames 轉換為 Tibbles。</p><h2 id="module-4-more-about-visualizations-aesthetics-and-annotations">Module 4 - More about visualizations, aesthetics, and annotations</h2><h3 id="aesthetics">Aesthetics</h3><p>與圖表的視覺效果相關，包含大小、形狀、顏色等。</p><p>範例：</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> penguins<span class="punctuation">)</span><span class="operator">+</span></span><br><span class="line">  geom_point<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> flipper_length_mm<span class="punctuation">,</span> y <span class="operator">=</span> body_mass_g<span class="punctuation">,</span> color <span class="operator">=</span> species<span class="punctuation">)</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p><code>aes</code> 中的 <code>x,y</code> 代表 x 軸和 y 軸對應的欄位，<code>color</code> 代表了點的顏色，在這裡是以不同的族群作為顏色區別。</p><p>其他可以使用的變數包含 <code>shape</code>, <code>size</code>, <code>alpha</code> (透明度), … 等。</p><h3 id="geom">Geom</h3><p>與圖表的類型以及幾何物件相關，可以透過 <code>+</code> 符號連接以疊加多個圖表，以下舉例幾個常用的圖表類型：</p><ul><li>geom_point 散佈圖</li><li>geom_jitter 抖動散佈圖 (當有資料點重複時，會產生隨機偏移)</li><li>geom_bar 長條圖</li><li>geom_line 折線圖</li><li>geom_smooth 趨勢線</li></ul><h3 id="facets">Facets</h3><p>將資料分群展示。</p><ol><li>facet_wrap(~<code>col</code>) 以單一欄位作為分類 (不會顯示空表格)</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> hotel_bookings<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> distribution_channel<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>deposit_type<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>以 <code>deposit_type</code> 進行分類，產生多個圖表，下圖是產生結果：</p><img src="/2024/07/20/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-7/facet-wrap.png" class="" title="facet-wrap"><ol start="2"><li>facet_grid(<code>row</code> ~ <code>col</code>) 以兩個欄位做組合分類 (會顯示空表格)</li></ol><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> hotel_bookings<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> distribution_channel<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_grid<span class="punctuation">(</span><span class="operator">~</span>deposit_type<span class="operator">~</span>market_segment<span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>以 <code>deposit_type</code> 作為列，<code>market_segment</code> 作為欄進行分類，產生多個圖表，下圖是產生結果：</p><img src="/2024/07/20/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-7/facet-grid.png" class="" title="facet-grid"><h3 id="lable-and-annotations">Lable and annotations</h3><p>圖表的標籤以及其他文字。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ggplot<span class="punctuation">(</span>data <span class="operator">=</span> hotel_bookings<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  geom_bar<span class="punctuation">(</span>mapping <span class="operator">=</span> aes<span class="punctuation">(</span>x <span class="operator">=</span> market_segment<span class="punctuation">)</span><span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  facet_wrap<span class="punctuation">(</span><span class="operator">~</span>hotel<span class="punctuation">)</span> <span class="operator">+</span></span><br><span class="line">  labs<span class="punctuation">(</span>title<span class="operator">=</span><span class="string">&quot;Comparison of market segments by hotel type for hotel bookings&quot;</span><span class="punctuation">)</span></span><br></pre></td></tr></table></figure><p>在 <code>labs</code> 之中加上 <code>title</code> 代表標題名稱，以下列舉其他可以加上的文字：</p><ul><li><code>subtitle</code> 子標題，位在標題下方</li><li><code>caption</code> 字幕，位在圖表右下方</li><li><code>x, y</code> 座標軸名稱，位在座標軸旁</li></ul><p>除此之外也可以使用 <code>annotate()</code> 函數，在指定的位置上加上文字。</p><h3 id="圖表儲存">圖表儲存</h3><p>要儲存產生的圖表可以使用 <code>ggsave()</code> 函數，默認會儲存最後一個生成的圖表，可以在函數中指定檔案名稱、大小以及解析度等等細節。</p><h2 id="詞彙">詞彙</h2><ol><li>Aesthetic ®(美學): A visual property of an object in a plot.</li><li>Nested (嵌套、巢狀): Code that performs a particular function and is containe d within code that performs a broader function.</li><li>Tidyverse ®: A system of packages in R with a common design philosophy for data manipulation, exploration, and visualization.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-6</title>
      <link href="/2024/07/15/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-6/"/>
      <url>/2024/07/15/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-6/</url>
      
        <content type="html"><![CDATA[<h1>Course 6 - Share Data Through the Art of Visualization</h1><h2 id="簡介">簡介</h2><p>This is the sixth course in the Google Data Analytics Certificate. You’ll learn how to visualize and present your data findings as you complete the data analysis process. This course will show you how data visualizations, such as visual dashboards, can help bring your data to life. You’ll also explore Tableau, a data visualization platform that will help you create effective visualizations for your presentations.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Visualize data<br>認識各種類型的資料視覺化方法，並了解如何什麼是有效的視覺化，以及其他有助於資料視覺化的因素。</li><li>Create data visualizations with Tableau<br>學習利用 Tableau 平台建立視覺化，並且為視覺化注入創造力和清晰度，確保產生的圖表容易理解。</li><li>Craft data stories<br>了解什麼是數據故事，並學習使用 Tableau 的儀表板和過濾功能創造有吸引力的視覺化效果。</li><li>Develop presentations and slideshows<br>了解如何有效地演示數據分析，建立能夠引起觀眾共鳴的簡報。</li></ol><h1>內容筆記</h1><h2 id="module-1-visualize-data">Module 1 - Visualize data</h2><h3 id="資料視覺化要素-the-mccandless-method">資料視覺化要素 - The McCandless method</h3><table><thead><tr><th>要素</th><th>解釋</th></tr></thead><tbody><tr><td>Information</td><td>正在使用的資料</td></tr><tr><td>Story</td><td>清晰且有說服力的敘述或概念</td></tr><tr><td>Goal</td><td>明確的目標或功能</td></tr><tr><td>Visual form</td><td>有效的視覺表達</td></tr></tbody></table><img src="/2024/07/15/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-6/The-McCandless-method.png" class="" title="四大要素"><h3 id="相關性-因果關係">相關性 &amp; 因果關係</h3><table><thead><tr><th>類型</th><th>區別</th></tr></thead><tbody><tr><td>相關性</td><td>衡量兩個變數相互關係的程度，並不意味著一個事件會導致另一個事件</td></tr><tr><td>因果關係</td><td>指事件導致特定結果的想法</td></tr></tbody></table><p>例子：<br>糙皮病是一種以頭暈、瘡、嘔吐和腹瀉為症狀的疾病，一開始人們認為這種疾病是由不衛生的生活條件引起的，大多數患有糙皮病的人也生活在不衛生的環境中。之後的研究發現，糙皮病是缺乏維生素 B3 所造成，證明骯髒的生活條件與其只是有相關性，並非因果關係。</p><h3 id="不同的視覺化方式">不同的視覺化方式</h3><table><thead><tr><th>資料模式</th><th>視覺化類型</th></tr></thead><tbody><tr><td>變化</td><td>隨著時間的推移而變化的觀察資料，適合透過折線圖或長條圖展示</td></tr><tr><td>聚類</td><td>資料集擁有相似或不同的值時，適合利用分布圖來展示</td></tr><tr><td>相對性</td><td>與事物的比例有關，或是包含一個整體的多個部分，適合使用圓餅圖</td></tr><tr><td>排行</td><td>需要排序的資料適合用長條圖來表示</td></tr><tr><td>相關性</td><td>表示兩個或多個事物之間的相互關係，可以使用散點圖表示</td></tr></tbody></table><img src="/2024/07/15/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-6/Decision-trees.png" class="" title="決策樹"><h3 id="設計原則">設計原則</h3><table><thead><tr><th>原則</th><th>解釋</th></tr></thead><tbody><tr><td>平衡</td><td>顏色和形狀等關鍵視覺元素均勻分佈</td></tr><tr><td>強調</td><td>使用顏色或是數值來表示出資料中的重點</td></tr><tr><td>移動</td><td>使用線條和顏色來吸引注意，並引導視線</td></tr><tr><td>圖案</td><td>使用形狀和顏色強調相似或相異的效果</td></tr><tr><td>重複</td><td>重複圖表類型、形狀或顏色，幫助觀眾回顧、比較之前的資料</td></tr><tr><td>比例</td><td>使用不同的顏色和尺寸有助於強調某些訊息</td></tr><tr><td>節奏</td><td>透過排列元素，形成流暢的視覺展現</td></tr><tr><td>多樣性</td><td>圖表類型、線條、形狀、顏色和數值方面應該具有一定的多樣性</td></tr><tr><td>一致性</td><td>所有內容應該保持前後一致，避免矛盾的情況</td></tr></tbody></table><h2 id="module-2-create-data-visualizations-with-tableau">Module 2 - Create data visualizations with Tableau</h2><h3 id="避免誤導性圖表">避免誤導性圖表</h3><table><thead><tr><th>避免</th><th>解釋</th></tr></thead><tbody><tr><td>切斷 y 軸</td><td>改變 y 軸比例可能導致不同組別差異看起來更大</td></tr><tr><td>雙 y 軸</td><td>如果使用雙 y 軸而沒有清楚標示，可能產生誤導</td></tr><tr><td>錯誤的分組</td><td>錯誤的分組可能無法呈現數據全貌，或是掩蓋了重要的趨勢</td></tr><tr><td>錯誤的圖表類型</td><td>如果在圓餅圖中的數據總和並非 100% 可能產生誤導</td></tr><tr><td>人為平滑趨勢</td><td>在大規模的散佈圖中使用趨勢線，可能使資料比原本看起來有更加緊密的聯繫</td></tr></tbody></table><h2 id="詞彙">詞彙</h2><ol><li>Annotation (註解): Text that briefly explains data or helps focus the audience on a particular aspect of the data in a visualization.</li><li>Cluster (聚類): A collection of data points on a data visualization with similar values.</li><li>Data storytelling (數據故事): Communicating the meaning of a dataset with visuals and a narrative that are customized for an audience.</li><li>Emphasis (強調): The design principle of arranging visual elements to focus the audience’s attention on important information in a data visualization.</li><li>Framework (框架): The context a presentation needs to create logical connections that tie back to the business task and metrics.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-5</title>
      <link href="/2024/07/10/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-5/"/>
      <url>/2024/07/10/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-5/</url>
      
        <content type="html"><![CDATA[<h1>Course 5 - Analyze Data to Answer Questions</h1><h2 id="簡介">簡介</h2><p>This is the fifth course in the Google Data Analytics Certificate. In this course, you’ll explore what it means to actually analyze your data. You’ll take what you’ve learned up to this point and apply it to make sense of the data you’ve collected. You’ll learn how to organize and format your data using spreadsheets and SQL to help you look at and think about your data in different ways. You’ll also find out how to perform complex calculations with your data to address business objectives. You’ll learn how to use formulas, functions, and SQL queries as you conduct your analysis.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Organize data for more effective analysis<br>了解如何使用試算表以及 SQL 進行排序和篩選。</li><li>Format and adjust data<br>了解轉換和格式化資料，以及學習利用 SQL 組合資料。</li><li>Aggregate data for analysis<br>學習如何使用 SQL 從多個資料庫提取資料進行組合。</li><li>Perform data calculations<br>利用試算表中的公式、函數和資料透視表以及 SQL 幫助計算，並且學習使用 SQL 管理臨時表格。</li></ol><h1>內容筆記</h1><h2 id="module-1-organize-data-for-more-effective-analysis">Module 1 - Organize data for more effective analysis</h2><h3 id="試算表中的排序">試算表中的排序</h3><p>如果排序的條件較少的話，可以使用內建的 <code>SORT</code> 函數，而如果條件較多則建議使用內建的排序功能。</p><ul><li>SORT(範圍, 排序欄, 遞增, [排序欄_2, 遞增_2, …])<br>以一欄或多欄中的值為依據，排列指定陣列或範圍內的資料列順序。</li><li>全選資料，點擊 <code>資料 &gt; 排序範圍 &gt; 範圍排序進階選項</code></li></ul><h3 id="sql-中的排序">SQL 中的排序</h3><p>預設為升序排序，如果要改成降序只要在後面加上 <code>DESC</code> 即可</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> column_name1 <span class="keyword">ASC</span><span class="operator">|</span><span class="keyword">DESC</span>, column_name2 <span class="keyword">ASC</span><span class="operator">|</span>DESC...</span><br></pre></td></tr></table></figure><h2 id="module-2-format-and-adjust-data">Module 2 - Format and adjust data</h2><h3 id="試算表轉換單位">試算表轉換單位</h3><p>CONVERT(數值, 初始單位, 目標單位)，利用 <code>CONVERT</code> 函數可以將數值轉換成其他計量單位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=CONVERT (A1, &quot;F&quot;, “C”)</span><br></pre></td></tr></table></figure><p>常用的單位 (使用時須注意大小寫)：</p><ul><li>重量：u、grain、g、ozm、lbm、ton…</li><li>距離：ang、Picapt、pica、in、ft、yd、m…</li><li>時間：sec、min、hr、day、yr</li><li>溫度：C、F、K</li><li>資訊：bit、byte</li><li>速度：m/hr、mph、kn、admkn、m/s</li></ul><h3 id="sql-字串合併">SQL 字串合併</h3><table><thead><tr><th>函數</th><th>範例</th><th>結果</th></tr></thead><tbody><tr><td>CONCAT(string1, string2, …, string_n)</td><td>CONCAT(‘Google’, ‘.com’)</td><td><a href="http://Google.com">Google.com</a></td></tr><tr><td>CONCAT_WS(separator, string1, string2, …, string_n)</td><td>CONCAT_WS(’ . ', ‘www’, ‘google’, ‘com’)</td><td><a href="http://www.google.com">www.google.com</a></td></tr><tr><td>|| or +</td><td>‘Google’ || ‘.com’</td><td><a href="http://Google.com">Google.com</a></td></tr></tbody></table><h2 id="module-3-aggregate-data-for-analysis">Module 3 - Aggregate data for analysis</h2><h3 id="join-函數">JOIN 函數</h3><p><code>JOIN</code> 函數可以根據相關欄位來組合多個表中的列，根據組合的關係可以分為 INNER JOIN、LEFT JOIN、RIGHT JOIN 和 OUTER JOIN，可以表示如下圖 (取自 <a href="https://learnsql.com/blog/learn-and-practice-sql-joins/">How to Learn SQL JOINs</a>) ：</p><img src="/2024/07/10/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-5/join.png" class="" title="JOIN類型"><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  column_name(s)</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  table1 <span class="comment">--left table</span></span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> table2 <span class="comment">--right table</span></span><br><span class="line"><span class="keyword">ON</span> table1.column_name <span class="operator">=</span> table2.column_name <span class="comment">--共同欄位</span></span><br></pre></td></tr></table></figure><h3 id="子查詢">子查詢</h3><p>透過子查詢可以組合不同的邏輯，透過單一查詢完成更多工作，並且使程式更有效率且容易閱讀。</p><ol><li><code>SELECT</code> 中的子查詢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">station_id,</span><br><span class="line">num_bikes_available,</span><br><span class="line">(<span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">AVG</span>(num_bikes_available)</span><br><span class="line"><span class="keyword">FROM</span> bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_stations) <span class="keyword">AS</span> avg_num_bikes_available <span class="comment">--子查詢</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_stations</span><br></pre></td></tr></table></figure><p>透過子查詢，加入 <code>avg_num_bikes_available</code> 作為欄位。</p><ol start="2"><li><code>FROM</code> 中的子查詢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">station_id,</span><br><span class="line">name,</span><br><span class="line">number_of_rides <span class="keyword">AS</span> number_of_rides_starting_at_station</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">CAST</span>(start_station_id <span class="keyword">AS</span> STRING) <span class="keyword">AS</span> start_station_id_str,</span><br><span class="line"><span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">AS</span> number_of_rides</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">      bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_trips</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> </span><br><span class="line"><span class="built_in">CAST</span>(start_station_id <span class="keyword">AS</span> STRING)</span><br><span class="line">) <span class="comment">--子查詢</span></span><br><span class="line"><span class="keyword">AS</span> station_num_trips</span><br><span class="line"><span class="keyword">INNER</span> <span class="keyword">JOIN</span> </span><br><span class="line">bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_stations </span><br><span class="line"><span class="keyword">ON</span> </span><br><span class="line">station_id <span class="operator">=</span> start_station_id_str</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> </span><br><span class="line">number_of_rides <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><p>利用子查詢直接建立一個表 <code>station_num_trips</code>，並透過 <code>FROM</code> 去存取。</p><ol start="3"><li><code>WHERE</code> 中的子查詢</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">station_id,</span><br><span class="line">name</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_stations</span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">station_id <span class="keyword">IN</span></span><br><span class="line">(</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line"><span class="built_in">CAST</span>(start_station_id <span class="keyword">AS</span> STRING) <span class="keyword">AS</span> start_station_id_str</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    bigquery<span class="operator">-</span>public<span class="operator">-</span>data.new_york.citibike_trips</span><br><span class="line">  <span class="keyword">WHERE</span></span><br><span class="line">  usertype <span class="operator">=</span> <span class="string">&#x27;Subscriber&#x27;</span></span><br><span class="line">  )</span><br></pre></td></tr></table></figure><p>利用子查詢建立一個表，之後用 <code>IN</code> 來篩選出有在表內的特定 id。</p><h3 id="having-子句">HAVING 子句</h3><p>因為 <code>WHERE</code> 沒辦法和聚合函數一起使用，因此必須使用 <code>HAVING</code> 來替代。</p><ul><li>聚合函數類型<ul><li>MIN()</li><li>MAX()</li><li>COUNT()</li><li>SUM()</li><li>AVG()</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">HAVING</span> <span class="keyword">condition</span></span><br></pre></td></tr></table></figure><h2 id="module-4-perform-data-calculations">Module 4 - Perform data calculations</h2><h3 id="更多試算表函數">更多試算表函數</h3><ol><li>SUMIF(範圍, 條件, [加總範圍])<br>傳回範圍內符合條件的項目總和，若未指定加總範圍，會使用<code>範圍</code>引數指定的範圍來計算總和。</li><li>SUMIFS(加總範圍, 條件核對範圍1, 條件1, [條件核對範圍2, 條件2, …])<br>傳回根據多個條件而得出的範圍總和，須注意和 <code>SUMIF</code> 的參數順序不同。</li><li>COUNTIFS(條件核對範圍1, 條件1, [條件核對範圍2, 條件2, …])<br>傳回根據多個條件而得出的範圍大小。</li><li>SUMPRODUCT(陣列1, [陣列2], …)<br>針對兩個或更多大小相同的陣列或範圍，計算彼此對應項目的乘積總和。</li></ol><h3 id="資料驗證">資料驗證</h3><p>資料驗證有助於確認資料的完整性，並確保數據是乾淨的。</p><table><thead><tr><th>類型</th><th>解釋</th><th>範例</th></tr></thead><tbody><tr><td>資料類型</td><td>資料是否與與欄位定義的資料類型相符</td><td>年齡值必須是數字類型</td></tr><tr><td>資料範圍</td><td>資料是否落在為欄位定義可接受的範圍內</td><td>分數的數據應介於 0 和 100 之間</td></tr><tr><td>資料約束</td><td>資料是否符合欄位的某些條件或標準</td><td>顧客數量必須為整數</td></tr><tr><td>資料連續</td><td>根據背景判斷資料是否有意義</td><td>產品出貨日期不能早於生產日期</td></tr><tr><td>資料結構</td><td>檢查資料是否符合規定的結構</td><td>網頁資料出現錯誤顯示</td></tr><tr><td>程式檢查</td><td>檢查程式在輸入期間是否出現前述錯誤</td><td>在某些輸入值可能出現異常</td></tr></tbody></table><h3 id="臨時表">臨時表</h3><p>在進行分析前，可以利用 <code>WITH</code> 子句建立臨時的表供之後的分析使用，類似把子查詢的表先建立出來的概念，而結束查詢之後它們會自動從資料庫中刪除。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WITH</span> table_name <span class="keyword">AS</span>(</span><br><span class="line">  <span class="keyword">SELECT</span></span><br><span class="line">    column_name(s)</span><br><span class="line">  <span class="keyword">FROM</span></span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line">  ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="詞彙">詞彙</h2><ol><li>Data aggregation (資料聚合): The process of gathering data from multiple sources and combining it into a single, summarized collection.</li><li>Subquery (子查詢): A SQL query that is nested inside a larger query</li><li>Temporary table (臨時表): A database table that is created and exists temporarily on a database server.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-4</title>
      <link href="/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/"/>
      <url>/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/</url>
      
        <content type="html"><![CDATA[<h1>Course 4 - Process Data from Dirty to Clean</h1><h2 id="簡介">簡介</h2><p>This is the fourth course in the Google Data Analytics Certificate. In this course, you’ll continue to build your understanding of data analytics and the concepts and tools that data analysts use in their work. You’ll learn how to check and clean your data using spreadsheets and SQL, as well as how to verify and report your data cleaning results.</p><h2 id="章節大綱">章節大綱</h2><ol><li>The importance of integrity<br>學習檢查資料完整性以及數據不足的處理方式，了解隨機抽樣對於避免抽樣偏差的重要性。</li><li>Clean data for more accurate insights<br>了解乾淨數據和髒數據之間的差異，練習清理試算表和其他工具中的資料。</li><li>Data cleaning with SQL<br>學習使用 SQL 中的查詢功能以及函數來清理和修改資料庫中的資料。</li><li>Verify and report on cleaning results<br>學習驗證資料是否乾淨並報告及記錄資料清理結果。</li><li>Optional: Add data to your resume<br>了解工作申請流程，並製作一份能突出優勢和相關經驗的履歷。</li><li>Course wrap-up<br>課程總結。</li></ol><h1>內容筆記</h1><h2 id="module-1-the-importance-of-integrity">Module 1 - The importance of integrity</h2><h3 id="資料完整性">資料完整性</h3><p>在開始任何分析之前，都必須先檢查數據是否有效、完整且乾淨，並且避免在操作過程中影響到資料的完整性，以下是幾個可能會有影響的操作：</p><table><thead><tr><th>操作<div style="width:100px"></th><th>解釋</th></tr></thead><tbody><tr><td>複製</td><td>在進行檢查以及標準化的過程時，如果僅是將原始資料複製一部分出來進行處理，可能導致原始資料還含有不合規範的資料，並導致兩份資料產出結果不同。</td></tr><tr><td>傳輸</td><td>資料在傳輸時可能會有傳輸不完全或是欄位錯誤等情況，影響資料完整。</td></tr><tr><td>編輯</td><td>在進行編輯資料時如果有誤刪的情況，必須及時恢復，避免導致資料不完整。</td></tr></tbody></table><h3 id="資料問題的處理">資料問題的處理</h3><ol><li>無數據：<ul><li>先小規模地蒐集數據進行初步分析，並在蒐集更多資料後請求額外時間進行更深入的分析。</li><li>使用其他類似資料集中的資料 (擁有類似的條件、特性)</li></ul></li><li>數據量少：<ul><li>使用替代數據進行分析</li><li>調整分析範圍以符合現有數據</li></ul></li><li>數據錯誤：<ul><li>嘗試修正資料中的錯誤</li><li>如果樣本數夠多且刪除該數據影響較小，可以直接忽略</li></ul></li></ol><h3 id="樣本量與相關名詞">樣本量與相關名詞</h3><ol><li>Population (母體)：要研究的整體對象。</li><li>Sample (樣本)：用於代表母體的子集合。</li><li>Confidence level (置信度)：特定個體對於特定命題真實性相信的程度。</li><li>Confidence interval (信賴區間)：在某一置信水平下，樣本統計值允許的範圍。信賴區間越大，置信水平越高。</li><li>Margin of error (誤差範圍)：樣本統計值與總體參數值之間的最大誤差，也可以視為是信賴區間的半徑。</li><li>Statistical power (檢定力)：正確拒絕「錯誤的虛無假設」的機率；獲得有意義結果的機率。</li></ol><ul><li>已知母體、誤差範圍以及置信度 → 可以計算最少所需樣本數</li><li>已知母體、樣本量以及置信度 → 可以計算誤差範圍</li></ul><h2 id="module-2-clean-data-for-more-accurate-insights">Module 2 - Clean data for more accurate insights</h2><h3 id="髒數據的類型">髒數據的類型</h3><table><thead><tr><th>類型</th><th>解釋</th></tr></thead><tbody><tr><td>重複數據</td><td>輸入或匯入數據時產生多次出現的紀錄</td></tr><tr><td>過時數據</td><td>因為人員變動或是系統老舊導致資料過舊</td></tr><tr><td>不完整數據</td><td>資料蒐集不當或是輸入錯誤導致缺少部分內容</td></tr><tr><td>不正確數據</td><td>完整但是不正確的數據，可能是虛構或是模擬的數據</td></tr><tr><td>不一致數據</td><td>資料的格式混亂</td></tr></tbody></table><h3 id="試算表清理資料-內建功能">試算表清理資料 - 內建功能</h3><ol><li>條件式格式<br>全選資料，點擊 <code>格式 &gt; 條件式格式設定</code>，可以將空白內容以指定的格式表示，方便檢查。</li></ol><img src="/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/Conditional-formatting.png" class="" title="條件式格式"><ol start="2"><li>刪除重複內容<br>全選資料，點擊 <code>資料 &gt; 資料清除 &gt; 移除重複內容</code>，如果選取有包含標題的話記得勾選 <code>資料包含標題列</code>，之後選擇要分析的欄位，如果兩列資料在勾選的欄位值都相同的話則會清除。</li></ol><img src="/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/Remove-duplicates.png" class="" title="刪除重複"><ol start="3"><li>資料透視表<br>全選資料，點擊 <code>插入 &gt; 資料透視表</code>，接著就可以在新分頁使用資料透視表，可以在其中檢查各欄、列，或是進行加總、排序等檢查數據。</li></ol><img src="/2024/07/02/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-4/Pivot-tables.png" class="" title="資料透視表"><h3 id="試算表清理資料-函數">試算表清理資料 - 函數</h3><ol><li>SPLIT(文字, 分隔符號, [逐個分割], [移除空白文字])<br>可以將文字依照分隔符號分割並且儲存，注意使用時要確保有足夠空間，否則會回傳錯誤，常用於分割日期與時間。</li></ol><ul><li>逐個分割：預設為 TRUE，代表當分隔符號長度為 2 以上時，會將每個字元都作為分隔，否則將其當為單一個分隔條件。不過分隔符號通常只會使用單一字元，故不常使用。</li><li>移除空白文字：預設為 TRUE，將連續分隔符號視為一個分隔符號，否則會在兩個符號之間加入空白儲存格值。</li></ul><ol start="2"><li>COUNTIF(範圍, 條件)<br>計算範圍內符合條件的儲存格數量。</li></ol><ul><li>注意條件的部分要用 <code>&quot;&quot;</code> 包起來，如果裡面沒有輸入東西則會計算空格數量。</li><li>如果要篩選的內容為文字，可以用萬用字元 <code>?</code> 代表單一字元以及 <code>*</code> 代表多個字元，如果要比對實際的 <code>?</code> 以及 <code>*</code>，則要在前面加上 <code>~</code>。</li></ul><ol start="3"><li><p>LEN(文本)<br>回傳字串的長度。</p></li><li><p>LEFT(字串, 字元數) / RIGHT(字串, 字元數)<br>傳回指定字串開頭 / 倒數幾個字元構成的子字串。</p></li><li><p>MID(字串, 起點, 擷取長度)<br>傳回字串的特定區段。</p></li><li><p>CONCATENATE(字串1, [字串2, …])<br>將多個字串連接在一起。</p></li><li><p>TRIM(字串)<br>移除文字開頭、結尾和重複的空格。</p></li></ol><h2 id="module-3-data-cleaning-with-sql">Module 3 - Data cleaning with SQL</h2><h3 id="資料清理常用-sql-功能">資料清理常用 SQL 功能</h3><ol><li>SELECT DISTINCT <code>column1</code>, <code>column2</code>, …<br>只顯示欄位中不同的值。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="keyword">DISTINCT</span> Country </span><br><span class="line"><span class="keyword">FROM</span> Customers;</span><br></pre></td></tr></table></figure><ol start="2"><li>MIN(<code>column_name</code>) / MAX(<code>column_name</code>)<br>回傳欄位中的最大 / 最小值。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">  <span class="built_in">MIN</span>(Price),</span><br><span class="line">  <span class="built_in">MAX</span>(Price)</span><br><span class="line"><span class="keyword">FROM</span> Products;</span><br></pre></td></tr></table></figure><ol start="3"><li>WHERE <code>column_name</code> IS NULL;<br>尋找欄位內缺少資料的列。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">  <span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">  your project name.cars.car_info </span><br><span class="line"><span class="keyword">WHERE</span> </span><br><span class="line">  num_of_doors <span class="keyword">IS</span> <span class="keyword">NULL</span>;</span><br></pre></td></tr></table></figure><ol start="4"><li>更新資料 (BigQuery 沙盒版不支援)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line">  table_name <span class="comment">--資料所在的 table</span></span><br><span class="line"><span class="keyword">SET</span></span><br><span class="line">  column1 <span class="operator">=</span> value1, column2 <span class="operator">=</span> value2, ... <span class="comment">--更新的值</span></span><br><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">  <span class="keyword">condition</span> <span class="comment">--篩選要更新的列</span></span><br></pre></td></tr></table></figure><ol start="5"><li>插入資料 (BigQuery 沙盒版不支援)</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span></span><br><span class="line">  table_name (column1, column2, column3, ...) <span class="comment">--資料所在的 table 以及行名稱</span></span><br><span class="line"><span class="keyword">VALUES</span></span><br><span class="line">  (value1, value2, value3, ...) <span class="comment">--各行對應的資料</span></span><br></pre></td></tr></table></figure><ol start="6"><li><p>LENGTH(string)<br>回傳字串長度。</p></li><li><p>SUBSTR(<code>string</code>, <code>start</code>, <code>length</code>)<br>回傳子字串。</p></li><li><p>TRIM(<code>string</code>)<br>刪除字串頭尾的所有空格。</p></li><li><p>CAST(<code>value1</code> AS <code>data_type</code> [(<code>length</code>)])<br>將值轉換成另一種資料類型。</p></li><li><p>CONCAT(<code>string1</code> , <code>string2</code>, …)<br>傳回串連所有字串值所產生的字串。</p></li><li><p>COALESCE(<code>value1</code>, <code>value2</code>, …)<br>傳回第一個非 <code>NULL</code> 的值。</p></li><li><p>類似 if else 語法<br>根據條件決定回傳的值。</p></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">  <span class="keyword">WHEN</span> condition1 <span class="keyword">THEN</span> result1</span><br><span class="line">  <span class="keyword">WHEN</span> condition2 <span class="keyword">THEN</span> result2</span><br><span class="line">  <span class="keyword">WHEN</span> conditionN <span class="keyword">THEN</span> resultN</span><br><span class="line">  <span class="keyword">ELSE</span> <span class="keyword">result</span></span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h2 id="module-4-verify-and-report-on-cleaning-results">Module 4 - Verify and report on cleaning results</h2><h3 id="變更日誌">變更日誌</h3><p>變更日誌可以幫助我們追蹤資料的改變和清理，建議使用固定格式方便管理，而變更日誌通常會包含這些內容：</p><ul><li>修改的文件與修改內容</li><li>變更日期</li><li>進行變更的人</li><li>批准變更的人</li><li>版本號</li><li>變更原因</li></ul><h2 id="詞彙">詞彙</h2><ol><li>Changelog (變更日誌): A file containing a chronologically ordered list of modifications made to a project.</li><li>Filtering (篩選): The process of showing only the data that meets a specified criteria while hiding the rest.</li><li>Syntax (句法): The predetermined structure of a language that includes all required words, symbols, and punctuation, as well as their proper placement.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-3</title>
      <link href="/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/"/>
      <url>/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/</url>
      
        <content type="html"><![CDATA[<h1>Course 3 - Prepare Data for Exploration</h1><h2 id="簡介">簡介</h2><p>This is the third course in the Google Data Analytics Certificate. As you continue to build on your understanding of the topics from the first two courses, you’ll be introduced to new topics that will help you gain practical data analytics skills. You’ll learn how to use tools like spreadsheets and SQL to extract and make use of the right data for your objectives, and how to organize and protect your data.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Data types and structures<br>學習數據是如何產生的以及分析師挑選數據，並且了解結構化和非結構化資料、資料類型和資料格式</li><li>Data responsibility<br>學習識別數據偏差並確保數據是公正且可信的，了解開放資料、資料道德和資料隱私的重要性。</li><li>Database essentials<br>學習如何提取、過濾和排序資料庫內的資料。</li><li>Organize and protect data<br>學習組織資料以及確保資料安全，並學習如何有規律地命名文件。</li><li>Engage in the data community<br>探索如何利用 LinkedIn 管理線上形象，並且與其他數據分析師交流學習。</li></ol><h1>內容筆記</h1><h2 id="module-1-data-types-and-structures">Module 1 - Data types and structures</h2><h3 id="資料格式">資料格式</h3><ol><li>主要 &amp; 輔助數據</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>主要數據</td><td>研究人員蒐集的一手資料</td><td>親自訪談、蒐集問卷得到的數據</td></tr><tr><td>輔助數據</td><td>其他人或是其他研究蒐集的數據</td><td>從其他公司購買的數據、政府數據</td></tr></tbody></table><ol start="2"><li>內部 &amp; 外部數據</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>內部數據</td><td>儲存在公司內部的數據</td><td>不同部門的薪資數據、商品銷售統計</td></tr><tr><td>外部數據</td><td>儲存在公司外部的數據</td><td>全國平均薪資、人口普查資料</td></tr></tbody></table><ol start="3"><li>連續 &amp; 離散數據</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>連續數據</td><td>數據幾乎可以是任何數值</td><td>身高、氣溫</td></tr><tr><td>離散數據</td><td>數據是可計量或有限的數值</td><td>員工人數、設備數量</td></tr></tbody></table><ol start="4"><li>定性 &amp; 定量數據</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>定性數據</td><td>對品質或特徵的主觀和解釋性衡量</td><td>運動偏好、時尚趨勢</td></tr><tr><td>定量數據</td><td>具體且客觀的衡量標準，例如數量或範圍</td><td>物種數量、通勤時間</td></tr></tbody></table><ol start="5"><li>名目 &amp; 序數數據<br>英文為 Nominal &amp; ordinal data，也有人翻為定類 &amp; 定序數據，且這兩種數據都屬於定性數據。</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>名目數據</td><td>沒有固定順序進行分類</td><td>新顧客、回頭客、老顧客 (彼此之間沒有排序關係)</td></tr><tr><td>序數數據</td><td>有設定順序或範圍的數據</td><td>電影評分、滿意度分級</td></tr></tbody></table><ol start="6"><li>結構化 &amp; 非結構化數據</li></ol><table><thead><tr><th>分類</th><th>解釋</th><th>例子</th></tr></thead><tbody><tr><td>結構化數據</td><td>以某種格式組織的數據，例如行和列</td><td>報稅紀錄、門市庫存</td></tr><tr><td>非結構化數據</td><td>無法在資料庫中儲存為行和列的資料</td><td>影片、社交媒體貼文</td></tr></tbody></table><img src="/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/Structured&Unstructured-data.png" class="" title="結構化與非結構化數據"><h3 id="長資料與寬資料">長資料與寬資料</h3><table><thead><tr><th>長資料</th><th>寬資料</th></tr></thead><tbody><tr><td>每列只有一個觀察值</td><td>每列有多個觀察值</td></tr><tr><td>適合建立少量變數的圖表</td><td>適合儲存大量變數</td></tr><tr><td>使用簡單的折線圖</td><td>進行進階的分析與繪圖</td></tr></tbody></table><p>長資料範例</p><img src="/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/long-data.png" class="" title="長資料"><p>寬資料範例</p><img src="/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/wide-data.png" class="" title="寬資料"><h2 id="module-2-data-responsibility">Module 2 - Data responsibility</h2><h3 id="數據偏差">數據偏差</h3><table><thead><tr><th>類型</th><th>解釋</th></tr></thead><tbody><tr><td>採樣偏差</td><td>採集的部分樣本不足以代表整體</td></tr><tr><td>觀察者偏差</td><td>不同的觀察者可能觀察到不同的結果</td></tr><tr><td>解釋偏差</td><td>因為不同的背景經驗導致模稜兩可的內容有不同的解釋</td></tr><tr><td>確認偏差</td><td>選擇性的解釋內容得到自己偏向的結果，而忽略了其他數據</td></tr></tbody></table><h3 id="資料的可靠性-roccc">資料的可靠性 - ROCCC</h3><table><thead><tr><th>流程</th><th>解釋</th></tr></thead><tbody><tr><td>Reliable</td><td>使用經過審查完整且公正的資料</td></tr><tr><td>Original</td><td>確保資料是原創的</td></tr><tr><td>Comprehensive</td><td>資料包含問題所需的多個面向</td></tr><tr><td>Current</td><td>盡可能使用最新的資料</td></tr><tr><td>Cited</td><td>引用來自可信的組織的資料</td></tr></tbody></table><h3 id="資料匿名化">資料匿名化</h3><p>透過消除個人識別資訊 (PII,Personally identifiable information) 來保護人們的私人或敏感資料的過程，通常包含清空、雜湊或屏蔽個人訊息等過程，使用固定長度的編碼來表示，或直接隱藏該資料。</p><p>常見需要匿名化的資料：</p><ul><li>電話號碼</li><li>名字</li><li>車牌</li><li>IP 位址</li><li>病例</li><li>帳號 … 等</li></ul><h3 id="開放資料">開放資料</h3><p>常見的開放資料包含政府以及 Google 等大公司提供的數據集，而開放資料必須滿足以下三個標準：</p><ul><li>完整的數據集向公眾提供和訪問。</li><li>有允許重複使用和分發的條款。</li><li>任何人都可以重複使用和分發資料。</li></ul><h2 id="module-3-database-essentials">Module 3 - Database essentials</h2><h3 id="關聯式資料庫">關聯式資料庫</h3><p>關係資料庫包含一系列可以連接以形成關係的表，其中的表格透過它們共有的欄位連接，接下來將簡介幾個關係資料庫中常提到的鍵。</p><p>主鍵 (primary key) 是欄位的標識符，其中每個值都是唯一的，用於標識該表中的每筆記錄，如果 customer_id 是客戶表的主鍵，則任何兩個客戶都不會具有相同的 customer_id。</p><p>主鍵也可以使用表格的多個欄位組成，稱為複合鍵 (composite key)，如果 customer_id 和 location_id 是客戶表的複合鍵的兩個欄，則這些欄位的值在整個表中必須是唯一的。</p><p>外鍵 (foreign key) 是一個表中的欄位，同時也是另一個表中的主鍵，一張表只能有一個主鍵，但可以有多個外鍵，這些鍵在關聯式資料庫中的表之間建立關係。</p><img src="/2024/06/30/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-3/Relational-databases.png" class="" title="關聯式資料庫"><h3 id="後設資料-metadata">後設資料 (metadata)</h3><p>又稱為元數據，簡單來說就是一個資料的資料，主要包含幾個元素：</p><ul><li>文件類型</li><li>創建時間和創建者</li><li>標題和描述</li><li>標籤和分類</li><li>最後修改時間與修改者</li><li>誰擁有存取、修改權限</li></ul><h3 id="更多-sql-語法">更多 SQL 語法</h3><ol><li>BETWEEN <code>value1</code> AND <code>value2</code><br>挑選出指定範圍的資料。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BETWEEN</span> <span class="number">20</span> <span class="keyword">AND</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><ol start="2"><li>ORDER BY <code>col1</code>, <code>col2</code>, …<br>以指定欄位進行排序，預設為升序排序。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Price</span><br></pre></td></tr></table></figure><p>如果想要以降序排序，可以在後面加上 <code>DESC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Price <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure><ol start="3"><li>LIMIT <code>number</code><br>僅顯示指定數量的資料。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LIMIT <span class="number">15</span></span><br></pre></td></tr></table></figure><h2 id="module-4-organize-and-protect-data">Module 4 - Organize and protect data</h2><h3 id="如何命名文件">如何命名文件</h3><p>良好的文件命名可以讓使用者更快了解文件的內容，建議保持命名風格和順序一致，並且包含以下幾點：</p><ul><li>項目名稱</li><li>文件創建日期</li><li>修訂版本號</li></ul><p>例如： SalesReport_20231125_v02</p><h3 id="安全性與分析的平衡">安全性與分析的平衡</h3><p>資料安全是透過採取適當的安全措施來保護資料免遭未經授權的存取或損壞，而資料分析師必須找到一種方法來平衡資料安全性與實際分析需求，以便能夠做出有意義且及時的觀察又不會影響到資料的安全性，常見的有兩種方式：</p><ul><li><p>加密<br>使用獨特的演算法來更改數據，並使不知道該演算法的用戶和應用程式無法使用數據，而擁有密鑰的人仍然可以使用原始資料。</p></li><li><p>令牌化<br>將想要保護的資料替換為隨機產生的數據 (令牌)，將原始資料儲存在單獨的位置並映射到令牌，即使資料被駭客攻擊，原始資料在單獨的位置仍然安全。</p></li></ul><p>除了以上兩種方法，版本控制也能幫助實現平衡，讓所有協作者能夠追蹤隨時間的變化，了解誰對文件進行了哪些更改、更改時間以及原因。</p><h2 id="詞彙">詞彙</h2><ol><li>Bias (偏見、偏差): A conscious or subconscious preference in favor of or against a person, group of people, or thing.</li><li>CSV (comma-separated values) file: A delimited text file that uses a comma to separate values.</li><li>Data ethics (資料倫理): Well-founded standards of right and wrong that dictate how data is collected,<br>shared, and used.</li><li>Data governance (資料治理): A process for ensuring the formal management of a company’s data assets.</li><li>Field (欄位): A single piece of information from a row or column of a spreadsheet; in a data table, typically a column in the table.</li><li>Metadata (後設資料、元數據): Data about data.</li><li>Record (紀錄?): A collection of related data in a data table, usually synonymous with row.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-2</title>
      <link href="/2024/06/28/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-2/"/>
      <url>/2024/06/28/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-2/</url>
      
        <content type="html"><![CDATA[<h1>Course 2 - Ask Questions to Make Data-Driven Decisions</h1><h2 id="簡介">簡介</h2><p>This is the second course in the Google Data Analytics Certificate. You’ll build on your understanding of the topics that were introduced in the first course of this certificate program. The material will help you learn how to ask effective questions, make data-driven decisions, and meet stakeholders’ needs.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Ask effective questions<br>在這個單元內學習如何進行有效的提問，良好的提問可以讓整個分析的流程變得更加順利。</li><li>Make data-driven decisions<br>本單元介紹數據如何去驅動的各種業務方面的決策，並且學習如何透過報告和儀表板有效地展現數據。</li><li>Spreadsheet magic<br>了解資料分析師為何選擇使用試算表、試算表的使用方式，以及利用結構化思維理解並解決問題。</li><li>Always remember the stakeholder<br>學習如何了解利害關係人的期望與需求，同時與合作團隊建立良好且清晰的溝通。</li></ol><h1>內容筆記</h1><h2 id="module-1-ask-effective-questions">Module 1 - Ask effective questions</h2><h3 id="資料分析的六個階段">資料分析的六個階段</h3><p>上一個課程有提到過資料分析的六個階段，在這邊又提了一次，詳細說明了如何透過問問題的方式去了解各個階段要做的事情。</p><div class="timeline "><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Ask</p></div></div><div class='timeline-item-content'><p>在這個階段應該做的事：</p><ul><li>定義要解決的問題</li><li>確保完全了解利害關係人的期望</li><li>專注於實際問題，避免任何干擾</li><li>與利害關係人合作並保持開放的溝通管道</li><li>結合背景觀察整體狀況</li></ul><p>問題：</p><ul><li>我的利害關係人說他們的問題是什麼?</li><li>既然已經確定了問題，那麼我該如何解決問題呢?</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Prepare</p></div></div><div class='timeline-item-content'><p>在此階段應該決定要收集哪些數據並且組織這些數據來解決問題，必須考慮的點有：</p><ul><li>以哪些指標 (metrics) 來衡量</li><li>以資料庫儲存數據</li><li>以安全措施來保護數據</li></ul><p>問題：</p><ul><li>我該如何想出問題的解決方案?</li><li>我需要進行哪些研究?</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Process</p></div></div><div class='timeline-item-content'><p>在這個階段需要清理數據以消除任何可能的錯誤、不準確或不一致，因此必須：</p><ul><li>使用試算表尋找錯誤的數據</li><li>使用 SQL 函數檢查多餘空格</li><li>刪除重複資料</li><li>盡可能檢查數據中的偏差</li></ul><p>問題：</p><ul><li>哪些錯誤或不準確的數據可能會影響我找出的答案？</li><li>如何清理資料以使我擁有的資訊更有一致性？</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Analyze</p></div></div><div class='timeline-item-content'><p>在此階段可以對資料進行排序和格式化，讓分析師可以更輕鬆地：</p><ul><li>執行計算</li><li>合併多個來源的數據</li><li>使用分析結果建立表格</li></ul><p>問題：</p><ul><li>我的數據告訴我什麼故事?</li><li>我的數據將如何幫助我解決這個問題?</li><li>誰需要我公司的產品或服務?什麼類型的人最有可能使用它?</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Share</p></div></div><div class='timeline-item-content'><p>在這個階段可能會透過圖表或儀表板等工具總結結果，向利害關係人展示你已經解決了他們的問題。</p><p>問題：</p><ul><li>如何使向利害關係人展示的內容吸引人且易於理解?</li><li>如果我是傾聽者，什麼東西可以幫助我理解?</li></ul></div></div><div class='timeline-item'><div class='timeline-item-title'><div class='item-circle'><p>Act</p></div></div><div class='timeline-item-content'><p>根據您的發現向您的利害關係人提供建議，讓他們能夠做出數據所驅動的決策。</p><p>問題：</p><ul><li>如何利用在 Share 階段收到的回饋來滿足利害關係人的需求和期望?</li></ul></div></div></div><h3 id="六個常見的問題類型">六個常見的問題類型</h3><table><thead><tr><th>類型<div style="width:100px"></th><th>範例 &amp; 說明</th></tr></thead><tbody><tr><td>預測</td><td>預測最佳廣告方法來吸引新客戶，我們可以利用過去的廣告的位置、媒體類型以及獲得的新客戶數量等數據來做預測。</td></tr><tr><td>分類</td><td>公司提高客戶滿意度也可以利用分類的方式，根據某些關鍵字或分數對客戶服務電話進行分類，幫助識別表現最好的客戶服務代表，或將行動與滿意度分數相關聯。</td></tr><tr><td>異常情況</td><td>以有監測健康狀況功能的智慧手錶公司為例，分析匯總健康數據非常重要，可以在某些數據趨勢不正常時發現並發出警報。</td></tr><tr><td>確認主題</td><td>與分類的問題類似，確定主題可以幫助優先考慮要改進的正確產品功能，主題主要是將分類所形成的類別進一步分組到更廣泛的主題。</td></tr><tr><td>發現關聯</td><td>以物流公司與另一家公司合作將貨物按時交付給客戶為例，透過分析運輸中心的等待時間的關聯，可以確定適當的時間修改，以增加準時交貨的數量。</td></tr><tr><td>尋找規律</td><td>以分析機器故障時間為例，假設透過分析維護數據發現定期維護延遲如果超過 15 天就會發生故障，就是發現了一個規律。</td></tr></tbody></table><h3 id="smart-questions">SMART questions</h3><table><thead><tr><th>提問</th><th>解釋</th></tr></thead><tbody><tr><td>Specific</td><td>問題具體嗎?是否能解決困難?能幫助你獲得大量信息嗎?</td></tr><tr><td>Measurable</td><td>問題的答案可以量化嗎?</td></tr><tr><td>Action-oriented</td><td>答案會提供能幫助制定計劃的資訊嗎?</td></tr><tr><td>Relevant</td><td>問題的答案和目標有關嗎?</td></tr><tr><td>Time-bound</td><td>問題與研究的時間有關嗎?</td></tr></tbody></table><p>利用這五個提問可以讓你提出高效的問題，讓之後的分析更加順利，這邊以人們在購買新車時會考慮的問題為例：</p><ul><li>Specific：這個問題是否聚焦在車子的特定功能?</li><li>Measurable：問題是否包含功能評分？</li><li>Action-oriented：問題是否會影響未來的功能?</li><li>Relevant：問題是否能找出影響車輛成交的因素?</li><li>Time-bound：問題是否驗證了最近三年的數據?</li></ul><p>透過以上的思考，我們可以提出以下幾個問題：</p><ul><li>從 1 到 10 評分，你認為四輪驅動對於汽車有多重要?並解釋原因。</li><li>你最希望在汽車擁有的前五項功能是什麼?</li><li>如果汽車是四輪驅動，是否會增加你的購買意願?</li></ul><div class="note warning no-icon flat"><p>避免提出的問題：</p><ul><li>引導性問題：這個產品太貴了，不是嗎?</li><li>封閉式問題：你對客戶試用滿意嗎?</li><li>模糊問題：這個工具適合你嗎?</li></ul></div><h2 id="module-2-make-data-driven-decisions">Module 2 - Make data-driven decisions</h2><h3 id="定性與定量數據">定性與定量數據</h3><img src="/2024/06/28/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-2/Qualitative&Quantitative-data.png" class="" title="說明"><p>資料分析師通常會在工作中使用這兩種類型的資料，定性 (Qualitative) 資料可以透過提供原因或更全面的解釋來幫助分析師更好地理解定量 (Quantitative) 資料，換句話說，定量資料通常告訴你什麼 (what)，而定性資料通常告訴你為什麼 (why)。</p><h3 id="大數據與小數據">大數據與小數據</h3><p>比較：</p><table><thead><tr><th>小數據</th><th>大數據</th></tr></thead><tbody><tr><td>由短的、明確定義的時間段內的資料集</td><td>較長時間段、較不具體的資料集</td></tr><tr><td>在試算表中組織和分析</td><td>保存在資料庫中以供查詢</td></tr><tr><td>被中小型企業使用</td><td>被大型組織使用</td></tr><tr><td>易於收集、儲存、管理和直覺表示</td><td>進行相同行為需要花費大量的精力</td></tr><tr><td>已經是適合分析的大小</td><td>需要分成較小的部分才能進行分析</td></tr></tbody></table><p>大數據的優點：</p><ul><li>成功分析後可以帶來許多好處，例如節省大量時間和金錢。</li><li>幫助企業了解當前的市場狀況，保持領先地位。</li><li>幫助公司追蹤客戶回饋，提供了改進方向。</li></ul><p>大數據的缺點：</p><ul><li>可能包含許多不重要或無關的資訊。</li><li>分析需要較長時間、效率較低。</li><li>數據不易獲得。</li><li>數據過多可能會導致不公平的演算法偏差。</li></ul><p>大數據中的 4 個 &quot; V &quot;：</p><table><thead><tr><th>特點</th><th>解釋</th></tr></thead><tbody><tr><td>Volume</td><td>資料量</td></tr><tr><td>Variety</td><td>資料種類</td></tr><tr><td>Velocity</td><td>數據處理速度</td></tr><tr><td>Veracity</td><td>數據的品質與可靠性</td></tr></tbody></table><h2 id="module-3-spreadsheet-magic">Module 3 - Spreadsheet magic</h2><h3 id="試算表裡的錯誤代碼">試算表裡的錯誤代碼</h3><table><thead><tr><th>錯誤</th><th>意義</th><th>說明 &amp; 舉例</th></tr></thead><tbody><tr><td>#DIV/0!</td><td>除以 0 或是空白儲存格</td><td>=B2/B3 (當 B3 為 0)</td></tr><tr><td>#ERROR!</td><td>輸入的內容無法解釋</td><td>=COUNT(B1:D1 C1:C10) (中間缺少了逗號)</td></tr><tr><td>#N/A</td><td>公式找不到數據</td><td>找不到引用的儲存格 (常發生於 VLOOKUP 等函數)</td></tr><tr><td>#NAME?</td><td>無法辨識公式或函數的名稱</td><td>名稱拼字錯誤</td></tr><tr><td>#NUM!</td><td>儲存格具有無效數值</td><td>=DATEDIF(A4, B4, “M”) (A4 的日期晚於 B4 的日期)</td></tr><tr><td>#REF!</td><td>引用了無效的儲存格</td><td>使用的儲存格位於已刪除的欄位中</td></tr><tr><td>#VALUE!</td><td>公式或引用單元格存在問題</td><td>需要進行額外的工作才能找到問題的根源</td></tr></tbody></table><h3 id="其他公式">其他公式</h3><ol><li>ISERROR(範圍)<br>如果儲存格會發生錯誤會返回 true 否則返回 false，可以利用其作為條件篩選出錯誤。</li><li>COUNTIF(範圍, 目標)<br>計算範圍內符合目標的儲存格數量。</li><li>VLOOKUP(目標, 範圍, 回傳欄位, 大約符合 (TRUE)或完全符合 (FALSE))<br>在範圍內找到目標之後回傳指定的目標欄位，詳細內容可以參考： <a href="https://meowmeowwantme.com/vlookup-ultimate-guide/">【EXCEL | VLOOKUP用法教學】5分鐘快速搞懂VLOOKUP函數</a>。</li></ol><h2 id="module-4-always-remember-the-stakeholder">Module 4 - Always remember the stakeholder</h2><h3 id="與利害關係人建立良好溝通">與利害關係人建立良好溝通</h3><ul><li>討論目標：利害關係人的需求通常是關於更大的專案或目標，嘗試詢問利害關係人想要什麼樣的結果，設定期望並且規劃下一步。</li><li>嘗試說不：假設一位主管有一個「高優先級」項目，需要數據來支持他們的假設，要求你在明天早上之前完成分析，如果你認為他們的假設尚未完整，或是有更好的分析方式、需要更多時間，這時可以勇敢地說不，並提出並詳細解釋你認為更好的方案。</li><li>為意外情況做規劃：在開始專案之前，列出潛在的障礙，並在預定時間表時預留一點時間處理問題。</li><li>了解你的專案：透過電子郵件或報告追蹤相關的信息，準備好回答相關的問題，了解你的專案如何與公司其他部門聯繫起來，並參與提供盡可能多的見解。</li><li>善用文字與視覺化：利用視覺化的方式可以幫助利害關係人更快的了解專案中的信息。</li><li>經常溝通：定期更新專案，利用日誌紀錄專案的歷程與困難，讓利害關係人可以隨時介入並查看進度。</li></ul><h3 id="與聽眾的溝通技巧">與聽眾的溝通技巧</h3><p>溝通也是資料分析師的必備技能，在與聽眾進行報告前可以先問自己以下四個問題，讓之後的報告更加有效率。</p><ul><li>誰是你的聽眾?</li><li>聽眾已經知道了什麼?</li><li>聽眾應該要知道什麼?</li><li>如何最好的傳達他們應該知道的信息。</li></ul><h2 id="詞彙">詞彙</h2><ol><li>Metric (指標): A single, quantifiable type of data that is used for measurement.</li><li>Structured thinking (結構化思考): The process of recognizing the current problem or situation, organizing available information, revealing gaps and opportunities, and identifying options.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Google資料分析課程筆記-1</title>
      <link href="/2024/06/26/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-1/"/>
      <url>/2024/06/26/Google%E8%B3%87%E6%96%99%E5%88%86%E6%9E%90%E8%AA%B2%E7%A8%8B%E7%AD%86%E8%A8%98-1/</url>
      
        <content type="html"><![CDATA[<h1>Course 1 - Foundations: Data, Data, Everywhere</h1><h2 id="簡介">簡介</h2><p>This is the first course in the Google Data Analytics Certificate. Organizations of all kinds need data analysts to help them improve their processes, identify opportunities and trends, launch new products, and make thoughtful decisions. In this course, you’ll be introduced to the world of data analytics through hands-on curriculum developed by Google. The material shared covers plenty of key data analytics.</p><h2 id="章節大綱">章節大綱</h2><ol><li>Introducing data analytics and analytical thinking<br>學習資料分析師如何使用各種工具和技能來為日常生活和商業中的決策提供資訊，並且簡單的介紹了本課程的期望。</li><li>The wonderful world of data<br>介紹與工作息息相關的資料生命週期以及資料分析過程，並且將其應用到實際的分析之中。</li><li>Set up your data analytics toolbox<br>簡介資料分析師工作中常見的試算表、SQL以及資料視覺化工具，並且利用範例來介紹其工作原理。</li><li>Become a fair and impactful data professional<br>簡介資料分析師在不同類型的企業中扮演的角色，以及 Google 資料分析證書對於未來求職的幫助。</li></ol><h1>內容筆記</h1><h2 id="module-1-introducing-data-analytics-and-analytical-thinking">Module 1 - Introducing data analytics and analytical thinking</h2><h3 id="資料分析的六個階段">資料分析的六個階段</h3><p>資料分析的流程主要可以分為六個步驟 ask、prepare、process、analyze、share、act，這邊將簡單介紹各個步驟。</p><table><thead><tr><th>階段</th><th>解釋</th></tr></thead><tbody><tr><td>Ask</td><td>透過提問來了解要解決的問題，並且充分了解利害關係人 (stakeholder) 的期望，要先了解整個問題才能進入之後的規劃步驟。</td></tr><tr><td>Prepare</td><td>對於專案的流程等細節進行規劃，並且蒐集相關資料，辨別其是否對於資料分析有幫助，在流程種也要確保決策以事實為依據，維持其公平、公正。</td></tr><tr><td>Process</td><td>處理前一步驟蒐集的資料 (清理、合併、刪除異常值…)，並且將其轉換為方便分析的格式。</td></tr><tr><td>Analyze</td><td>使用試算表、SQL等工具進行資料分析，以找出問題的解決方案。</td></tr><tr><td>Share</td><td>透過簡報或其他資料視覺化工具向決策者展示結果，而在這個階段所使用的媒體非常重要。常見以直覺呈現資料的工具包含 Google Sheets、Tableau 和 R 等。</td></tr><tr><td>Act</td><td>公司將資料分析的結果付諸行動，實施新的業務策略或者其他改變。</td></tr></tbody></table><h3 id="資料分析師的技能">資料分析師的技能</h3><table><thead><tr><th>技能</th><th>解釋</th></tr></thead><tbody><tr><td>Curiosity</td><td>可以使分析師以預期或意外的方式從數據中獲得更多資訊，幫助在提問階段獲取更多與目標相關的資料來源。</td></tr><tr><td>Understanding context</td><td>了解要分析的數據背景，可以幫助分析師縮小變數範圍，找到最有可能影響結果的變數，從而得出更有意義的見解。</td></tr><tr><td>Technical mindset</td><td>以系統化並且有邏輯的方式處理問題，將複雜問題分解成為方便處理的一個個小問題。</td></tr><tr><td>Data design</td><td>資料設計技能是技術思維的延伸，主要是關於資訊的組織方式，透過不同的組織資料方式來獲得結論，透過資料設計可以使分析變得更容易，得出更具有洞察力的結果。</td></tr><tr><td>Data strategy</td><td>資料策略主要聚焦於管理層面，管理資料分析中的人員、流程和工具，以及如何進行資源的分配以取得更好的結果。</td></tr></tbody></table><h2 id="module-2-the-wonderful-world-of-data">Module 2 - The wonderful world of data</h2><h3 id="資料的生命週期">資料的生命週期</h3><p>注意這邊的生命週期與前面的資料分析流程是不同的，不同的流程之間不能混用。</p><table><thead><tr><th>週期</th><th>解釋</th></tr></thead><tbody><tr><td>Plan</td><td>決定需要什麼類型的資料、如何管理資料、由誰負責。</td></tr><tr><td>Capture</td><td>蒐集或引入來自各種不同來源的數據。</td></tr><tr><td>Manage</td><td>關心和維護資料，確定其儲存方式以及用於儲存的工具。</td></tr><tr><td>Analyze</td><td>使用數據解決問題、做出決策並支援業務目標。</td></tr><tr><td>Archive</td><td>保存相關數據以供長期和未來參考。</td></tr><tr><td>Destroy</td><td>刪除資料以及任何共用副本。</td></tr></tbody></table><h3 id="常用資料分析工具">常用資料分析工具</h3><ol><li>Spreadsheets 試算表<br>常用的有 Microsoft Excel 和 Google Sheets，有以下幾個特點：</li></ol><ul><li>方便 收集、儲存、組織和分類資訊</li><li>識別出規律並整合資料。</li><li>以圖形和圖表進行資料視覺化。</li></ul><ol start="2"><li>Databases and query languages 資料庫與查詢語言<br>資料庫是儲存在電腦系統中的結構化資料的集合，常見的結構化查詢語言 (SQL) 程式包括 MySQL、Microsoft SQL Server 和 BigQuery，並且它們有以下特點：</li></ol><ul><li>允許分析師從資料庫中分離出特定訊息。</li><li>可以輕鬆地學習並理解對資料庫提出的請求。</li><li>允許分析師從資料庫中選擇、建立、新增或下載資料進行分析。</li></ul><ol start="3"><li>視覺化工具<br>圖形、地圖、表格、圖表等都是分析師常用的視覺化工具，而 Tableau 和 Looker 是兩種最常使用的視覺化工具，而這些工具具有以下特點：</li></ol><ul><li>將複雜的數字變成人們可以理解的圖表。</li><li>幫助利害關係人得出結論，從而做出明智的決策和有效的業務策略。</li><li>擁有多種功能：<ul><li>Tableau 擁有簡單的拖放功能可讓使用者在儀表板中建立互動式圖表。</li><li>Looker 可以與資料庫通信，讓資料直接產生視覺效果。</li></ul></li></ul><ol start="4"><li>工具比較</li></ol><table><thead><tr><th>試算表</th><th>資料庫</th></tr></thead><tbody><tr><td>透過軟體存取</td><td>使用查詢語言存取資料庫</td></tr><tr><td>行和列格式的結構化數據</td><td>使用規則和關係的結構化數據</td></tr><tr><td>提供對有限數量數據的訪問</td><td>提供對大量數據的訪問</td></tr><tr><td>手動數據輸入</td><td>嚴格一致的資料輸入</td></tr><tr><td>通常一次一個用戶</td><td>多用戶</td></tr><tr><td>由使用者控制</td><td>由資料庫管理系統控制</td></tr></tbody></table><h2 id="module-3-set-up-your-data-analytics-toolbox">Module 3 - Set up your data analytics toolbox</h2><h3 id="sql-查詢語法">SQL 查詢語法</h3><ol><li>SELECT<br>選擇要檢索的 columns (欄)，如果要取多個欄可以使用逗號隔開。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">customer_id,</span><br><span class="line">first_name,</span><br><span class="line">last_name</span><br></pre></td></tr></table></figure><p>而如果在 SELECT 後面加上一個 <code>*</code> 代表選擇表內的所有欄位，在較大的表中需要謹慎使用。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span></span><br></pre></td></tr></table></figure><ol start="2"><li>FROM<br>選擇資料所在的 table (表)，表示方法為 <code>dataset_name.table_name</code> (資料集名稱和表的名稱用一個點隔開)。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> customer_data.customer_name</span><br></pre></td></tr></table></figure><ol start="3"><li>WHERE<br>用來篩選資料的條件，和 SELECT 不同，條件之間可以用 AND、OR、NOT 等運算符連接，以表達想要使用的條件。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span></span><br><span class="line">customer_id <span class="operator">&gt;</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">AND</span> first_name <span class="operator">=</span> <span class="string">&#x27;Tony&#x27;</span></span><br><span class="line"><span class="keyword">AND</span> last_name <span class="operator">=</span> <span class="string">&#x27;Magnolia&#x27;</span></span><br></pre></td></tr></table></figure><p>如果要使用條件來篩選出特定的名字，我們可以這樣寫：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Chavez&#x27;</span></span><br></pre></td></tr></table></figure><p>但是如果要找到特定開頭的名字的話，必須使用 <code>LIKE</code> 來幫助篩選，範例中可以篩選出所有以 “Ch” 開頭的名字，而其中的 % 符號則代表一個或多個字元 (有的語言以 <code>*</code> 作為代表)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">WHERE</span> name <span class="keyword">LIKE</span> <span class="string">&#x27;Ch%&#x27;</span></span><br></pre></td></tr></table></figure><ol start="4"><li>註解<br>註解的寫法有兩種，分別是單行註解 --以及多行註解 /* */，可以讓程式更好理解。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 單行註解</span></span><br><span class="line"><span class="comment">/* 多行</span></span><br><span class="line"><span class="comment">註解*/</span></span><br></pre></td></tr></table></figure><ol start="5"><li>別名<br>在 SELECT 和 FROM 兩個區塊選擇資料範圍時，可以使用 <code>AS</code> 加上資料的別名，方便之後使用。</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> </span><br><span class="line">my_table_alias.actual_column_name <span class="keyword">AS</span> my_column_alias</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">actual_table_name <span class="keyword">AS</span> my_table_alias</span><br></pre></td></tr></table></figure><h2 id="module-4-become-a-fair-and-impactful-data-professional">Module 4 - Become a fair and impactful data professional</h2><h3 id="確保公平性">確保公平性</h3><p>資料專業人員有責任確保他們所做的分析是公平的，意味著確保分析不會產生甚至是加深偏見，如果分析不客觀，可能會產生誤導或有害的結論，而課程中提供了幾個策略以確保分析的公平性：</p><table><thead><tr><th>策略<div style="width:150px"></th><th>解釋</th></tr></thead><tbody><tr><td>考慮所有可用數據</td><td>資料分析時必須確定哪些資料對分析有用，而遇到某些與關注內容無關或與期望不符的數據時，不應該直接捨棄，才能使分析結果反映事實。</td></tr><tr><td>辨別周圍因素</td><td>之前有提到過了解背景是資料分析師的重要技能，對於分析的最終結論至關重要，因此與考慮所有可用數據類似，還必須了解可能影響分析結果的的周圍因素。</td></tr><tr><td>使用自我報告的數據</td><td>自我報告是一種資料收集技術，使用問卷或訪談等方式，讓參與者在無干擾的情況下提供有關自己的資訊，可以避免人們對他人的偏見。</td></tr><tr><td>善用&quot;過採樣&quot;</td><td>過採樣是增加總體中非主導群體樣本的過程，增加部分數據的採樣數量，增加資料的公平性。</td></tr><tr><td>確保資料始終公平</td><td>確保從專案的最初到分析出結果並採取行動時都是公平的，也代表資料在收集、清理、處理和分析都是在公平的情況下進行。</td></tr></tbody></table><h2 id="詞彙">詞彙</h2><ol><li>Attribute (屬性): A characteristic or quality of data used to label a column in a table.</li><li>Context (情境、背景): The condition in which something exists or happens.</li><li>Formula (公式): A set of instructions used to perform a calculation using the data in a spreadsheet.</li><li>Function (函數): A preset command that automatically performs a specified process or task using the data in a spreadsheet.</li><li>Gap analysis (差距分析): A method for examining and evaluating the current state of a process in order to identify opportunities for improvement in the future.</li><li>Oversampling (過採樣): The process of increasing the sample size of nondominant groups in a population. This can help you better represent them and address imbalanced datasets.</li><li>Self - reporting (自我報告): A data collection technique where participants provide information about themselves.</li><li>Stakeholders (利害關係人): People who invest time and resources into a project and are interested in its outcome.</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 線上課程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 資料分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-二分搜尋</title>
      <link href="/2024/06/16/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/"/>
      <url>/2024/06/16/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E4%BA%8C%E5%88%86%E6%90%9C%E5%B0%8B/</url>
      
        <content type="html"><![CDATA[<p>二分搜尋是一個比循序搜尋還要有效率的常用搜尋方式，主要邏輯為反覆將搜尋範圍減半直到找到目標為止，但是除了最基本的寫法之外還有另外兩種寫法，也有很多小細節是需要注意的。</p><h1>一點小細節</h1><h2 id="循環-終止條件">循環 &amp; 終止條件</h2><ol><li>left &lt;= right<br>當循環條件為 left &lt;= right 時，代表會在 left == right + 1 時結束，此時區間為空，代表可以直接回傳 -1 ，target 不在陣列之中。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2"><li>left &lt; right<br>當循環條件為 left &lt; right 時，代表會在 left == right 時結束，此時區間內還有一個元素，因此在最後必須檢查該元素是否為 target。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="comment">//相同</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target? left : <span class="number">-1</span>; <span class="comment">//判斷</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="mid-取值">mid 取值</h2><p>mid 在取值時有兩種寫法，分別為 (left + right) / 2 以及 (left + right + 1) / 2 ，這兩種寫法在陣列長度為奇數時會取到相同的值，但是在偶數時前者會取到中央偏左的值，後者則會取到偏右的值，以 nums.size() == 2 的陣列為例，前者會取到 index 為 0 的位置，後者取到 index 為 1 的位置。</p><p>不過這兩種寫法在一般的二分搜尋寫法中最後得到的結果會是相同的，因為二分搜尋的核心是將陣列分段縮小範圍，因此實際上不一定要取正中間的位置，但是等等介紹到的二分搜尋方式中會利用到，以避免死循環。</p><p>在處理陣列較長的問題時，因為 left + right 時可能會超過 int 的範圍，為了避免溢位問題，我們也會改變寫法，改為 left + (right - left) / 2 或是 left + (right - left + 1) / 2 ，分別對應到前面提到過的兩種取值。</p><h1>區間方式</h1><h2 id="直接法">直接法</h2><div class="note primary no-icon flat"><p>在區間中找到元素時直接回傳結果，退出循環代表目標不在陣列中。</p></div><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == target) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="排除法">排除法</h2><div class="note primary no-icon flat"><p>不斷排除目標不在的區間。</p></div><h3 id="type-1">Type 1</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>; <span class="comment">//注意</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="type-2">Type 2</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>; <span class="comment">//注意</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[left] == target? left : <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>觀察以上的兩種寫法可以發現，與直接法不同的是，程式不會去主動判斷 nums[mid] == target ，而是不斷的縮小範圍，直到區間只剩下一個數字，目的是使結束時 left == right 方便判斷。</p><p>而兩種方法的 mid 取值這時候就有不同之處了，這兩種取值方式可以避免在剩下兩個元素時的死循環，在使用時要特別注意。</p><h2 id="比較">比較</h2><p>直接法因為會在找到目標時直接跳出，因此適合非重複的陣列，否則其在重複陣列找到目標的位置不一定，而使用排除法的兩種方式則分別可以找到右邊界以及左邊界，適合處理較複雜的題目。</p><table><thead><tr><th>方法</th><th>直接法</th><th>排除法 Type 1</th><th>排除法 Type 2</th></tr></thead><tbody><tr><td>循環條件</td><td>left &lt;= right</td><td>left &lt; right</td><td>left &lt; right</td></tr><tr><td>mid 取值</td><td>皆可</td><td>(left + right + 1) / 2</td><td>(left + right) / 2</td></tr><tr><td>left 取值</td><td>mid + 1</td><td>mid</td><td>mid + 1</td></tr><tr><td>right 取值</td><td>mid - 1</td><td>mid - 1</td><td>mid</td></tr><tr><td>應用</td><td>非重複陣列</td><td>重複陣列右邊界</td><td>重複陣列左邊界</td></tr></tbody></table><h1>練習</h1><h2 id="leetcode-34-find-first-and-last-position-of-element-in-sorted-array"><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/description/">LeetCode 34. Find First and Last Position of Element in Sorted Array</a></h2><p>Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.</p><p>If target is not found in the array, return [-1, -1].</p><p>You must write an algorithm with O(log n) runtime complexity.</p><p>Example 1:<br>Input: nums = [5,7,7,8,8,10], target = 8<br>Output: [3,4]</p><p>Example 2:<br>Input: nums = [5,7,7,8,8,10], target = 6<br>Output: [-1,-1]</p><p>Example 3:<br>Input: nums = [], target = 0<br>Output: [-1,-1]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">searchRange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ans</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt; target) left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums[left] != target) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">else</span> ans[<span class="number">0</span>] = left;</span><br><span class="line">        </span><br><span class="line">        left = <span class="number">0</span>;</span><br><span class="line">        right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt; target) right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = mid;</span><br><span class="line">        &#125;</span><br><span class="line">        ans[<span class="number">1</span>] = left;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>透過排除法的兩種方式找到邊界。</p><h2 id="leetcode-852-peak-index-in-a-mountain-array"><a href="https://leetcode.com/problems/peak-index-in-a-mountain-array/description/">LeetCode 852. Peak Index in a Mountain Array</a></h2><p>You are given an integer mountain array arr of length n where the values increase to a peak element and then decrease.</p><p>Return the index of the peak element.</p><p>Your task is to solve it in O(log(n)) time complexity.</p><p>Example 1:<br>Input: arr = [0,1,0]<br>Output: 1</p><p>Example 2:<br>Input: arr = [0,2,1,0]<br>Output: 1</p><p>Example 3:<br>Input: arr = [0,10,5,2]<br>Output: 1</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peakIndexInMountainArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="type">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(arr[mid] &gt; arr[mid + <span class="number">1</span>]) right = mid;</span><br><span class="line">            <span class="keyword">else</span> left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 mountain array 的特性， peak element 的左邊有 arr[n] &lt; arr[n + 1] ；右邊則是 arr[n] &gt; arr[n + 1] ，因此可以透過二分搜尋的方式尋找 peak element。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> 陣列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-雙指針</title>
      <link href="/2024/06/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9B%99%E6%8C%87%E9%87%9D/"/>
      <url>/2024/06/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9B%99%E6%8C%87%E9%87%9D/</url>
      
        <content type="html"><![CDATA[<p>雙指針是在陣列處理時可以利用的技巧，利用兩個指針去做判斷或是構造出窗口幫助解題，根據兩個指針的特性可以分為對撞指針、快慢指針以及滑動窗口。</p><h1>對撞指針</h1><p>兩個指針在數列兩端，移動方向相反，向中間移動，通常終止條件為兩指針對撞 or 滿足題目需求，兩邊指針的移動條件則要視題目需求做判斷。</p><h2 id="leetcode-167-two-sum-ii-input-array-is-sorted"><a href="https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/description/">LeetCode 167. Two Sum II - Input Array Is Sorted</a></h2><p>Given a 1-indexed array of integers <code>numbers</code> that is already sorted in non-decreasing order, find two numbers such that they add up to a specific <code>target</code> number. Let these two numbers be <code>numbers[index1]</code> and <code>numbers[index2]</code> where <code>1 &lt;= index1 &lt; index2 &lt;= numbers.length</code>.</p><p>Return the indices of the two numbers, <code>index1</code> and <code>index2</code>, added by one as an integer array <code>[index1, index2]</code> of length 2.</p><p>The tests are generated such that there is exactly one solution. You may not use the same element twice.Your solution must use only constant extra space.</p><p>Example 1:<br>Input: numbers = [2,7,11,15], target = 9<br>Output: [1,2]</p><p>Example 2:<br>Input: numbers = [2,3,4], target = 6<br>Output: [1,3]</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; numbers, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = numbers.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[left] + numbers[right] &gt; target) right--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(numbers[left] + numbers[right] &lt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;left + <span class="number">1</span>, right + <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因為題目提供的數列已經經過排序，因此可以透過 left 和 right 指針代表的數字和來判斷是否做指針的移動，當總和小於 target 時，將 left 右移可以使總和變大；反之將 right 左移可以使總和變小，直到總和等於 target 時結束。</p><h2 id="leetcode-11-container-with-most-water"><a href="https://leetcode.com/problems/container-with-most-water/description/">LeetCode 11. Container With Most Water</a></h2><p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the i<sup>th</sup> line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p><p>Find two lines that together with the x-axis form a container, such that the container contains the most water.Return the maximum amount of water a container can store.</p><p>Example 1:</p><img src="/2024/06/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9B%99%E6%8C%87%E9%87%9D/question_11.jpg" class="" title="Example"><p>Input: height = [1,8,6,2,5,4,8,3,7]<br>Output: 49</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxArea</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = height.<span class="built_in">size</span>() - <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, (right -  left) * <span class="built_in">min</span>(height[left], height[right]));</span><br><span class="line">            <span class="keyword">if</span>(height[left] &lt; height[right]) left ++;</span><br><span class="line">            <span class="keyword">else</span> right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>容器的高度是由左右兩短較短的一邊決定，因此在移動左右指針時，若移動較長邊只有可能使容量變小 or 不變，為了要算出當前的最大容量，必須移動兩邊中較短者，並將容量與之前的最大值比較，直到兩指針相撞。</p><h1>快慢指針</h1><p>兩個指針初始位置相同，移動方向相同，但速度不同，通常終止條件為兩指針再次相遇 or 快指針移動至數列尾端，兩邊指針的移動條件則要視題目需求做判斷。</p><h2 id="leetcode-26-remove-duplicates-from-sorted-array"><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/description/">LeetCode 26. Remove Duplicates from Sorted Array</a></h2><p>Given an integer array <code>nums</code> sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in <code>nums</code>.</p><p>Consider the number of unique elements of <code>nums</code> to be <code>k</code>, to get accepted, you need to do the following things:</p><ol><li>Change the array <code>nums</code> such that the first <code>k</code> elements of <code>nums</code> contain the unique elements in the order they were present in <code>nums</code> initially. The remaining elements of <code>nums</code> are not important as well as the size of <code>nums</code>.</li><li>Return <code>k</code>.</li></ol><p>Example 1:<br>Input: nums = [1,1,2]<br>Output: 2, nums = [1,2,_]</p><p>Example 2:<br>Input: nums = [0,0,1,1,1,2,2,3,3,4]<br>Output: 5, nums = [0,1,2,3,4,<em>,</em>,<em>,</em>,_]</p><p>Solution 1:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[slow] != nums[fast])&#123;</span><br><span class="line">                slow++;</span><br><span class="line">                nums[slow] = nums[fast];</span><br><span class="line">            &#125;</span><br><span class="line">            fast++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>慢指針 slow 代表了未重複的數列的結尾，並利用快指針 fast 來遍歷整個數列，當快慢指針值不同時，代表該數字尚未加入未重複數列中，將其加入並且把 slow++，迴圈執行至快指針到達數列尾端。</p><p>Solution 2:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">set&lt;<span class="type">int</span>&gt; <span class="title">s</span><span class="params">(nums.begin(),nums.end())</span></span>;</span><br><span class="line">        <span class="built_in">copy</span>(s.<span class="built_in">begin</span>(),s.<span class="built_in">end</span>(),nums.<span class="built_in">begin</span>());</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>當然這題也可以直接用 set 不重複的特性來解決…</p><h2 id="leetcode-141-linked-list-cycle"><a href="https://leetcode.com/problems/linked-list-cycle/description/">LeetCode 141. Linked List Cycle</a></h2><p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p><p>There is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the <code>next</code> pointer. Internally, <code>pos</code> is used to denote the index of the node that tail’s <code>next</code> pointer is connected to. Note that <code>pos</code> is not passed as a parameter.</p><p>Return <code>true</code> if there is a cycle in the linked list. Otherwise, return <code>false</code>.</p><p>Example 1:</p><img src="/2024/06/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9B%99%E6%8C%87%E9%87%9D/question_141-1.png" class="" title="Example"><p>Input: head = [3,2,0,-4], pos = 1<br>Output: true</p><p>Example 2:</p><img src="/2024/06/10/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-%E9%9B%99%E6%8C%87%E9%87%9D/question_141-2.png" class="" title="Example"><p>Input: head = [1,2], pos = 0<br>Output: true</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        ListNode *fast = head, *slow = head;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(slow == fast) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>快指針一次動兩步，慢指針則只動一步，如果存在環則快指針一定會碰到慢指針，因此回傳 true，否則迴圈在快指針到達尾端時停止並回傳 false。</p><h1>滑動窗口</h1><p>兩個指針初始位置相同，移動方向相同，但移動條件不同 (一般為滿足條件時左指針向右，窗口縮小；不滿足時右指針向右，窗口擴大)，通常終止條件為右指針移動至數列尾端。</p><h2 id="leetcode-209-minimum-size-subarray-sum"><a href="https://leetcode.com/problems/minimum-size-subarray-sum/description/">LeetCode 209. Minimum Size Subarray Sum</a></h2><p>Given an array of positive integers <code>nums</code> and a positive integer <code>target</code>, return the minimal length of a subarray whose sum is greater than or equal to <code>target</code>. If there is no such subarray, return <code>0</code> instead.</p><p>Example 1:<br>Input: target = 7, nums = [2,3,1,2,4,3]<br>Output: 2</p><p>Example 2:<br>Input: target = 4, nums = [1,4,4]<br>Output: 1</p><p>Example 3:<br>Input: target = 11, nums = [1,1,1,1,1,1,1,1]<br>Output: 0</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, sum = <span class="number">0</span>, ans = <span class="number">100001</span>;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            sum += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(sum &gt;= target)&#123;</span><br><span class="line">                ans = <span class="built_in">min</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ans == <span class="number">100001</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>因為題目有限制原始陣列的大小，因此可以先令 ans 為大小上限 +1 ，之後利用滑動窗口的方式，每次滿足 sum &gt;= target 時做比較，最後如果 ans 和原始值相同，代表無法滿足條件，回傳 0。</p><h2 id="leetcode-904-fruit-into-baskets"><a href="https://leetcode.com/problems/fruit-into-baskets/description/">LeetCode 904. Fruit Into Baskets</a></h2><p>You are visiting a farm that has a single row of fruit trees arranged from left to right. The trees are represented by an integer array <code>fruits</code> where <code>fruits[i]</code> is the type of fruit the i<sup>th</sup> tree produces.</p><p>You want to collect as much fruit as possible. However, the owner has some strict rules that you must follow:</p><ol><li>You only have two baskets, and each basket can only hold a single type of fruit. There is no limit on the amount of fruit each basket can hold.</li><li>Starting from any tree of your choice, you must pick exactly one fruit from every tree (including the start tree) while moving to the right. The picked fruits must fit in one of your baskets.</li><li>Once you reach a tree with fruit that cannot fit in your baskets, you must stop.</li></ol><p>Given the integer array <code>fruits</code>, return the maximum number of fruits you can pick.</p><p>Example 1:<br>Input: fruits = [1,2,1]<br>Output: 3</p><p>Example 2:<br>Input: fruits = [0,1,2,2]<br>Output: 3</p><p>Example 3:<br>Input: fruits = [1,2,3,2,2]<br>Output: 4</p><p>Solution:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">totalFruit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; fruits)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; map;</span><br><span class="line">        <span class="keyword">while</span>(right &lt; fruits.<span class="built_in">size</span>())&#123;</span><br><span class="line">            map[fruits[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(map.<span class="built_in">size</span>() &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="type">int</span> fruit = fruits[left++];</span><br><span class="line">                <span class="keyword">if</span>((--map[fruit]) == <span class="number">0</span>) map.<span class="built_in">erase</span>(fruit);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, right - left + <span class="number">1</span>);</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>利用 unordered_map 來儲存窗口內水果的種類和數量，如果 size &gt; 2 代表超出數量，因此縮減窗口直到滿足條件，並且將水果數量與 ans 做比較。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> 陣列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-3</title>
      <link href="/2024/05/15/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-3/"/>
      <url>/2024/05/15/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-3/</url>
      
        <content type="html"><![CDATA[<h1>三維迷宮問題</h1><div class="note primary no-icon flat"><p>給定一個三維的迷宮，起點標示為 S ，終點標示為 E ，# 代表牆壁，. 表示道路，每次移動所需時間相同，計算出從起點到終點的最短時間。</p></div><p>其實就是二維迷宮的推廣而已，可以同樣用 DFS 解決，此時每次可前進的方向會有 6 個，分別為前、後、上、下、左、右，而判斷邊界時也要注意 x, y, z 都要判斷。因為題目必須判斷最短時間，因此要多加一個變數 dis 來儲存當前的最短步數。</p><p>部分程式碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//6個方向</span></span><br><span class="line"><span class="type">int</span> dir[<span class="number">6</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;,&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;,&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;&#125;,dis = <span class="number">30000</span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//判斷邊界函數</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> z, <span class="type">int</span> y, <span class="type">int</span> x)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> (<span class="number">0</span> &lt;= z &amp;&amp; z &lt; a &amp;&amp; <span class="number">0</span> &lt;= y &amp;&amp; y &lt; b &amp;&amp; <span class="number">0</span> &lt;= x &amp;&amp; x &lt; c);  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c, <span class="type">int</span> z, <span class="type">int</span> y, <span class="type">int</span> x, <span class="type">int</span> arr[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>], <span class="type">int</span> vis[<span class="number">30</span>][<span class="number">30</span>][<span class="number">30</span>],<span class="type">int</span> step)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">if</span>(arr[z][y][x] == <span class="string">&#x27;E&#x27;</span>)&#123;  </span><br><span class="line">        dis = <span class="built_in">min</span>(dis, step);  <span class="comment">//判斷是否為最短路徑</span></span><br><span class="line">        <span class="keyword">return</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    vis[z][y][x] = <span class="number">1</span>;  </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++)&#123;  </span><br><span class="line">        <span class="type">int</span> tz = z + dir[i][<span class="number">0</span>];  </span><br><span class="line">        <span class="type">int</span> ty = y + dir[i][<span class="number">1</span>];  </span><br><span class="line">        <span class="type">int</span> tx = x + dir[i][<span class="number">2</span>];  </span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(a, b, c, tz, ty, tx) &amp;&amp; vis[tz][ty][tx] == <span class="number">0</span> &amp;&amp; arr[tz][ty][tx] != <span class="string">&#x27;#&#x27;</span>)&#123;  </span><br><span class="line">            <span class="comment">//如果不是邊界或牆壁，且沒有 visit 過就進行 DFS</span></span><br><span class="line">            <span class="built_in">dfs</span>(a, b, c, tz, ty, tx, arr, vis, step + <span class="number">1</span>);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    vis[z][y][x] = <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>圖的最短路徑問題</h1><h2 id="單源最短路徑-single-source">單源最短路徑 (Single Source)</h2><p>確定起點，去求到其他點的最短路徑問題，根據邊的權重是否有負值必須選擇不同的演算法。</p><h3 id="權重非負-dijkstra-s-algorithm">權重非負 - Dijkstra’s Algorithm</h3><ol><li>建立陣列 vis，初始值為 0 ，儲存該點是否已經確定最小距離。</li><li>建立陣列 dis，dis[S] 為 0，其他點皆為無限，代表 S 到該點目前的最小距離。</li><li>建立陣列 parent，紀錄到該點最短路徑的父節點。</li><li>從 vis = 0 的點中挑選 dis 最小的點 M，檢查其相鄰節點 N，假設 N 到 M 距離為 k ，取 dis[M] = min(dis[M] ,dis[N] + k)，並將 vis[M] 標示為 1。</li><li>重複步驟 4 直到所有點皆被 visited。</li></ol><p>實作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假設該圖有 n 個節點，且所有節點連通，d[a][b] 儲存 a 到 b 的權重</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化陣列</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        vis[i] = <span class="number">0</span>;</span><br><span class="line">        dis[i] = <span class="number">1e9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    parent[S] = S;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="type">int</span> p, minDis = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[j] &lt; minDis)&#123;</span><br><span class="line">                p = j; <span class="comment">//紀錄距離最小點</span></span><br><span class="line">                minDis = dis[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        vis[p] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//檢查鄰近節點</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!vis[j] &amp;&amp; dis[p] + d[p][j] &lt; dis[j])&#123;</span><br><span class="line">                dis[j] = dis[p] + d[p][j];</span><br><span class="line">                parent[j] = p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要取得 S 到某點 P 的最短路徑，只要從 parent[P] 開始往回推直到 S 點。</p><h3 id="權重為負-bellman-ford-algorithm">權重為負 - Bellman-ford Algorithm</h3><ol><li>建立陣列 dis，dis[S] 為 0，其他點皆為無限，代表 S 到該點目前的最小距離。</li><li>建立陣列 parent，紀錄到該點最短路徑的父節點。</li><li>窮舉 S 到所有點 A 以及其鄰近點 B，假設 A 和 B 之間距離為 k，如果 dis[A] + k &lt; dis[B]，則進行 relax，設定 dis[B] = dis[A] + k。重複本步驟 (n - 1) 次，其中 n 為總結點數。</li><li>再次窮舉所有點進行檢查，如果可以 relax 代表存在負環。</li></ol><div class="note primary no-icon flat"><p>如果存在負環代表繞了該環一圈之後權重和為負數，只要一直繞圈就會使路徑長變短。</p></div><p>實作：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">relax</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//窮舉所有點</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="comment">//檢查是否能 relax</span></span><br><span class="line">            <span class="keyword">if</span> (dis[j] &gt; dis[i] + d[i][j])&#123;</span><br><span class="line">                dis[j] = dis[i] + d[i][j];</span><br><span class="line">                parent[j] = i;</span><br><span class="line">                updated = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回傳是否有進行 relax</span></span><br><span class="line">    <span class="keyword">return</span> updated;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">int</span> S)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化陣列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++) dis[i] = <span class="number">1e9</span>;</span><br><span class="line">    dis[S] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//進行 n - 1 次</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="comment">//如果無法 relax 則提前結束</span></span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">relax</span>()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//檢查負環</span></span><br><span class="line">    <span class="type">int</span> neg_cycle = <span class="built_in">relax</span>();</span><br><span class="line">    <span class="keyword">return</span> neg_cycle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="全域最短路徑-all-pairs">全域最短路徑 (All Pairs)</h2><p>也稱為多源最短路問題，用於求圖中所有的最短路徑。</p><h3 id="floyd-warshall-algorithm">Floyd–Warshall Algorithm</h3><p>窮舉所有節點 k ，將其作為中繼點，比較 dis[i][j] 和 dis[i][k] + dis[k][j] 的大小，如果經過 k 點會使距離更小則將其記錄下來。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">floyd_warshall</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//初始化陣列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            dis[i][j] = d[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        dis[i][i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//窮舉所有點 k 做為中間點</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">                dis[i][j] = <span class="built_in">min</span>(dis[i][j], dis[i][k] + dis[k][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意本演算法的時間複雜度為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> ，使用時須注意是否會超時。</p>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> DFS </tag>
            
            <tag> Graph </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>離散筆記-卡塔蘭數</title>
      <link href="/2024/05/12/%E9%9B%A2%E6%95%A3%E7%AD%86%E8%A8%98-%E5%8D%A1%E5%A1%94%E8%98%AD%E6%95%B8/"/>
      <url>/2024/05/12/%E9%9B%A2%E6%95%A3%E7%AD%86%E8%A8%98-%E5%8D%A1%E5%A1%94%E8%98%AD%E6%95%B8/</url>
      
        <content type="html"><![CDATA[<h1>卡塔蘭數 Catalan Number</h1><p>卡塔蘭數 (Catalan Number) 是組合數學中一個常在各種計數問題中出現的數列，數列的前幾項分別為：1, 1, 2, 5, 14, 42, 132, 429…</p><h1>定義公式</h1><div class="note primary no-icon flat"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mn>0</mn></msub><mo>=</mo><mn>1</mn><mo separator="true">,</mo><msub><mi>C</mi><mn>1</mn></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">C_0 = 1, C_1 = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p></div><p>一般項公式：</p><div class="note primary no-icon flat"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><mfrac><mn>1</mn><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></mfrac><msubsup><mi>C</mi><mi>n</mi><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mo>=</mo><msubsup><mi>C</mi><mi>n</mi><mrow><mn>2</mn><mi>n</mi></mrow></msubsup><mo>−</mo><msubsup><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow><mrow><mn>2</mn><mi>n</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">C_n = \frac{1}{n+1}C_{n}^{2n} = C_{n}^{2n} - C_{n-1}^{2n}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.2484389999999999em;vertical-align:-0.403331em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.403331em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.061108em;vertical-align:-0.247em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-2.4530000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.1205469999999997em;vertical-align:-0.30643899999999996em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999998em;"><span style="top:-2.451892em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.30643899999999996em;"><span></span></span></span></span></span></span></span></span></span></p></div><p>遞迴公式：</p><div class="note primary no-icon flat"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mi>n</mi></msubsup><msub><mi>C</mi><mi>i</mi></msub><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{n+1} = \sum_{i=0}^{n}C_{i}C_{n-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.891661em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span><br>or<br><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>C</mi><mi>n</mi></msub><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msub><mi>C</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub><msub><mi>C</mi><mrow><mi>n</mi><mo>−</mo><mi>i</mi></mrow></msub></mrow><annotation encoding="application/x-tex">C_{n} = \sum_{i=1}^{n}C_{i-1}C_{n-i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mbin mtight">−</span><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span></p></div><h1>應用</h1><h2 id="路徑問題">路徑問題</h2><p>在一個 n * n 的格點中，從左下角 (0, 0) 到右上角 (n, n)，每一步只能向右或向上，不穿越對角線的總路徑數。</p><p>n = 4 的情形：</p><img src="/2024/05/12/%E9%9B%A2%E6%95%A3%E7%AD%86%E8%A8%98-%E5%8D%A1%E5%A1%94%E8%98%AD%E6%95%B8/example1.png" class="" title="n&#x3D;4的情形"><h2 id="括號分配">括號分配</h2><p>有 a<sub>1</sub> , a<sub>2</sub> , …, a<sub>n</sub> , a<sub>n+1</sub> ，共 n + 1 個數，中間用 n 個減號隔開，在式子中添加 n - 1 個括號，最後形成的排列數。<br>n = 3 的情形：<br>((a<sub>1</sub> - a<sub>2</sub>) - a<sub>3</sub>) - a<sub>4</sub><br>(a<sub>1</sub> - (a<sub>2</sub> - a<sub>3</sub>)) - a<sub>4</sub><br>(a<sub>1</sub> - a<sub>2</sub>) - (a<sub>3</sub> - a<sub>4</sub>)<br>a<sub>1</sub> - ((a<sub>2</sub> - a<sub>3</sub>) - a<sub>4</sub>)<br>a<sub>1</sub> - (a<sub>2</sub> - (a<sub>3</sub> - a<sub>4</sub>))</p><div class="note primary no-icon flat"><p>首先從 1 到 n 選定一個減號的位置 k，此時會將式子分為前後兩邊，前面有 k - 1 個減號，後面有 n - k 個減號，而前後也可以透過類似的方式計算，因此總排列數可以表達為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \sum_{k=1}^{n}f(k-1)f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 也就是卡塔蘭數的遞迴形式。</p></div><h2 id="括號配對數">括號配對數</h2><p>有 n 組括號，其中每組括號包含 “(” 以及 “)” ，所形成的合法排列數。<br>n = 3 的情形：<br>( ( ( ) ) )<br>( ( ) ( ) )<br>( ( ) ) ( )<br>( ) ( ( ) )<br>( ) ( ) ( )</p><div class="note primary no-icon flat"><p>假設第一個左括號所對應到的右括號位置在 k，此時該括號內包含 k - 1 對括號，外面有 n - k 對括號，而內外的括號排列也可以透過類似的方式計算，因此總排列數可以表達為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \sum_{k=1}^{n}f(k-1)f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 同樣也是卡塔蘭數的遞迴形式。</p></div><h2 id="多邊形分割">多邊形分割</h2><p>有一個 n + 2 邊形，透過連接頂點，將其分割為 n 個三角形的所有可能 (旋轉視為相同分割法)。</p><div class="note primary no-icon flat"><p>首先選中其中一條邊，再選擇一個點之後就會形成一個三角形，共有 n 個頂點可以做選擇，假設選中了第 k 個點，此時三角形的左邊有 k + 1 個點，可以形成 k - 1 個三角形，右邊可以形成 n - k 個三角形，而左右的分割數也可以透過類似的方式計算，因此總分割數可以表達為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \sum_{k=1}^{n}f(k-1)f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 。</p></div><h2 id="二元樹">二元樹</h2><p>一個二元樹有 n 個節點，其所有可能的結構。<br>n = 3 的情形 (月牙形代表空節點)：</p><img src="/2024/05/12/%E9%9B%A2%E6%95%A3%E7%AD%86%E8%A8%98-%E5%8D%A1%E5%A1%94%E8%98%AD%E6%95%B8/example2.png" class="" title="n&#x3D;3的情形"><div class="note primary no-icon flat"><p>將所有節點由 1 ~ n 進行排序，選中其中一點 k 作為根結點，該點左右兩邊分別為左右子樹，此時左子樹包含 k - 1 個節點，右子樹有 n - k 個節點，總排列數可以表達為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo>=</mo><msubsup><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><mi>f</mi><mo stretchy="false">(</mo><mi>k</mi><mo>−</mo><mn>1</mn><mo stretchy="false">)</mo><mi>f</mi><mo stretchy="false">(</mo><mi>n</mi><mo>−</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">f(n) = \sum_{k=1}^{n}f(k-1)f(n-k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 。</p></div>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 離散 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-2</title>
      <link href="/2024/05/07/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-2/"/>
      <url>/2024/05/07/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-2/</url>
      
        <content type="html"><![CDATA[<h1>樹的遍歷</h1><h2 id="重建樹">重建樹</h2><div class="note primary no-icon flat"><p>根據給定原始樹的先序遍歷 (preorder traversal) 和中序遍歷 (inorder traversal)重構原始樹。</p></div><p>前序遍歷的順序為 [根結點、左子樹、右子樹]，而中序遍歷的順序為 [左子樹、根結點、右子樹]，因此我們可以透過前序遍歷的第一個元素找到根結點，將其帶入中序遍歷，就可以找到左、右子樹，對左、右子樹遞迴進行此行為就可以構造出原始樹，<br>函式程式碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(string preord, string inord, <span class="type">int</span> preord_left, <span class="type">int</span> preord_right, <span class="type">int</span> inord_left, <span class="type">int</span> inord_right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preord_left &gt; preord_right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//從前序遍歷中取得根結點</span></span><br><span class="line">    <span class="type">int</span> preord_root = preord_left;</span><br><span class="line">    <span class="comment">//找到根結點在中序遍歷中的位置</span></span><br><span class="line">    <span class="type">int</span> inord_root = inord.<span class="built_in">find</span>(preord[preord_root]); </span><br><span class="line"></span><br><span class="line">    <span class="comment">//構造根結點</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preord[preord_root]);</span><br><span class="line">    <span class="type">int</span> size_left_subtree = inord_root - inord_left;</span><br><span class="line">    <span class="comment">//構造左子樹</span></span><br><span class="line">    root-&gt;leftChild = <span class="built_in">BuildTree</span>(preord, inord, preord_left + <span class="number">1</span>, preord_left + size_left_subtree, inord_left, inord_root - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//構造右子樹</span></span><br><span class="line">    root-&gt;rightChild = <span class="built_in">BuildTree</span>(preord, inord, preord_left + size_left_subtree + <span class="number">1</span>, preord_right, inord_root + <span class="number">1</span>, inord_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二元搜尋樹">二元搜尋樹</h2><div class="note primary no-icon flat"><p>給定一棵二元搜尋樹 (binary search tree) 的先序遍歷 (preorder traversal)，重構出原始樹。</p></div><p>二元搜尋樹的特性：</p><ul><li>一個節點的左子樹只包含鍵值小於該節點的節點。</li><li>一個節點的右子樹只包含鍵值大於該節點的節點。</li><li>左子樹和右子樹也都是二分搜尋樹。</li></ul><p>因為有以上特性，在區分左、右子樹時不需要利用到原始樹的中序遍歷，只要在前序遍歷中找到鍵值大於根結點的地方就是右子樹了，之後也是利用遞迴的方式建構出原始樹。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">BuildTree</span><span class="params">(<span class="type">int</span> preord[], <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; right) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//從前序遍歷中取得根結點</span></span><br><span class="line">    <span class="type">int</span> preord_root = left;</span><br><span class="line">    <span class="type">int</span> size_left_subtree = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//找到右子樹在前序遍歷中的位置</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = left+<span class="number">1</span>; i &lt;= right; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(preord[i] &gt; preord[preord_root]) <span class="keyword">break</span>;</span><br><span class="line">        size_left_subtree++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//構造根結點</span></span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(preord[preord_root]);</span><br><span class="line">    <span class="comment">//構造左子樹</span></span><br><span class="line">    root-&gt;leftChild = <span class="built_in">BuildTree</span>(preord, left + <span class="number">1</span>, left + size_left_subtree);</span><br><span class="line">    <span class="comment">//構造右子樹</span></span><br><span class="line">    root-&gt;rightChild = <span class="built_in">BuildTree</span>(preord, left + size_left_subtree + <span class="number">1</span>, right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>最小生成樹</h1><h2 id="prim-s-algorithm">Prim’s algorithm</h2><ol><li>設定初始節點，將其加入最小生成樹中。</li><li>在包含已選中與未選中的邊 (一端選中一端未選中) 中尋找權重最小者，將其加入最小生成樹中。</li><li>重複步驟 2 直到所有點都在最小生成樹內。</li></ol><h2 id="kruskal-s-algorithm">Kruskal’s algorithm</h2><ol><li>將所有邊依照權重由小排到大。</li><li>選擇權重最小邊，加入最小生成樹中。</li><li>檢查最小生成樹是否形成 circle，如果有則刪除剛剛加入的邊。</li><li>重複步驟 2 3 直到所有邊都考慮完畢。</li></ol><h2 id="sollin-s-algorithm">Sollin’s algorithm</h2><ol><li>把每個點都當成一棵樹。</li><li>在所有樹中挑選出權重最小的邊。</li><li>如果有重複的邊只要保留一個，並且將選中的邊加入最小生成樹。</li><li>重複步驟 2 3 直到只剩下一顆樹 or 所有邊都已考慮完畢。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> Tree </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>演算法筆記-1</title>
      <link href="/2024/05/04/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-1/"/>
      <url>/2024/05/04/%E6%BC%94%E7%AE%97%E6%B3%95%E7%AD%86%E8%A8%98-1/</url>
      
        <content type="html"><![CDATA[<h1>最大子數列</h1><h2 id="非循環陣列">非循環陣列</h2><div class="note primary no-icon flat"><p>給定長度為 N 的整數陣列A，從 A 所有可能的 subarray 中找出一個 subarray S，使得 S 中所有元素的總和是最大值。</p></div><h3 id="kadane-s-algorithm">Kadane’s Algorithm</h3><p>循環遍歷整個陣列 A，在第 i 個元素時判斷 A[i] 和 cucursum + A[i] 的大小，判定在第 i 個元素時所能達到的最大值，之後將 cursum 與 maxsum 比較，取得子字串總和的最大值。</p><p>程式碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxsum = A[<span class="number">0</span>], cursum = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;  </span><br><span class="line">    cursum = <span class="built_in">max</span>(cursum + A[i], A[i]);  </span><br><span class="line">    maxsum = <span class="built_in">max</span>(maxsum, cursum);</span><br><span class="line">&#125;</span><br><span class="line">retuen maxsum;</span><br></pre></td></tr></table></figure><p>因為只要遍歷整個陣列一次，時間複雜度為 O(n)。</p><h2 id="循環陣列">循環陣列</h2><div class="note primary no-icon flat"><p>給定長度為 N 的 “循環” 整數陣列A，從 A 所有可能的 subarray 中找出一個 subarray S，使得 S 中所有元素的總和是最大值。</p></div><p>因為在尋找最大子數列時，可能會有數列跨越 A[N-1] 到 A[0] 的情況，這時候除了該數列之外，剩下的部分就可以利用之前的方式處理，找到最小子數列，那剩餘的部分就會是最大子數列，可以得到答案為 max(total - minsum, maxsum)，其中 total 為整個陣列總和。<br>另外必須考慮陣列元素全為負數時 total - minsum = 0，必須回傳 maxsum，也就是陣列元素中的最大值。<br>程式碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> maxsum = A[<span class="number">0</span>], cursum1 = <span class="number">0</span>, minsum = A[<span class="number">0</span>], cursum2 = <span class="number">0</span>, total = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; N; i++)&#123;  </span><br><span class="line">    total += m[i];  </span><br><span class="line">    cursum1 = <span class="built_in">max</span>(cursum1 + A[i], A[i]);  </span><br><span class="line">    maxsum = <span class="built_in">max</span>(maxsum, cursum1);  </span><br><span class="line">    cursum2 = <span class="built_in">min</span>(cursum2 + A[i], A[i]);  </span><br><span class="line">    minsum = <span class="built_in">min</span>(minsum, cursum2);  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">if</span>(total == minsum) retuen maxsum;</span><br><span class="line"><span class="keyword">else</span> retuen <span class="built_in">max</span>(total - minsum, maxsum);  </span><br></pre></td></tr></table></figure><p>判斷陣列元素是否全為負數的特例情況時，也可以透過 maxsum &lt; 0 來作為條件。</p><h1>數島嶼</h1><div class="note primary no-icon flat"><p>給定一個 M * N 的二維矩陣地圖，矩陣中的值只有 0 或 1，分別代表陸地和海洋。由多個相鄰的陸地水平或垂直連接而形成的區塊稱為一個島嶼，且陸地之間不能以斜向方式連接。請找出在地圖中所有島嶼的數量。</p></div><p>遍歷整個陣列，當遇到陸地時將島嶼數加一，進行 DFS 尋找鄰近的其他陸地，並且直接把該陸地炸沉 (1 改為 0) 避免再次訪問到。<br>DFS 函式程式碼：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">check</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> arr[<span class="number">300</span>][<span class="number">300</span>])</span></span>&#123;  </span><br><span class="line">    <span class="type">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;&#125;;  </span><br><span class="line">    <span class="keyword">if</span>(arr[x][y] == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">//判斷是否為陸地</span></span><br><span class="line">    <span class="keyword">else</span>&#123;  </span><br><span class="line">        arr[x][y] = <span class="number">0</span>; <span class="comment">//炸沉陸地</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;  </span><br><span class="line">            <span class="type">int</span> tx = x + dir[i][<span class="number">0</span>], ty = y + dir[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判斷邊界</span></span><br><span class="line">            <span class="keyword">if</span>(tx &gt;= <span class="number">0</span> &amp;&amp; tx &lt;= m<span class="number">-1</span> &amp;&amp; ty &gt;= <span class="number">0</span> &amp;&amp; ty &lt;= n<span class="number">-1</span>)&#123;  </span><br><span class="line">                <span class="built_in">check</span>(tx, ty, m, n, arr);  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 筆記 </category>
          
          <category> 資工 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 演算法 </tag>
            
            <tag> 陣列 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-Buff與物品總覽</title>
      <link href="/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/"/>
      <url>/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會功能plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a> ← 當前位置</li></ol></div><p>本文將介紹遊戲中的 Buff 以及物品，如果需要找尋物品請善用 Ctrl + F。</p><h1>Buff</h1><p>需要開始前有 Buff 才有效：</p><ul><li>突觸加速：減少掛機時間，最高可疊加至 80%。</li><li>校準增益：增加裝備校準的成功率，+n 車代表能以 0% 失敗讓裝備到 +n。</li><li>校準保護：校準失敗時破壞裝備。</li><li>RNG：開紫箱的傳奇和史詩掉率增加。</li><li>寵物領養：滿足需求的玩家可以領養寵物。</li></ul><p>需要結束時有 Buff 才有效：</p><ul><li>額葉：額葉皮質增強，最高80%，增加經驗獲取量。</li><li>BTC：交易漏洞，最高100%，影響從 NPC 獲得的 BTC 量。</li></ul><h1>物品總覽</h1><h2 id="物質類">物質類</h2><ul><li>AI核心 (AI)：用於部署掛機機器人升級，同時也是玩家之間最主要的交易貨幣。</li><li>AI核心集群 (AICC,CC)：由1000個AI核心組成，需要時可分解使用。</li><li>醫療科技零件 (MTP)：可用於製作醫療物品、壓碎。</li><li>醫療科技集群 (MTC)：由1000個醫療科技零件組成，需要時可分解使用。</li><li>彈藥零件 (ATP)：可用於製作能量電池、壓碎。</li><li>軍用彈藥零件 (MATP)：可用於製作反物質電池、壓碎。</li><li>科技碎片 (TS)：可用於製作背包、開箱子、提升分子等級。</li><li>科技集群 (TSC)：由1000個科技碎片組成，需要時可分解使用。</li><li>雜湊處理器 (hash)：用於挖礦獲得btc、製作AI。</li><li>裝備校準核心 (Cali Core)：用於校準裝備。</li><li>出廠重置碎片：將已校準裝備還原，讓裝備可以寄送或放到市集。</li><li>協議漏洞碎片 (PBS)：用於入侵香格里拉數據堡壘獲得buff。</li><li>加密容器類：可用科碎在終端機解鎖，內含隨機裝備或其他物品。<br>已加密容器 (LC)<br>稀有已加密容器 (LRC)<br>傳奇已加密容器 (LLC)</li><li>稀有裝備箱：可用科碎在終端機解鎖，內含隨機裝備或其他物品。</li><li>補給箱[公會] (GC)：用於收集公會資源、佔領。</li><li>已加密的公會記憶碎片 (EGMS)：可在公會內解密，獲得隨機裝備。</li><li>公會入侵指令發信器 (giot)：可用於開啟較高難度的入侵地城。</li><li>密鑰碎片：在地城中取得3個不同區域的密鑰碎片後，在終端機合成可以進入下個地區。</li><li>地城代幣：可以透過解任務 (黃色問號) 以及打死科技歹徒 (簡稱tt，撿地上的箱子有機率遇到)獲得，兩種獲取途徑都在地下城中，可以和裝備商人換取稀有裝備箱。</li></ul><h2 id="裝備類">裝備類</h2><div class="note primary no-icon flat"><p>詳細介紹可以看另一篇文章：<a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a>。</p></div><ul><li>快取記憶體 (cache)：可以在3D分子列印機製作出對應品質裝備，獲得的物品等級取決於分子等級。</li><li>武器類<br>主武器 (PW)<br>特殊武器 (SW)<br>破壞性武器 (DW)</li><li>防具類<br>頭盔 (helm)<br>上身裝甲 (upper)<br>下身裝甲 (lower)<br>靴子 (boots)</li><li>升級模組 (mod)：可以裝到武器上提升數值。</li><li>能量電池：特殊武器所需子彈，分解後可獲得彈藥零件，轉換比例為 20:1。</li><li>反物質電池：破壞性武器所需子彈，分解後可獲得軍用彈藥零件，轉換比例為 20:1。</li></ul><h2 id="醫療類">醫療類</h2><h3 id="單體醫療">單體醫療</h3><ul><li>止痛藥：最低階的單體醫療，僅能對玩家本人回血，分解後可得醫碎，轉換比例為 2:1。</li><li>所有單體醫療：</li></ul><table><thead><tr><th>物品</th><th>補血量</th><th>補血量/成本醫碎量</th></tr></thead><tbody><tr><td>止痛藥</td><td>501</td><td>500</td></tr><tr><td>舊式奈米修復機器人</td><td>1201</td><td>120</td></tr><tr><td>舊式奈米醫療機器人</td><td>6001</td><td>450</td></tr><tr><td>奈米醫療機器人</td><td>12001</td><td>600</td></tr><tr><td>軍用奈米醫療機器人</td><td>26001</td><td>812</td></tr><tr><td>進階奈米醫療機器人</td><td>54001</td><td>1012</td></tr><tr><td>高級奈米醫療機器人</td><td>110001</td><td>1203</td></tr><tr><td>稀有奈米醫療機器人</td><td>240001</td><td>1500</td></tr><tr><td>傳奇奈米醫療機器人</td><td>480001</td><td>1500</td></tr><tr><td>史詩奈米醫療機器人</td><td>1000001</td><td>3125</td></tr></tbody></table><h3 id="群體醫療">群體醫療</h3><ul><li>止痛噴劑：最低階的群體醫療，能讓地城內所有玩家回血。</li><li>所有群體醫療：</li></ul><table><thead><tr><th>物品</th><th>補血量</th></tr></thead><tbody><tr><td>止痛噴劑</td><td>301</td></tr><tr><td>舊式修復無人機</td><td>901</td></tr><tr><td>舊式奈米醫療無人機</td><td>4001</td></tr><tr><td>奈米醫療無人機</td><td>10001</td></tr><tr><td>軍用奈米醫療無人機</td><td>20001</td></tr><tr><td>進階奈米醫療無人機</td><td>40001</td></tr><tr><td>高級奈米醫療無人機</td><td>80001</td></tr><tr><td>稀有奈米醫療無人機</td><td>160001</td></tr><tr><td>傳奇奈米醫療無人機</td><td>320001</td></tr><tr><td>史詩奈米醫療無人機</td><td>640001</td></tr></tbody></table><h2 id="背包類">背包類</h2><ul><li>老舊袋子 (OP)：由 100 科碎合成，裝備後增加4格背包容量。</li><li>腰包 (Fanny)：由 10 老舊袋子合成，裝備後增加8格背包容量。</li><li>探險家背包 (Dora)：由 15 腰包合成，裝備後增加16格背包容量。</li><li>公事包 (EOC)：由 20 探險家背包合成，裝備後增加32格背包容量。</li><li>自主儲存單位 (ASU)：由 25 公事包合成，裝備後增加64格背包容量。</li></ul><h2 id="增益類">增益類</h2><h3 id="個人增益">個人增益</h3><ul><li>錄音帶：增加攻擊、防禦20%，持續10分鐘。</li><li>校準AI碎片(5%)：提供校準增益 5 分鐘。</li><li>網路隧道 VPN：忽略任何聊天漏洞1小時。</li></ul><h3 id="全服增益">全服增益</h3><ul><li>校準AI碎片(10%↑)：提供校準增益 5 分鐘 (可疊加)。</li><li>校準保護奈米機器人：提供校準保護 5 分鐘。</li><li>聊天漏洞發信器：10 分鐘內將全球聊天的部分對話轉換為其他文字。</li><li>SLANC連接器：將聊天機器人Slanc連接到公頻。</li><li>RNG干擾：產生 2 分鐘的 RNG 效果。</li><li>獎勵助推碎片：全體玩家獲得可選擇的獎勵提升 Buff (掛機時間4倍，獎勵2倍)。</li><li>神經突觸加速器：提供 10 分鐘的 5% 神經突觸加速 (可疊加)。</li><li>稀有神經突觸加速器：提供 20 分鐘的 40% 神經突觸加速 (可疊加)。</li><li>額葉皮質優化器：提供 20 分鐘的 80% 額葉皮質增強。</li><li>交易漏洞發信器：提供 20 分鐘的 40% 交易漏洞 (可疊加)。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-賺取資源</title>
      <link href="/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/"/>
      <url>/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會教學plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a> ← 當前位置</li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a></li></ol></div><p>本篇文章將會介紹幾種方式讓新手在遊戲初期獲取 AI 以及 BTC。</p><h1>出售物品</h1><p>短期快速賺錢的方式可以把背包內對新手收益不大的物品出售，如雜湊、箱子、公記等。<br>詳細的物品可以參考：<a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a> &gt; 背包內值錢物品</p><h1>掛 AI</h1><p>看到標題可能會有一個疑問，掛 AI 應該會消耗 AI 核心阿，怎麼賺錢呢?<br>實際上掛 AI 其實也是一個會賺錢的行為，在掛 AI 時可以獲得快取、雜湊等物資，透過剛剛說到的出售物品方法，向其他玩家交易，可以獲得更多的 AI，甚至有可能運氣爆棚出了個紅快取，從此吃穿不愁。</p><h1>壓碎</h1><p>進行這兩種行為的前提是必須加入公會，才可以使用公會內的回收器。</p><h2 id="打工">打工</h2><p>從老闆那裡拿到醫碎之後，在公會的回收器壓成科碎，並寄還給老闆，主要收益是老闆給的薪水，每壓 1k 醫碎的薪水約為 80~100 AI。</p><h2 id="自雇">自雇</h2><p>因為是自己當老闆，所以必須有一定的初始資金買醫碎，買了醫碎之後一樣到公會壓成科碎，壓成科碎之後可以賣掉或是製作成灰包或更高等級的包包出售，主要的收益是醫碎和科碎或包包的差價。</p><h1>下地城</h1><p>此賺錢方式的前提是必須加入公會，才可以打入侵難度的地下城。<br>在 <a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a> 中提到過裝備評級會影響是否能在敵人身上獲得經驗以及戰利品，為了可以速刷低等地下城，同時也可以獲得敵人掉落的物資，玩家們開發出了一種透過壓低裝備評級速刷入侵地下城的方式，玩家們稱之為 「東巴」 ，其主要收益是敵人掉落的雜湊、黃箱等物資。</p><div class="note primary no-icon flat"><p>複習一下裝備評級的公式：<br>(MAX(主武, 特武) + 頭 + 身 + 褲 + 鞋) / 5</p></div><p>而我們的目標是將裝備評級壓到剛好可以刷最低等級的 4 等入侵地下城，並且要確定能夠扛住 Boss 的傷害，因此建議是到 30 等以上再做嘗試，在 <a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a> 中有提到過，上衣是所有防具中提供最多血量的，所以我們只要穿一件 30 等的紫色上衣，配上 30 紫破武，其他裝備都不穿，這時候可以發現，因為破武不會計算在裝備評級內，裝備評級為 30 / 5 = 6，恰好滿足我們的需求。<br>東巴裝備範例：</p><img src="/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/dungeon.png" class="" title="東巴裝備"><p>可以總結東巴有幾點需求：</p><ul><li>加入公會開放入侵地城</li><li>防具確保自己不會被 Boss 打死</li><li>破武一槍一支小怪增加效率</li><li>裝備評級可以獲得敵人物資</li></ul><p>只要滿足以上需求就可以速刷入侵地城 (一場5分鐘內)，來賺取物資。</p><div class="note primary no-icon flat"><p>本教學到此結束啦，如果覺得以上的內容對你有幫助，可以在遊戲中給我 (douobb) 一個街頭聲望喔，另外如果對這個遊戲有興趣，可以在創立帳號時填寫我為推薦人，我會帶你加入公會並且發放小禮物喔~如果對於本教學有任何建議也歡迎在遊戲中私訊我。</p></div>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-快取與裝備</title>
      <link href="/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/"/>
      <url>/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會教學plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a> ← 當前位置</li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a></li></ol></div><h1>快取使用方式</h1><h2 id="灰白快取">灰白快取</h2><p>由於前期練分子列印的主要方式是燒科碎或免費練，所以可以選擇存起來或是賣給其他玩家以換取 AI，等到燒科碎或免費練的效率不足後，可以拿到黑市燒換取 BTC 及分子列印經驗。</p><p>由於在黑市的收益取決於分子列印等級，所以相較於賣掉所能獲得的收益，要到130 ~ 150 等之後才能打平回本，而燒快取的時機是等有大佬開交易漏洞 100% (BTC 收入 +100%) 及額葉 (經驗收入 +80%) 時拿著討價裝 (極限為 BTC 收入 +40%)再燒，才能最大化效率以級收益。</p><h2 id="綠黃快取">綠黃快取</h2><p>通常平時都存著，等哪天大佬開交易漏洞 100%，拿著討價裝 (極限為 BTC 收入 +40%) 再賣給 NPC 商人，而賣給 NPC 的收益與等級無關，所以只要有加成就能直接拿去賣。</p><h2 id="紫紅快取">紫紅快取</h2><p>自己留著之後做裝自己用，通常情況下到了約 50 等後就能考慮換成紫裝，對於入侵難度的地城而言，紫裝屬於標準配置，而紅裝由於極度稀少，所以價格也很高，如果缺錢的話可以考慮賣掉換成 AI，通常售價在幾十 CC 左右(1CC = 1000 AI)，而如果要自己印的話，通常要到 200 ~ 300 等以上比較合乎收益。</p><h1>裝備介紹</h1><h2 id="裝備類型">裝備類型</h2><p>以下介紹僅供參考，並沒有固定的配套，可自行搭配組合。</p><h3 id="主武器">主武器</h3><p>不需彈藥，但傷害低，通常做為增加爆率的手段，等負擔的起紫裝的印刷費時，就可以考慮印一把 24 或 25 爆率的主武等校準 +8 ，因為校好之後基本上不用再換，所以最優先，24 或 25 爆率又稱大爆、精準。</p><h3 id="特殊武器">特殊武器</h3><p>需要能量電池，對盾傷害 1.2 倍，可以打盾，也可以作為增加爆率、暈眩、爆傷的手段，然後都交給破武打，14 或 15 暈只要 +5 就可以 20 暈。</p><h3 id="破壞性武器">破壞性武器</h3><p>需要反物質電池，傷害係數最高，但對盾僅有 0.5 倍傷害，不過敵人的盾都不會太高，前期爆傷還沒太高時，可以選擇爆傷破，後面爆傷達到 170% 以上就可以選擇力破了。</p><h3 id="頭盔">頭盔</h3><p>係數是防具第三，通常做為撐閃避、爆傷、治療加成的手段，治療加成要到十分後期才有其作用，爆傷沒滿就撐閃避也不太好，因此前期可以選擇爆傷，或者多撐一點生命。</p><h3 id="上身盔甲">上身盔甲</h3><p>係數防具第一，撐血量好幫手，也可選擇閃避、爆傷、治療加成等特效。</p><h3 id="下身盔甲">下身盔甲</h3><p>係數防具第二，同上身。</p><h3 id="靴子">靴子</h3><p>係數最低，同頭盔。</p><h3 id="升級模組">升級模組</h3><p>可以裝在防具和武器上增加數值。</p><h2 id="裝備數值上限">裝備數值上限</h2><p>各種數值的上限:</p><ul><li>爆率 70%</li><li>爆傷 200% + 基礎20%</li><li>閃避 40%</li><li>暈眩 20%</li><li>治療 100%</li><li>逃脫 80%</li><li>討價 40%</li><li>背包 128</li></ul><h2 id="裝備詞綴介紹">裝備詞綴介紹</h2><p>重要性為主觀評價。</p><h3 id="體力">體力</h3><p>重要性：★★★☆☆<br>加成能力：血量<br>最低出現品質：白<br>出現裝備部位：防具<br>加成數值：10%<br>介紹：增加你的生存能力。</p><h3 id="回復">回復</h3><p>重要性：★☆☆☆☆<br>加成能力：戰鬥完回復血量<br>最低出現品質：白<br>出現裝備部位：防具<br>加成數值：10%<br>介紹：速刷地城省藥用，但限制很大，至少得保證小怪能2發內打死。</p><h3 id="護盾">護盾</h3><p>重要性：★☆☆☆☆<br>加成能力：戰鬥完回復護盾<br>最低出現品質：白<br>出現裝備部位：防具<br>加成數值：10%<br>介紹：同回復。</p><h3 id="力量">力量</h3><p>重要性：★★★★☆<br>加成能力：武器傷害<br>最低出現品質：白<br>出現裝備部位：武器<br>加成數值：10%<br>介紹：前期爆率及爆傷未滿時可先跳過，中後期破武必備，爆傷滿後就靠力破撐輸出。</p><h3 id="爆率">爆率</h3><p>重要性：★★★★★<br>加成能力：爆擊機率<br>最低出現品質：白<br>出現裝備部位：武器、防具<br>加成數值：武器 10% ~ 25%、防具 1% ~ 5%<br>介紹：可以透過精準紫、紅主武 + 模組稱滿。</p><h3 id="爆傷">爆傷</h3><p>重要性：★★★★☆<br>加成能力：爆擊傷害<br>最低出現品質：白<br>出現裝備部位：武器、防具<br>加成數值：武器 5% ~ 10%、防具 5% ~ 15%<br>介紹：不推薦在武器上，因為最高也只有 10%，反正盡量疊滿220%就對了。</p><h3 id="閃避">閃避</h3><p>重要性：★★★★☆<br>加成能力：閃避攻擊的機率<br>最低出現品質：綠<br>出現裝備部位：防具<br>加成數值：5% ~ 15%<br>介紹：總共最高 40%，可以幫你省藥，若是運氣不錯有了 14、15 閃的頭、鞋，就可以校上去配模組稱滿。</p><h3 id="逃跑">逃跑</h3><p>重要性：★☆☆☆☆<br>加成能力：脫離戰鬥的機率<br>最低出現品質：白<br>出現裝備部位：鞋子<br>加成數值：15% ~ 25%<br>介紹：逃跑的作用是在你沒藥 or 沒子彈時，讓你脫戰。</p><h3 id="暈眩">暈眩</h3><p>重要性：★★★★☆<br>加成能力：攻擊暈眩機率<br>最低出現品質：白<br>出現裝備部位：武器<br>加成數值：8% ~ 15%<br>介紹：總共最高20%，可以簡單的弄一把 +5 的紫14、15暈在主武或特武上，這樣就滿了。</p><h3 id="口袋">口袋</h3><p>重要性：★★★☆☆<br>加成能力：增加背包格數<br>最低出現品質：白<br>出現裝備部位：防具<br>加成數值：3格 ~ 6格<br>介紹：當你需要大量製作東西或掛機拿材料時，就會需要背包裝，有餘力可以弄一套。</p><h3 id="治癒">治癒</h3><p>重要性：★★★☆☆<br>加成能力：增加藥品回血量<br>最低出現品質：綠<br>出現裝備部位：防具<br>加成數值：5% ~ 30%<br>介紹：高等後比較有用，可以省藥錢。</p><h3 id="討價">討價</h3><p>重要性：★★★★☆<br>加成能力：影響黑市、商人販賣價格<br>最低出現品質：白<br>出現裝備部位：武器<br>加成數值：1% ~ 20%<br>介紹：討價武可以準備一把 +8 的紫 19 討或是兩把20討，總之湊滿40就行。</p><h2 id="升級模組詞綴介紹">升級模組詞綴介紹</h2><p>重要性為主觀評價。</p><h3 id="體力">體力</h3><p>重要性：★☆☆☆☆<br>加成能力：血量<br>最低出現品質：灰<br>加成數值：10%<br>介紹：中期一段時間，紫品質以上可以撐點生存能力，前期等級太低數值沒用，後期高等了裝備本身就夠了。</p><h3 id="回復">回復</h3><p>重要性：★☆☆☆☆<br>加成能力：戰鬥完回復血量<br>最低出現品質：灰<br>加成數值：10%<br>介紹：速刷地城省藥用，但限制很大，至少得保證小怪能2發內打死。</p><h3 id="護盾">護盾</h3><p>重要性：★☆☆☆☆<br>加成能力：戰鬥完回復護盾<br>最低出現品質：灰<br>加成數值：10%<br>介紹：同回復。</p><h3 id="傷害">傷害</h3><p>重要性：★☆☆☆☆<br>加成能力：武器傷害<br>最低出現品質：灰<br>加成數值：10%<br>介紹：增加輸出能力，但需要高等且你還有多的模組格，但那應該已經是在配極限裝了</p><h3 id="爆率">爆率</h3><p>重要性：★★★★★<br>加成能力：爆擊機率<br>最低出現品質：灰<br>加成數值：1% ~ 5%<br>介紹：配合精準紫武可以把爆率撐滿。</p><h3 id="爆傷">爆傷</h3><p>重要性：★★★★★<br>加成能力：爆擊傷害<br>最低出現品質：灰<br>加成數值：1% ~ 10%<br>介紹：10% 留起來，基本上全身大多都會插滿這個。</p><h3 id="閃避">閃避</h3><p>重要性：★★★☆☆<br>加成能力：閃避攻擊的機率<br>最低出現品質：綠<br>加成數值：1% ~ 5%<br>介紹：可以拿來配 +8 閃避裝來撐滿 40 閃。</p><h3 id="逃跑">逃跑</h3><p>重要性：★☆☆☆☆<br>加成能力：脫離戰鬥的機率<br>最低出現品質：灰<br>加成數值：10% ~ 20%<br>介紹：逃跑的作用是在你沒藥 or 沒子彈時，讓你脫戰。</p><h3 id="暈眩">暈眩</h3><p>重要性：★★☆☆☆<br>加成能力：攻擊暈眩機率<br>最低出現品質：灰<br>加成數值：1% ~ 5%<br>介紹：不建議使用，不然浪費模組格，因為暈武就很好撐滿。</p><h3 id="口袋">口袋</h3><p>重要性：★★★☆☆<br>加成能力：增加背包格數<br>最低出現品質：白<br>加成數值：1格 ~ 2格<br>介紹：插在背包裝上用。</p><h3 id="治癒">治癒</h3><p>重要性：★★★☆☆<br>加成能力：增加藥品回血量<br>最低出現品質：綠<br>加成數值：4% ~ 7%<br>介紹：高等後比較有用，可以省藥錢。</p><h1>校準</h1><h2 id="校準介紹">校準介紹</h2><p>透過校準可以增加裝備的基礎數值，進入裝備介面並點選升級即可進入校準站，而掛機時也能進行校準，校準之前必須插入裝備校準核心並等待30分鐘，因此建議每次校準完都要插回核心。<br>校準裝備的過程中，校準程序有一定的失敗機率，導致裝備遭到破壞，若校準失敗，裝備及裝備上的模組都會消失。</p><p>以下是校準相關數據：</p><table><thead><tr><th>稀有度</th><th>等級</th><th>失敗率</th><th>增幅</th></tr></thead><tbody><tr><td>廢棄 (灰)</td><td>+1</td><td>2%</td><td>5%</td></tr><tr><td>廢棄 (灰)</td><td>+2</td><td>5%</td><td>10%</td></tr><tr><td>廢棄 (灰)</td><td>+3</td><td>10%</td><td>15%</td></tr><tr><td>普通 (白)</td><td>+4</td><td>15%</td><td>20%</td></tr><tr><td>高級 (綠)</td><td>+5</td><td>50%</td><td>40%</td></tr><tr><td>稀有 (黃)</td><td>+6</td><td>100%</td><td>60%</td></tr><tr><td>傳說 (紫)</td><td>+7</td><td>150%</td><td>80%</td></tr><tr><td>傳說 (紫)</td><td>+8</td><td>200%</td><td>110%</td></tr><tr><td>史詩 (紅)</td><td>+9</td><td>400%</td><td>150%</td></tr><tr><td>史詩 (紅)</td><td>+10</td><td>666%</td><td>200%</td></tr></tbody></table><p>+6 以上的校準，在沒有使用校準增益的情況下，是不可能成功的，校準增益會減少失敗機率，而且效果可以疊加，此外還有校準保護奈米機器人增益可以免除校準的破壞效果，建議重要的裝備要等到上述增益時進行校準。</p><h2 id="校準車">校準車</h2><p>有時候會有大佬開連續的校準增益 (每 35 或 40 分鐘一次)，讓大家可以在失敗機率為 0 的情況下連續強化到 +8 或 +10，通常在校準車前可以在公頻或公會內收到通知，新手可以準備之前提到過的紫精準主做校準。</p><div class="note primary no-icon flat"><p>本教學到此結束啦，如果覺得以上的內容對你有幫助，可以在遊戲中給我 (douobb) 一個街頭聲望喔，另外如果對這個遊戲有興趣，可以在創立帳號時填寫我為推薦人，我會帶你加入公會並且發放小禮物喔~如果對於本教學有任何建議也歡迎在遊戲中私訊我。</p></div>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-交易指南</title>
      <link href="/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/"/>
      <url>/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會功能plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a> ← 當前位置</li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a></li></ol></div><p>交易是 CCO 中非常重要的一部分，而玩家之間交易的主要貨幣是 AI 核心，可以用其來交易各種物資，而主要的交易通道有市集以及市場頻道，以下將介紹各種交易的方式。</p><h1>市集</h1><p>玩家可以從主頁到達市集購買物品，而在掛機時也可以從下方的市集進入 (掛機時無法購買物品)，市集的主要交易貨幣為 BTC，玩家可以在自己攤位上架物品換取 BTC，在上架之前建議可以先看看市集裡面相同物品的價格。</p><p>新手時期因為印製裝備需要消耗 BTC，因此建議可以在市集尋找等級相近的裝備來穿，這樣就可以省下一筆錢，而用不到的裝備也可以丟到市集販售。</p><p>注意在市集購買物品時，可能會因為 BTC 不足，或是背包空間不足而無法購買，有些物品在市集裡面的價格會超過其價值，如公會箱以及子彈，建議在購買之前可以先在公頻或是公會頻道詢問其他大佬。</p><h1>市場頻道</h1><p>市場頻道也是一個物品流通的地方，該頻道主要使用英文來溝通，交易貨幣通常為 AI 核心，有時也會有以物易物的情況，玩家之間會用寄送禮物的方式來互相寄送物品，而在交易時也要當個有誠信的人，如果有欺騙的情況可是會被封號的。</p><h2 id="交易縮寫">交易縮寫</h2><p>為了能讓新手也能在市場頻道進行交易，底下將介紹交易時常用到的縮寫 (找尋物品請善用 Ctrl + F)：</p><h3 id="交易方式">交易方式</h3><ul><li>WTS = Want To Sell = 想賣</li><li>WTB = Want To Buy = 想買</li><li>WTT = Want To Trade = 想交換 通常是非 AI　的以物易物</li></ul><h3 id="交易物品">交易物品</h3><h4 id="碎片類">碎片類</h4><ul><li>TSC = Tech Scrap Cluster = 科碎集群 = 1000 科碎</li><li>MTC = Medical Tech Cluster = 醫碎集群 = 1000 醫碎</li><li>ATP = Ammunition Tech Parts = 彈碎</li><li>MATP = Military Ammunition Tech Parts = 軍碎</li></ul><h4 id="快取類">快取類</h4><p>快取稀有度：</p><ul><li>trash =  灰快 (快取)</li><li>common = 白快</li><li>hq = high quality = 綠快</li><li>rare = 黃快</li><li>legendary = 紫快</li><li>epic = 紅快</li></ul><p>快取部位：</p><ul><li>epic = 紅快</li><li>PW = Primary Weapon = 主武</li><li>SW = Special Weapon = 特武</li><li>DW = Destructive Weapon  = 破武</li><li>helm = helmet = 頭盔</li><li>upper = upper armor = 上身 = 衣服</li><li>lower = lower armor = 下身 = 褲子</li><li>boots = 鞋子</li><li>MOD = 模組</li></ul><h4 id="箱子類">箱子類</h4><ul><li>LC = 白箱 = 已加密容器</li><li>LRC = 黃箱 = 稀有已加密容器</li><li>LLC = 紫箱 = 傳奇已加密容器</li></ul><h4 id="背包類">背包類</h4><ul><li>OP = Old Pouch = 灰包</li><li>Fanny = fanny pack = 白包</li><li>Dora = Explorer’s Backpack = 黃包</li><li>EOC = Employee Office Case = 紫包</li><li>ASU = Autonomous Starage Unit = 紅包 (目前已改為無法交易)</li></ul><h4 id="其他類">其他類</h4><ul><li>Hash = 雜湊處理器</li><li>giot = gang invasion order transmitter = 入侵 = 公會入侵指令發信器</li><li>egms = 公祭/公記/公雞 = 已加密的公會記憶碎片</li><li>GC = Gang Crate = Supply Crate [Gang] = 公會箱</li></ul><h1>其他</h1><p>除了上述兩種主要交易方式之外，還有一個交易功能，在進入其他玩家的個人檔案之後，下滑可以找到傳送交易請求的選項，此交易功能必須兩位玩家都不是在掛機狀態才能執行，目前很少人在使用，主要會使用到的地方是直接寄送 BTC，只要雙方都按下確認就會執行交易。<br>交易介面：</p><img src="/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/trade.png" class="" title="交易"><div class="note primary no-icon flat"><p>本教學到此結束啦，如果覺得以上的內容對你有幫助，可以在遊戲中給我 (douobb) 一個街頭聲望喔，另外如果對這個遊戲有興趣，可以在創立帳號時填寫我為推薦人，我會帶你加入公會並且發放小禮物喔~如果對於本教學有任何建議也歡迎在遊戲中私訊我。</p></div>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-公會教學plus</title>
      <link href="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/"/>
      <url>/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="密碼錯誤" data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="002fabb222f59b329fcd825ce0ee52aaf2ce0c0eff546c2c551efb7af408ea4c">b69de08f0745a4e8c252d11e88b1e24448ee3c9dcf76d2a5ebd6e236c24093ba2c5b804ebc85ffe9a81d9946e7c3783e961876d20319d09fd0c74ab155ba95e7055ac6eba4d773ed307886faff6db4ba0a2b9b72f64f109d29731594d23abaea345896cfebd818a538fdcc6ba7c4f7d16a525c888d8ce522031b086d1577d3788dc011039c5a1d42ac4774599fb59740107e4a86fdb3658faeec3bc224f612fc5e4ed0a72677c6347ba5cebb989eeab9cf979b1cf9dd5ed6e8c1c9fa13bb6459ca0b671eb5832cfe5c1d30a59d4bb42fbd9bccacd48caf9a5257750117a019f3c10fd36f69cc9b10a0e4f836bbe7f3665541aa3cba4a7ca4ee13764b8548076cce57963db44ffa9e2303b79a3b94941480b85d7306112dfdb10ba07fa3ea8433614cac3284261a3c8fd2922937c4bc58172f1f8ede9dc70f45c7f74c359228c6732fdfc195357c7bf6140e89f0c69e41d372cc6f34825a9191e08b1bc34809a281632c0b6acac5815440bb791e9db8718115d009348d4242ea9642d2ccc84ff1040a80243215a419ac69ad106d2b4423b4b196e47f1b37645b3e882ad0499f293c6c26fd286414b3a05e4d1c43f8125e137806ae7c4bcd6a0c8baf4f6414d6b4136188a975391a98ebf7273ee3eebe0e730f37e6a7add7b7a6eb5e944eb400ab5a6a73f573e0459703e2856f5d8050e5fe187fe1db8673af371e4dea57ca692a5fc443a7220877157812584340218205d82d581fdd48376eb9e135ee2ffda4fc5e643128ed1472f3845b679d1c42f051c9bf80b119b5fafcb0a06b790ea73071b43a3947aee6f30c2dd7d14f601b8483c55e004640f96fc490dc454db65c66990347e2c8a6dfbe8343590169119f19488d82bcb72035696163a754722d8efff6f3bc7b07261356598aec6f9e7b46b1a627b738de45d315eb7f19db29dd842b8bcca398975ca7491cb90997c2da0a3b422a1f6bfc5ca72368c1d21319c50b6d27b98c4296fbd8626ff5e9c85e12a58e01ca42cf9f0a1ae9527347e9622004e9d239f56e254ba08eeae76b9cc0682ee0ccf198a5aaae9aa435620b0d67b09f1ac84ae96ae27c9e1a75ababf6d7ea4c8bf9fb4cb4e0aea686c8e84ec6fca6f9d58ddd16a18dfedc2e4c48a3274a9db34796594d761fb54747e859830a3c0979053f9aced1b0fbefbf9081b5f278d16a354b39a45acb058bb2b3a92a56026e5eeb9174c35f0197ea5d55ed5e6c4e477356f9326acc4040ddd0fd9306194bebaff68666a060e06377be4a91a325a2c6facbe2b4f5b20b8fb0fec2542374d17c1adfd2ced622f9d56e6610cca9daad4c3429608d1adce2535ebd1dd87a6fe5ee47a56ebbcfcef2da5384d23ba627c1981dd2fda4a0eedaafa1df88810a63857c6bf90e3ced1c33dc43bd10024762d8267c3332418dcfd9a8f585a49e1681053160232f47e30a252cf6f9edc556be5a2c93558ec85b531afc43e8372064bacbfda41bbefa9bd775201dc24725a68219b852c3a71f5af46a5e199f17e1540b79414a6c0773929306a42442e86dd5f6532495cb6f14fa37f0b54c03994ca080e4c8fe04fc20b19af47fc27a9240bab31b1b2704796ef8d60f3ebed24d35f1c261314a260ffcf5b5ef83f6969af43845200a498aeff7f5a109f66a78ac2918517a43206e81c3a4ca57e137b9105111657630a7666507d526eb995abbf66341e9e49523288af625b95543d4a64fbb9f273cde98f9c4be283a74032334a94b35b29e78f18a62d00c1f246b5f2453a2ec52aac7219ad5ed62ef70099830dd86dde8fbc38609a049cd6851957bcb2762f8deb2a1ca92929ec1e2c7f4c66bc2b4a04ca4b5eb76896ddec237216fae683ab369a88404636718d23cef73106e325ffb42990aec8373e5d2b2decdd0e88ba8d33fc4845343dd29ae280cad0d5ac4ed5b22fc36b6601341601a307fd33b2431abf0f2a28a37af69f6637b3ca373e86c855c275ef929474e4e141c4fd9616fb1fd92ce6bfd9ba78be5d818b2d2f1f7a8dcd72a3106eca8afb3a4858edc5261641af56cecc60092eec15e1f8a8822abea0793e7b1fed0bfc35aeb75fad4dc1d6a407dc22304753cc7736543cab6a972c6fa21fac72d062f3ecf72049b0ea459f43cba47a92d2203795522d48e7456b5f93cf80ac79ad34863cbb529abe6fb6a1185921e68703bee0141f866f0da9b05b676cd443b3f63661175e3dd509737640dbb78fd00af0e1d9e815f02ced966d7c493cd2c48bcc4943198bf4d189cf38ac844c69971311c387a46b268c8ce77db6cf9fe9e27e988226273aabb1a45c105fcf0cc93660dca275e66f5a12a247da81e26cd3858bb3c877eeed824de3720255b67d3954b20605cb879d84f56450651eda1fbdda0540111214f4cfac5264f7a6b5ddcb1223ab33c652b8cf23a6a36476f7cafa77074b85eb68ca5dcb3adcf91d4a639d5d85727308180d92d01bbda5fbad983056c2e8662e87784f04656272c7ea84b954d5c1fcc5829c5a6b19ea688a6d3d6084f2556096158dc49e6efb1f9138f647f8c4ba910cd25e35235ff3a5a6d139dfbbcf5264493045de62573081b28dca203da0192c1aa00a99847e737aaf568ad70af89b407630179e84340756034a8a40d397719a08199d07f39033bd9ee05d61270ab6fcc62f65f5d8426e20510cf91f664650e13b3b7467ac889882ffe528408f3da49682e43f97972b6cb66aadf27e3fd7666009c59c72c9dcc1e64a8c314fd19e7e7adba332c3630b0f782b4aac1b52d0266160d39ff5f3be1d539951d884847e411208f961390b8b2bbfc1139394db22fa04d19fa348dcb8a2df58f387ea51b50c64f69d6d3824d943555266551d310a63716b759f867f253d4492c7080b4009dba98ee93c922d99da302924ce3aed4c2765dc1a977545225139fc4efdb930a7a0bc5e7d681f0c23bca65500684ca195bf2f7ffd8ebf61ab1a1010cfcc89db189f4f719c7c77267cb09c3ced89198409c0aa18030ca1f5e8d0763657320b96e5718da8fd629c35324508e6309011f62fdf5c8ca59bd4ee90d940a3be1138ed546aab2ab8bb2c59fb58caae1ade22629da98b0f51a356c173347e5eeb08a147e0b5ef7654e8ceb9bd33954f89d8342613546adf87e5de7da7faaf35379db13c1af2d919356d4936f8b348c71ebffa5a791ba285be1fbd7bf21d09ac4954dddbbad0529e84cc8b9cab509b53ca21b1edb3c673e42a6366f6cee41c047565ee7e5578288724e64131d39e158b467c45fa19395ca1a334fa8680fcf78a4aa0b066b6d5d6359ad60677704b7728fbceb9980f11982f424570ab02668d9c22927d2eae6cf926fb05cd58f71f7c2905629a59047768d597b8a19756b607505061cd789993b5aaefd8a8d3c5c4e9fd40302a35026517aeb295aaf5bfaa94f2c7e27c49ceefa2cf39aadc201053e7deae26d1590798e754c3e99dc7e1db48d33c4e8d2ec279a2abbf6e8aab74711fec7f731c892014905e1f9dbcbbb4d396875313c537f709ae7b9e2a21634f0aa468dc5dc701018d3f6aaedd8c91c21f7d14ca7fe0d5c0af6f46562b33c91709507c769a2841021638b78938b0e357154c86cb5358bcac93aa466eef39ca6edec3c41fa9aa03c9cfec106152688d2549cb9596b66c572f819728fabf8c7e1ab290c59ee5b634f1f226875e5ef878baff9f5593fddc0e5dc90e1da13372130292cb750f6915c853ba28f7639db22f707fb79a600f229abc1ac8b05a5b278da1824cb7af7f05da2bb57e67e1eec51dec5ba56912494af1fc4e0fbd403a50864b884960bfa07b5218e0dcaecf50417d62c524456f5c8aaf83426567db32e5a08f35c4494add4cb819b66dd522422c6dc64472d646b2dc40abf1370cc30dea95849837111699f3816a2658ba639b54456357a0f5ba6a5cdd15f8f5354a51d85cfe76dca586cdc4e74a5a9bf8772c470b85cdc8b7bed60342996105e4baf3eb28d0b8d99464af686bb2d1fa96a794cf8abacb622c9ae01c93c5c156cf448a77279f626c1a7b48a31a5cd22d5e0c44a7853f2e929eb4aa3acc5f497388eeb7a954e1dacb4b124ae264e816f948a4d180340388469bf99261a026036d5ebd035808b248e9a5dfceaabde884508e22f2b42e3992c63ae13788fe2ca3c45def359fdb87bd2d68138cf7441f6cc5c390a5abb2fe82b2437970eac8624a5433d64c57b8aeca7086d519d9cd480f0b59e31b050915ae12ce8bdfef48e47ade51dac10e74887c27910d20a067660a07b9df09d7a5df93875ce43ed044e6fcfb3c718372c8d995d85855712ab1b91df93c3b9ffa95dccf2ffa366f60b06e0351d7e50ffa608951992287301e83500cf575b83a4164d605cee439e855daafc9a44b93157d73c5c25ee012713f357a08ab4a7723874972e1aacc61a9b7735b0fe86cace30a8859908b447d2d71045a691d07ac9da7408bb67f545a6657e313967eef6e20f286972942d0a906ace4f05f1e4cb083b419e2e0dd81464aacb1453ecfa82cbff351420f417205950b5d0a4d505a5b00cb17611e1e1892ce851aaee465bf338bfcb279e88777122c57f2c39dd6a812c5d056c8132339ab972d1ec776ab8dfd5eec2ce517b4b32837e4f9d8414ec25a0fdd2eea92efc7da070eeb3e1f635fc9133e70670aa4fb2031ea8d748c4f9df305a60fb5591655b97f26512b2456349f57cb8ad4577492a39c12323204c181932dce3092c075b07a14b245ab86962102d3f43e8911faa3caad00e41d13f6a59d9228474484c139bc7c13b8e217caf9c8544414abf30947f38c8c75deb3fbdb25cf942222e72a693988478018cd334cbb3efe56ffcdced8941222183c785b890c8723ca09c087fa28b5e0058ce4d61cad109fa40dc3a83c3fd1a2e640b5deeaf780946c6323dede36b447c95c318b4ae90361c7d6561a47c7fff594efc567e8fd8a0c0909bb67702963e5a637e2b0bc37aa6dd96acc92a6e90fe8287e11cf1f168612e17aef20f04f1b50438b4f30722dc76570a5298a0c4fca0e615aa58c5cd814ac8c2727444c56efe697dab793988e29bb1532ef141db112a4eff439009ab9028f795fabb0b29330468d6f4c583082eeb1af874ba144b66df65d650e3ebcd53ce6a4be1b2c85dcaffc5b50d7b3bc9a5f0a6a97990fd3fd051afc8b9c9e9ef348531a82bf14d94691c9b02d6502a9d7081b86f5c3063c2601e26c1f472fd4ce0a7161466653b6b0e92810f30faa512fc66b2456e55b43c2ca30a86d99502f48b1ccb7bd9d75efb291986bafbdd7431b4dd2315ddae6640421797a0033443625431dab163cb9a135254a9786a9acd4068b9dc569d05b945bc5696bab98c7eca6ea9fe7b15ab686c845a9865a6017a15ce43da770556d418adca3d242d5d84cf5d9e04542e5a1b4fde4bc1078920a14ae30c7ab2b8e506ab6637094d9ce0962b65654ca81cddda8b614bee6a35e0989cddcbf1863a8dd22e801043bdbe38c6464fed3592a9838c4d49e6fd0dc5ed56251fd96a537de728002c8c5fa678fdca88cab1b333d0ce93d3699b0b3153cf31c9c2db9ddf5e768c52332be78bd9b96fc1ac642b00bef2f0154b66c0dad1f83c5e9c09b2201c6e71c56218cdd8dc40a6293e5c0c3465a24151d71a7f26a6c1b9e176dc34439acc0db5eae72426923c0de1c35894e902c205d279bb8948a007e23b998964fdabb3bbfc8d53097a878bfff4ce93abb57a1f7cd36334b8995c3d626d61c04b5dbf4e57218674454ee5f51b80011eecdaf125e25ba2f3deb3b7db4577766204559197af653f1c0f48c498de1c06d718b29d8afc8b371e0444fda911727d52d9284551e53ef872d6ec36d0cec151550cb998f60db774003973a506c22d47d1f815f36357f0b19522877d15bc71f9f0292cefc564fa688f676297c3e6dbc285688cef9b9120ec000a00eb37ce0f14c936c9c2a3a753040d62a2f186b717b0a86a91eecee2fa257566ab4d458fd1dcf81c8372a1b229f1f6ba11c0a4f1be20ff46debade96b9ab5027386c2e59d4b8dfc24d242d67032481943aa955e9f3a260e7fb920f54c9945b0fb358725faa1cf58f992910b73e64aa915c3e09240d187264070db81c4aa0047abdc14ded582fab560c584e0146ab105f55b7580b8795602db87012161b217c85f04c79b063f52b649e30d78dacb94934644d53720a00c7044caef0606c8803841269b5102fcdd17abd484d0f6537d179adfbbdcefe53e6d550620d6a92d71c9f1cb64d2ec51b0c7ccf5103f013f4b626ac7bdf2a20c4683db9a8ec88d2aadb2c97518fa117d7de536f61f90b000caf8b36b7f6518eb8ee0bd2bc35d88efabbe32d810c9a2c51c98716b6542f82b963958722b6624da4559ceeeb78444d657e1cb0247f49670fecf0799060b79c2ddab50d60c90c3ad2b049fbdc9ad2a56c20a50de8c7020c2fd02b85c81e96fd748236aa017f02bcfa78ee610831cf5de321885a90682b426f03d1bfb3c7d9ed4a18388876fe5e2f64e9ebc6cf8039b17595be0b24dcfd371d0985600d8dc7dd441041decd970fe8f8b1dfcb6e2491a6e4d9b45a61cadedaf817c710dc26c2e6a2a907ac839da227ebb57cf3a6d367750565db2a98e0bc2017070ff5062f3ac9d2aef1500612456b5a66ae286c1f3782b977c50b950cb4dfd2a851edd025188459dd965104af2c68429e2b0dee6246920b194a193f8068cdc49022d392f0a11dcc2b7f2a9b27b5e38255fe4c73ea507f93f4c405ddca551546e5dbc3406d3870557cfff5f82ef5c5de468c660cbb756e888091cda144377871ae0c71a367c7a22e2e9f93e8617391518bec217e93693a4354e99ddbcadd50180c7c5c3c4af60c1dd6d8bcdd9550f894b2abfd5a0b442a3ca747bdd326efb75f1c4613293365e9a9c5e7b9165e1c173599f32654965b837cfdbce3db2194f00449e4a295ae93beca989955ba53930f3bf09747a4bfd8f6a9563ed43bed25253ab08144f381935a11ed7e6cbda591abfa1854a71dc0d1a6c05dd7c2c197ceebd4d806f928c44b0a8db2a8384498de9da92daf86a44d9d20cebbcececffc701a757c2bd867cd20e8fc124e3088c3e79604eb07eadaa24444d5a3e633b1830a5a8c6eba68a76e3c6ec2edb0a740ccb1b95a393441e6260d7e4599deb8fd0e695dd082f0c62485bf06186b9aaea5fa22e5ddc63ca7785277262e29a280782d1a0a5cce0dcf350c7ba944350baebde4183e17cf8627a59e4919839c586ca06ba6c2354a738ac5bac4dab9a19969be65ee87fb14eda2fadbc5839ba26367625f05cf6a21f643e73f213a9109a823999183cd99bfcbdd0511417b1919a944bfa8b9db201853a4dc82a1b027745e2c5f74e4f7effbc48157738c57bf8e1254fba0a83b85583854024224a2362da5962e915d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">SUI 成員專屬，在此輸入密碼以查看</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-公會功能</title>
      <link href="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/"/>
      <url>/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a> ← 當前位置</li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會功能plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a></li></ol></div><p>新手如果有在聊天室冒頭，應該會收到許多不同的公會邀請，要加入公會的方式也就只能靠邀請的方式，或是自己建立一個公會，加入公會之後會有公會專屬的聊天室，以及公會總部專屬的功能。</p><h1>公會名詞解釋</h1><ol><li>公會資源<br>公會運轉所需的資源，主要來源是「收集公會資源」功能，每週會扣除定量資源，如資源不足會導致公會強行解散，所需數量和公會成員數成正比。</li><li>公會資金<br>公會運轉所需的 BTC，主要來源是「存入比特幣」功能，每週會扣除定量資金，如資金不足會導致公會強行解散，所需數量和公會成員數成正比。</li><li>控制香格里拉<br>公會競爭時所比較的數據，主要來源是「加強佔領香格里拉」功能，每週控制數在遊戲排名前二的公會可以使用「收取保護費」這項功能，在每週日UTF+8 08:00會刷新數據。</li><li>公會經驗<br>公會升級所需，主要來源於「收集公會資源」及「解密記憶碎片」功能，公會每升一級，最大的成員上限會增加一人。</li></ol><h1>公會功能介紹</h1><ol><li>存入比特幣<br>把你的錢投入公會運轉資金裡，投入就拿不回來，相當於捐款。</li><li>自動回收器<br>主要功能是花費一定時間將醫、彈、軍碎及快取轉變成科技碎片，這個過程被稱為壓碎，在大多情況下，只會用碎片類型的物品下去轉換，不會使用快取，在沒有加速時每次最高可以壓到九小時，每個碎片會有20%的機率得到額外一個科碎，所以期望值為1.2倍的科碎，以下是三種碎片所需時間 (無時間減免)：</li></ol><ul><li>醫碎/軍碎 1片16秒</li><li>彈碎 1片4秒</li></ul><ol start="3"><li>收集公會資源<br>消耗公會箱及一定時間來獲得公會資源、公會經驗以及玩家本人的挖礦經驗，最高可以掛到8小時，為了公會的發展可以考慮每天睡前掛。</li><li>加強佔領香格里拉<br>消耗公會箱及一段時間增加控制香格里拉的數量，原本各公會間有佔領排表，但目前幾乎沒有公會按表進行佔領。</li><li>解密記憶碎片<br>消耗公會記憶碎片及一定時間來獲得隨機裝備、公會經驗以及玩家本人的挖礦經驗，每個記憶碎片會得到一件隨機裝備，而裝備的品質為黃色到紅色，裝備等級與人物主等級相同，最高可以掛到8小時。</li><li>收取保護費<br>只有在公會控制香格里拉的數量在全遊戲排名前二時才能使用，消耗公會箱、btc、及一定的時間，有機會獲得Ai核心、科技碎片、灰包、醫碎、各式加密容器、稀有度從黃~紅的裝備，對於新手來說是賺到第一桶金的好時機。</li><li>駭入SL數據堡壘<br>主要作用是消耗協議漏洞碎片及少量時間來換取全伺服器共用的駭入進度，在進度滿了之後會隨機產生一種全伺服器共用的短期加成，但由於目前有許多大佬願意花錢幫大家開效果，所以通常不會用到，也是可以無視的功能之一。</li></ol><h1>SUI 公會專屬</h1><p>如果你屬於 SUI 公會，可以前往 <a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">公會教學plus</a>，裡面有更多內容。</p><div class="note primary no-icon flat"><p>本教學到此結束啦，如果覺得以上的內容對你有幫助，可以在遊戲中給我 (douobb) 一個街頭聲望喔，另外如果對這個遊戲有興趣，可以在創立帳號時填寫我為推薦人，我會帶你加入公會並且發放小禮物喔~如果對於本教學有任何建議也歡迎在遊戲中私訊我。</p></div>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CCO教學-新手入門</title>
      <link href="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/"/>
      <url>/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/</url>
      
        <content type="html"><![CDATA[<div class="note info no-icon flat"><p>CCO 教學系列文章：</p><ol><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/">CCO教學-新手入門</a> ← 當前位置</li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E5%8A%9F%E8%83%BD/">CCO教學-公會功能</a></li><li><a href="https://douobb.github.io/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E5%85%AC%E6%9C%83%E6%95%99%E5%AD%B8plus/">CCO教學-公會功能plus (SUI 公會專屬)</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E5%BF%AB%E5%8F%96%E8%88%87%E8%A3%9D%E5%82%99/">CCO教學-快取與裝備</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E4%BA%A4%E6%98%93%E6%8C%87%E5%8D%97/">CCO教學-交易指南</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-%E8%B3%BA%E5%8F%96%E8%B3%87%E6%BA%90/">CCO教學-賺取資源</a></li><li><a href="https://douobb.github.io/2024/04/28/CCO%E6%95%99%E5%AD%B8-Buff%E8%88%87%E7%89%A9%E5%93%81%E7%B8%BD%E8%A6%BD/">CCO教學-Buff與物品總覽 </a></li></ol></div><h1>簡介</h1><p>CyberCode Online (賽博源碼)，簡稱為 CCO ，是一款由台灣人開發的 Text MMORPG ，雖然地下城以及戰鬥畫面及其陽春，但是遊戲整體體驗還是不錯的。此遊戲的本體就是掛機以及聊天室，遊戲除了多個語言的聊天室之外，還有交易專用的聊天室，可供玩家進行自由交易，因為是一個掛機類型的遊戲，非常適合學生、上班族遊玩，當一個快樂的薪水小偷。<br>陽春的地下城：</p><img src="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/dungeon.png" class="" title="地下城"><p>遊戲的另一個特色就是非 Pay to Win ，玩家不一定要課金才能變得比其他人強，因為這個遊戲的課金功能都是全伺服器共享的，因此當一個免費仔也能玩的很開心，除此之外，遊戲內的風氣相當好，對新手相當友善，掛機時沒事情都可以在聊天室和大家一起聊天。</p><div class="note primary no-icon flat"><p>遊戲連結：<br><a href="https://cybercodeonline.com/">網頁版</a><br><a href="https://play.google.com/store/apps/details?id=com.cybercodeonline.cybercode">Google Play</a><br><a href="https://apps.apple.com/tw/app/cybercode-online-text-mmo/id1541691332">App Store</a><br><a href="https://www.microsoft.com/zh-tw/p/cybercode-online/9n9xc0hl2tsp">Microsoft Store</a></p></div><h1>新手入門</h1><h2 id="注意事項">注意事項</h2><p>本遊戲有一些規則需要注意，希望大家都能夠遵守：</p><ul><li>禁止小號 (小號間無法交易物品，而且可能導致帳號被鎖)。</li><li>禁止使用腳本外掛、輔助工具。</li><li>禁止使用現實世界的金錢交易。</li><li>友善聊天，禁止刷屏、謾罵等情形。</li></ul><h2 id="新手怎麼升級">新手怎麼升級</h2><ol><li><p>等級 1 ~ 4 ：<br>可以先打路邊的敵人提升等級，如果發現自己打不過也可以點擊左上角的逃跑 (成功率為 100%) ，可以獲得一些快取，可以列印成裝備，4等之後會開啟市集，建議裝備可以在裡面購買，會比自己列印便宜。</p></li><li><p>等級 5 ~ 9：<br>在裝備等級足夠的情況下，可以嘗試去打等級相近的地下城，可以獲得經驗以及物資，也能在右下角手機圖示 &gt; 地下城列表裡面找看看等級相近的地下城，普通以及挑戰難度的地下城中可以撿到該地區的密鑰碎片，記得編號 1、2、3 的各留一個，三者可以在終端機合成，成為通往下一地區的密鑰。<br>也可以使用 AI 核心掛機提升等級，在有突觸加速 buff (減少80%掛機時間) 時升級效率很不錯。</p></li><li><p>等級 10 ~ ：<br>等級 10 之後基本上遊戲的所有功能都會開啟，玩家在合成密鑰之後也可以到下一個地區掛機，注意這時候如果打怪不小心死掉了會扣除 10% 的經驗以及 BTC ，如果不想要噴這麼多錢，可以把 BTC 存進銀行內。</p></li></ol><h2 id="主頁功能簡介">主頁功能簡介</h2><p>在開啟了所有功能之後，主頁應該會是這個樣子：</p><img src="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/home.png" class="" title="主頁"><p>而各個區塊的功能大致如下 (詳細功能之後會介紹)：</p><p>互動列表</p><ul><li>荒坂貨幣換匯：課金道具 (有活動時可能會有免費物品可以拿)。</li><li>電馭裝飾：課金裝飾框。</li><li>3D 分子列印機：將快取列印成裝備。</li><li>裝備商人：販賣對應等級裝備 (不建議購買)、地城代幣兌換。</li><li>藥商：販賣藥品 (不建議購買)、出售道具。</li><li>終端機：解鎖加密容器、合成密鑰</li><li>荒坂銀行：儲存道具、BTC。</li><li>李先生的交易站：製作背包。</li><li>校準站：校準加強裝備。</li></ul><p>旅行</p><ul><li>超迴列車總站：前往各區域。</li><li>香格里拉商業區：可以升級各個副等級。</li><li>香格里拉市集：可以販賣、購買物資。</li><li>公會總部：使用公會內部功能。</li><li>公寓：可以養寵物 (需要等級 100 以上且獲得條件困難)。</li></ul><h2 id="如何與人互動">如何與人互動</h2><p>在聊天室如果點擊他人的名字會出現一個彈窗，上面有許多功能</p><img src="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/click-name.png" class="" title="彈窗"><ul><li>檢舉並封鎖、封鎖：建議不要濫用檢舉功能，封鎖之後在聊天室就不會看到該人的訊息。</li><li>查看個人檔案：可以看到玩家的等級、創號日期，向下滑動之後可以看到其他功能，上方的選單可以查看該玩家的背包以及寵物。</li><li>送禮物：寄送物品給該玩家，玩家間互相送禮物也是常見的交易方式。</li><li>傳送私人訊息：私訊該玩家 (玩家會收到通知)。</li><li>回覆：在聊天室中回覆並 @ 該玩家 (玩家會收到通知)，在聊天室中輸入 @ 加上該玩家名字可以達到相同效果。</li></ul><h2 id="等級與副等級">等級與副等級</h2><p>在個人檔案可以看到自己的主等級以及五個副等級，其中副等級不會超過主等級，以下簡介各個等級的功能以及重要程度 (主觀)。</p><h3 id="主等級">主等級</h3><p>重要性：★★★★★<br>作用：人物等級，也決定了副等級的上限。<br>升級方式：</p><ol><li>部署 AI 機器人：消耗 AI 核心 (有掛機時間減免時推薦)。</li><li>附近的敵人：可能需要消耗彈藥。</li><li>地下城：可能需要消耗彈藥、藥品。</li></ol><h3 id="分子列印等級">分子列印等級</h3><p>重要性：★★★★★<br>作用：影響快取列印出裝備的等級，以及黑市燒快取所獲的的 BTC 量。<br>升級方式：</p><ol><li>商業區 &gt; 分子列印工廠：不需消耗物品 (速度較慢)。</li><li>商業區 &gt; 逆向工程：消耗科技碎片 (速度較快)。</li><li>市集 &gt; 黑市：消耗快取 (150 等以下不建議)。</li><li>列印裝備：消耗快取、BTC (不推薦)。</li></ol><h3 id="醫學等級">醫學等級</h3><p>重要性：★★★★☆<br>作用：影響可以做出來的藥品，最高級的藥只需要練到 140 等級即可。<br>升級方式：</p><ol><li>商業區 &gt; 人體改造診所：不需消耗物品。</li><li>背包 &gt; 製作 (製作藥品)：消耗醫療碎片 (建議在有經驗加成時製作)。</li></ol><h3 id="彈藥製作等級">彈藥製作等級</h3><p>重要性：★☆☆☆☆<br>作用：影響製作彈藥的比例，但是因為彈藥容易獲得，所以不推薦練。<br>升級方式：</p><ol><li>商業區 &gt; 改造彈藥：不需消耗物品。</li><li>背包 &gt; 製作 (製作彈藥)：消耗彈藥、軍用彈藥碎片。</li></ol><h3 id="搜索等級">搜索等級</h3><p>重要性：★★★★☆<br>作用：影響可以搜索的區域，區域等級越高獲得物品越多，算是穩定的經濟來源。<br>升級方式：</p><ol><li>搜索：不需消耗物品。</li></ol><h3 id="挖礦等級">挖礦等級</h3><p>重要性：★☆☆☆☆<br>作用：影響挖礦的 BTC 獲得量，以及製作 AI 核心的比例，因為要較高等級才能回本，且雜湊直接出售的價格也不錯，所以不推薦練。<br>升級方式：</p><ol><li>商業區 &gt; 加密貨幣挖礦：消耗雜湊 (新手不推薦)。</li><li>公會總部 &gt; 蒐集公會資源：消耗公會箱。</li><li>公會總部 &gt; 解密記憶碎片：消耗公會記憶碎片。</li><li>背包 &gt; 製作 (製作AI)：消耗雜湊、科技碎片 (新手不推薦)。</li></ol><h2 id="新手避坑">新手避坑</h2><h3 id="不建議進行的操作">不建議進行的操作</h3><p>有一些操作在低等級時報酬不高，要到高等級才會回本，或是有些行為就是在浪費錢，以下列舉一些新手不推薦做的事：</p><ol><li>黑市燒快取：約 150 等回本</li><li>練挖礦等級：約 300 - 400 等回本。</li><li>練彈藥等級：彈藥容易獲得，練等意義不大。</li><li>大量列印裝備：會消耗大量 BTC。</li><li>把快取放入公會回收器：時間長且收益低。</li><li>製作後綴為噴劑或無人機的藥品：這類藥品為群體醫療，不建議使用。</li><li>破解 SL 數據中心：破解後可以獲得全球 buff ，但是因為常常會有大佬直接課金開 buff ，所以沒有必要。</li></ol><h3 id="背包內值錢物品">背包內值錢物品</h3><p>新手在前期很有可能遇到背包放不下物品的情況，這時候可能就需要丟棄掉一些東西，但是其實有些物品是可以拿來換取其他資源的，這邊簡介一些新手不建議丟棄的有價值物品：</p><ol><li>各類快取：快取從灰 (廢棄) 到紅 (史詩) 都是可以出售換成 AI 的，因此不建議新手將其丟棄，詳細的兌換 AI 比例可以在公頻詢問或是洽詢各公會內人員。</li><li>稀有、傳奇加密容器：可以找人換取 AI ，也可以放到市集換 BTC ，當然想要留著自己開箱也行。</li><li>雜湊處理器：前面提到過不建議練挖礦等級，因此雜湊就可以拿去換取資源，可以找人換取 AI ，也可以放到市集換 BTC。</li><li>已加密的公會記憶碎片：可以開出裝備 (黃 ~ 紅) ，因為新手的裝備汰換快速，因此紅裝不太值錢，可以找人換取 AI。</li></ol><h3 id="裝備評級">裝備評級</h3><p>在個人檔案可以看到自己的裝備評級，詳細的計算公式為 <em>(MAX(主武, 特武) + 頭 + 身 + 褲 + 鞋) / 5</em> ，裝備等級主要有以下兩個公用：</p><ol><li>地下城評估：可以透過自己的裝備評級、稀有度 (顏色)、校準程度來評估自己是否適合該等級地下城，同時也會影響是否能在敵人身上獲得經驗以及戰利品 (裝備評級 - 敵人等級 &gt; 3 時無法獲得)。</li><li>AI 掛機經驗：AI 掛機所獲得的經驗量和裝備評級，因此建議掛機時評級要盡量與自身等級相同，除了打地城的裝備之外，也可以準備一套掛機專用套裝，因為稀有度不影響經驗獲得量，所以只要印灰裝就好。<br>掛機套裝範例 (評級395)：</li></ol><img src="/2024/04/27/CCO%E6%95%99%E5%AD%B8-%E6%96%B0%E6%89%8B%E5%85%A5%E9%96%80/afk-set.png" class="" title="掛機套裝"><h2 id="推薦好站">推薦好站</h2><ol><li><a href="https://hackmd.io/@temmie950807/SL_DATA">SL DATA</a>：裡面有一些新手教學、工具以及故事。</li><li><a href="https://discord.com/invite/JREx8xz">官方 DC</a>：裡面儲存了聊天室的 log，有活動時裏面也會有通知。</li><li><a href="https://forum.gamer.com.tw/C.php?bsn=73182&amp;snA=6">新手常見問題</a></li></ol><p>除了以上網站外也可以看看本網站中的其他相關文章 (陸續更新中)。</p><div class="note primary no-icon flat"><p>本教學到此結束啦，如果覺得以上的內容對你有幫助，可以在遊戲中給我 (douobb) 一個街頭聲望喔，另外如果對這個遊戲有興趣，可以在創立帳號時填寫我為推薦人，我會帶你加入公會並且發放小禮物喔~如果對於本教學有任何建議也歡迎在遊戲中私訊我。</p></div>]]></content>
      
      
      <categories>
          
          <category> 休閒 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CCO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter開發-機殼篩選網頁-續</title>
      <link href="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/"/>
      <url>/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/</url>
      
        <content type="html"><![CDATA[<h1>簡介</h1><div class="note info flat"><p>網頁連結： <a href="https://douobb.github.io/pc_case_filter/">機殼篩選</a></p></div><p>本專案是我使用Flutter開發的第一個正式專案，功能是讓使用者可以篩選出符合自己需求的機殼，詳細介紹可以參考<a href="https://douobb.github.io/2024/04/18/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81/">上一篇文章</a></p><h1>後續</h1><div class="note info flat"><p>網頁連結： <a href="https://forum.gamer.com.tw/C.php?bsn=60030&amp;snA=643654&amp;tnum=3">【攻略】原價屋機殼篩選</a></p></div><p>在完成了上一篇文章的隔天，我把網站分享到了巴哈姆特 - 電腦應用綜合討論區，到現在也過了一個禮拜了，沒想到竟然已經有 10k 的瀏覽量，這幾天收到許多的建議，也因此對網頁進行了不少的更新改進，多了一些功能，因此想在這邊做一點紀錄。</p><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/10k-views.png" class="" title="10k瀏覽"><h2 id="新增功能">新增功能</h2><h3 id="機殼邊長">機殼邊長</h3><p>原本在設計網頁時其實也有考慮到加入這個邊長篩選的功能，讓使用者可以判斷機殼是否適合放入指定空間，但是因為原價屋網頁上的機殼邊長順序並非固定的 寬 * 深 * 高 排序，因此難以去做判斷，而如果使用長度去做排序，因為不同的機殼外觀不同 (高&gt;深 or 深&gt;高)，可能會造成誤判，就改以公升數進行篩選。</p><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/suggest.png" class="" title="建議"><p>後來也收到許多人的建議加入此功能，最後採用了最長邊、次長邊、短邊的篩選方式，剩下的就交給使用者自行判斷了，以下是修改後的結果：</p><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/length.png" class="" title="邊長篩選"><p>實現的方法就是在蒐集資料時利用 sort 函數將三邊長進行排序，存入三個變數後上傳到資料庫中儲存，之後在 Flutter 程式之中加入篩選三邊長的功能就好。</p><h3 id="背插-全景機殼">背插、全景機殼</h3><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/others.png" class="" title="背插、全景機殼"><p>這個功能是加在 「其他」 類型的篩選中，可以篩選出支援背插主板以及全景外觀的機殼，實現的方法相當簡單，就是在爬蟲時擷取是否出現關鍵字 「背插」 和 「全景」 即可。</p><h2 id="調整功能">調整功能</h2><h3 id="側板類型">側板類型</h3><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/side-panel.png" class="" title="側板類型"><p>原本的側板類型只有 側透、非側透、可替換 三種，也是有不少人建議加上非玻璃的側透類型，因為有些人只是不希望使用易碎的玻璃而已，而壓克力就是不錯的選項，因此我在篩選側板類型中多加了壓克力這個選項。</p><h3 id="內附風扇數">內附風扇數</h3><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/fans-inside.png" class="" title="內附風扇數"><p>一開始在做爬蟲時就有順便統計了機殼所內附的風扇數量，不過後來就懶得做出來實際的功能，只是將 「是否內附風扇」 加在「其他」 類型的篩選中，後來有人建議可以加入風扇數量的篩選，於是就將這個功能做出來了。</p><p>實現的部分是使用 Flutter 的 RangeSlider widget，讓使用者可以調整機殼內風扇數的範圍，並進行篩選。</p><h3 id="cpu-高-gpu-長">CPU 高 &amp; GPU 長</h3><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/cpu&gpu.png" class="" title="CPU高&amp;GPU長"><p>原本的功能只有做 CPU 高以及 GPU 長的下限，不過有人建議可以加上兩者的上限(雖然我還是不太了解原因)，後來就把此功能補上，並將兩者的篩選欄位分開，方便使用。</p><h3 id="硬碟支援">硬碟支援</h3><img src="/2024/04/25/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81-%E7%BA%8C/drives-support.png" class="" title="硬碟支援"><p>這個功能應該是最多人有建議加上的，要做出這個功能也是花了不少時間，和邊長的篩選功能一樣，也是一個我一開始有考慮做的功能，因為各個機殼對於硬碟的兼容性各不相同，也可能會因為顯卡長、電供尺寸不同而改變，除此之外，原價屋的網頁表示方式也相當抽象，因此我花了不少時間做整理，當然，最後篩選出的結果還是要由使用者自行判斷。</p><p>以下是部分程式碼(已省略重複內容，詳細程式碼可至 Github 專案中查看)，可以看到光是 “3.5 or 5.25*” 就有不少寫法(前後對調、英文大小寫、“共用”…)需要去做判斷，而支援度的部分我是直接針對單一類型的硬碟取最大值，因此在兩種類型的硬碟同時做篩選時可能造成衝突，這也是需要使用者自行做判斷的原因。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(drivesSupport)):</span><br><span class="line">  tmp = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>]</span><br><span class="line">  drivesSuppor25.append(<span class="number">0</span>)</span><br><span class="line">  drivesSuppor35.append(<span class="number">0</span>)</span><br><span class="line">  drivesSuppor525.append(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;5.25 or 3.5*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;5.25 or 3.5*&quot;</span>)+<span class="number">12</span>:drivesSupport[i].find(<span class="string">&quot;5.25 or 3.5*&quot;</span>)+<span class="number">14</span>]).isdigit()):</span><br><span class="line">      t = <span class="built_in">int</span>(drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;5.25 or 3.5*&quot;</span>)+<span class="number">12</span>:drivesSupport[i].find(<span class="string">&quot;5.25 or 3.5*&quot;</span>)+<span class="number">14</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      t = <span class="built_in">int</span>(drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;5.25 or 3.5*&quot;</span>)+<span class="number">12</span>])</span><br><span class="line">    drivesSuppor25[i] += t</span><br><span class="line">    drivesSuppor35[i] += t</span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;3.5 or 5.25*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;3.5 or 2.5*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;2.5 or 3.5*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;2.5 OR 3.5*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;共用*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="string">&quot;3.5/2.5*&quot;</span> <span class="keyword">in</span> drivesSupport[i]):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">while</span>(drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>) != -<span class="number">1</span>):</span><br><span class="line">    t = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>((drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>)+<span class="number">4</span>:drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>)+<span class="number">6</span>]).isdigit()):</span><br><span class="line">      t = <span class="built_in">int</span>(drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>)+<span class="number">4</span>:drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>)+<span class="number">6</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      t = <span class="built_in">int</span>(drivesSupport[i][drivesSupport[i].find(<span class="string">&quot;2.5*&quot;</span>)+<span class="number">4</span>])</span><br><span class="line">    <span class="keyword">if</span>(t &gt; tmp[<span class="number">0</span>]):</span><br><span class="line">      tmp[<span class="number">0</span>] = t</span><br><span class="line">    drivesSupport[i] = drivesSupport[i].replace(<span class="string">&quot;2.5*&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">while</span>(drivesSupport[i].find(<span class="string">&quot;3.5*&quot;</span>) != -<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  <span class="keyword">while</span>(drivesSupport[i].find(<span class="string">&quot;5.25*&quot;</span>) != -<span class="number">1</span>):</span><br><span class="line">    <span class="comment">#code</span></span><br><span class="line">  drivesSuppor25[i] += tmp[<span class="number">0</span>]</span><br><span class="line">  drivesSuppor35[i] += tmp[<span class="number">1</span>]</span><br><span class="line">  drivesSuppor525[i] += tmp[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><div class="note simple"><p>其實這個項目在大約一個月之前就已經完成並準備發表，但是一直在擔心自己做的不夠好，所以才拖了這麼久，觀察這個項目的運作情況，結果發布了之後還是有一些 bug 要處理，不過好險沒有太大的影響，也收到了很多建議，希望能夠幫助更多正在挑選機殼的人，未來也有可能製作其他記憶體、電供等的篩選網頁，非常感謝大家的支持。</p></div>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 爬蟲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flutter開發-機殼篩選網頁</title>
      <link href="/2024/04/18/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81/"/>
      <url>/2024/04/18/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81/</url>
      
        <content type="html"><![CDATA[<h1>簡介</h1><div class="note info flat"><p>網頁連結： <a href="https://douobb.github.io/pc_case_filter/">機殼篩選</a></p></div><p>本專案是我使用Flutter開發的第一個正式專案，功能是讓使用者可以篩選出符合自己需求的機殼，可以使用的功能包括了搜索、排序以及篩選，希望對正在挑選機殼的人們有幫助，如果在使用過程中有遇到問題或有其他建議都歡迎向我回報。</p><p>機殼的資料來自 <a href="https://www.coolpc.com.tw/eachview.php?IGrp=14">原價屋CASE機殼(+電源)總覽</a> 網站，此專案所使用到的技術以及環境如下：</p><ul><li>Flutter 3.19.0 (channel stable)</li><li>Dart 3.3.0</li><li>Python 3.12.2</li><li>Firebase Realtime Database</li><li>Github Actions</li><li>Github Pages</li></ul><h1>開發過程</h1><h2 id="蒐集機殼資料">蒐集機殼資料</h2><p>在原價屋網站上的機殼資料主要包含以下項目：</p><ul><li>機殼</li><li>品牌</li><li>容量</li><li>顯卡長</li><li>CPU高</li><li>主板</li><li>電供</li><li>內附風扇數</li><li>風扇 (前、後、上、下、側)</li><li>水冷 (120、140、240、280、360、420)</li><li>I/O (U3、U2、TYPE-C、HDMI、SD讀卡機)</li><li>硬碟 (2.5、3.5)</li><li>光碟機</li><li>側板類型</li><li>控制器&amp;集線器</li><li>顯卡垂直安裝</li><li>圖片</li></ul><p>而我所做的就是利用 Python 的 BeautifulSoup 函示庫，蒐集網頁上的資料並且整理成一個一個陣列，之後上傳到建立好的 Firebase 資料庫中，讓 Flutter 建立的網頁可以讀取我們整理好的資料，同時為了方便管理，我也讓這個 Python 檔案可以產生 log 以及儲存機殼資料的 csv 檔。</p><p>部分程式內容：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#控制器&amp;集線器</span></span><br><span class="line">fanHub = []</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> allCase:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="keyword">case</span>.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&quot;控制器|集線器&quot;</span>)))!=<span class="number">0</span>):</span><br><span class="line">    fanHub.append(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    fanHub.append(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#顯卡垂直安裝</span></span><br><span class="line">verticalGPU = []</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">case</span> <span class="keyword">in</span> allCase:</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">len</span>(<span class="keyword">case</span>.find_all(string=re.<span class="built_in">compile</span>(<span class="string">&quot;顯卡垂直安裝&quot;</span>)))!=<span class="number">0</span>):</span><br><span class="line">    verticalGPU.append(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    verticalGPU.append(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><h2 id="flutter-建立網頁">Flutter 建立網頁</h2><p>Fltter 的部分首先先從 Firebase 資料庫儲存每個機殼的資料到 class 中，根據使用者設定的條件進行排序、篩選後呈現到網頁上，每個機殼的資料是放在 Card 類型的 widget 中，而布局方式不是使用內建的 GridView ，而是使用 <a href="https://pub.dev/packages/responsive_grid">responsive_grid</a> ，因為每個機殼的敘述文字長度可能不同，使用此布局方式能使每個 Card 的高度自適應內容，不用像 GridView 一樣統一高度，不過也是因為使用了此方法，導致網頁在滾動時的效能會降低。</p><p>部分程式內容：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">body: Align(</span><br><span class="line">    child: Container(</span><br><span class="line">        decoration: BoxDecoration(</span><br><span class="line">            color: primaryColor,</span><br><span class="line">        ),</span><br><span class="line">        child: ResponsiveGridList(<span class="comment">//布局</span></span><br><span class="line">            controller: controller,</span><br><span class="line">            desiredItemWidth: <span class="number">500</span>,</span><br><span class="line">            children: initCaseCard(cardColor, textColor, buttonColor, filterCase),<span class="comment">//Card 物件</span></span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">),</span><br></pre></td></tr></table></figure><h1>開發心得</h1><p>在開發的過程中我也遇到過不少問題，因此在這邊把一些開發時可能遇到的困難、解決方法以及一些實用的小技巧記錄下來。</p><h2 id="quicktype">Quicktype</h2><div class="note info flat"><p>網頁連結： <a href="https://quicktype.io/">quicktype</a></p></div><p>Quicktype是一個可以將 JSON 轉為各種語言的 Class 或 Struct 的網站，可以減少自己轉換程式碼的時間。進入網站之後，點擊 OPEN QUICKTYPE 就會進入轉換網頁，只要在左側輸入 JSON 源碼，右側選擇想要的程式語言，就會在中間自動生成程式碼，以下是使用範例：</p><img src="/2024/04/18/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81/quicktype.png" class="" title="quicktype範例"><h2 id="gitgub-專案-secrets">Gitgub 專案 Secrets</h2><p>如果要把專案上傳到 Gitgub 的公開專案上，並使用 Github Actions 執行的話，為了避免 Passowrd, API Key 等等重要資料外洩，就必須要把這些資料寫到該專案的 Secrets 之中，而我在建立 Python 和 Flutter 的專案時都有使用到 Secrets 功能，底下將簡介兩種程式語言引入 Secrets 的方法。</p><h3 id="python">Python</h3><ol><li>打開專案的 Settings &gt; Secrets and variables &gt; Actions ，新建一個 Repository secret ，將資料輸入，範例名稱為{SECRET_LINK}。</li></ol><img src="/2024/04/18/Flutter%E9%96%8B%E7%99%BC-%E6%A9%9F%E6%AE%BC%E7%AF%A9%E9%81%B8%E7%B6%B2%E9%A0%81/github_secrets_python.png" class="" title="github_secrets_python範例"><ol start="2"><li>在 workflows 中的 yml 檔案中要加入以下代碼：</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">SECRET_LINK:</span> <span class="string">$&#123;&#123;secrets.SECRET_LINK&#125;&#125;</span></span><br><span class="line">  <span class="comment">#&#123;SECRET_LINK&#125; 可以改為剛剛設定的變數名稱</span></span><br></pre></td></tr></table></figure><ol start="3"><li>在 Python 引入 os 函式庫，就可以使用環境中的 secrets</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">url = os.environ[<span class="string">&#x27;SECRET_LINK&#x27;</span>] <span class="comment">#&#123;SECRET_LINK&#125; 可以改為剛剛設定的變數名稱</span></span><br></pre></td></tr></table></figure><h3 id="flutter">Flutter</h3><div class="note info flat"><p>此方法參考： <a href="https://medium.com/flutter-community/managing-secrets-in-an-open-sourced-flutter-web-app-8c2219ed72b9">Managing secrets in an open-sourced flutter web app</a></p></div><p>這一個方法的原理是將想要的檔案轉為 base64 編碼，並設定為 secrets ，執行 Actions 時將 secrets 轉換回 dart 檔案讓其他程式碼可以使用。</p><ol><li>建立一個 <code>secrets.dart</code> 檔案，將資料放入其中（記得將檔案上傳時不要連 <code>secrets.dart</code> 一起上傳了），<code>secrets.dart</code> 範例：</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:firebase_core/firebase_core.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myFirebaseOptions = <span class="keyword">const</span> FirebaseOptions(</span><br><span class="line">    apiKey: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    authDomain: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    databaseURL: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    projectId: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    storageBucket: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    messagingSenderId: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    appId: <span class="string">&quot;...&quot;</span>,</span><br><span class="line">    measurementId: <span class="string">&quot;...&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>在 secrets.dart 檔案所在文件夾打開終端機，輸入以下指令，產生 base64 編碼文件 secrets。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">certutil -encode secrets.dart secrets</span><br></pre></td></tr></table></figure><ol start="3"><li><p>用記事本打開 secrets 就會看到 <code>secrets.dart</code> 檔案轉換成的 base64 編碼，在專案中新建一個 Repository secret ，將剛剛的編碼輸入（不包含上下分隔線），範例名稱為{SECRETS_FILE_CONTENT}。</p></li><li><p>在 workflows 中的 yml 檔案中要加入以下代碼：</p></li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">name:</span> <span class="string">Decode</span> <span class="string">base64</span> <span class="string">secrets</span> <span class="comment">#將 base64 編碼還原</span></span><br><span class="line"><span class="attr">run:</span> <span class="string">echo</span> <span class="string">$SECRETS_FILE_CONTENT</span> <span class="string">|</span> <span class="string">base64</span> <span class="string">-di</span> <span class="string">&gt;</span> <span class="string">lib/secrets.dart</span> <span class="comment">#lib 路徑</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line">  <span class="attr">SECRETS_FILE_CONTENT:</span> <span class="string">$&#123;&#123;</span> <span class="string">secrets.SECRETS_FILE_CONTENT</span> <span class="string">&#125;&#125;</span></span><br><span class="line">  <span class="comment">#&#123;SECRETS_FILE_CONTENT&#125; 可以改為剛剛設定的變數名稱</span></span><br></pre></td></tr></table></figure><ol start="5"><li>在 Flutter 引入 secrets.dart ，就可以使用裡面的內容</li></ol><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:pc_case_filter/secrets.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> main() <span class="keyword">async</span> &#123;</span><br><span class="line">  WidgetsFlutterBinding.ensureInitialized();</span><br><span class="line">  <span class="keyword">await</span> Firebase.initializeApp(</span><br><span class="line">    options: myFirebaseOptions <span class="comment">/* secrets.dart 內的變數 */</span></span><br><span class="line">  );</span><br><span class="line">  runApp(<span class="keyword">const</span> MyApp());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="白天-黑夜模式切換">白天 &amp; 黑夜模式切換</h2><p>本專案中可以透過按鍵切換樣式，有三種模式，分別為自動、黑夜、白天，其中的自動模式是根據裝置的樣式自動切換，為了達成這個功能，我建立了兩個變數：</p><ul><li>isDarkMode 判斷當時該顯示什麼樣式 （0：白天、1：黑夜）</li><li>colorMode 當時的色彩模式 （0：自動、1：黑夜、2：白天）</li></ul><p>配合 MediaQuery class 取得裝置的色彩模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brightness = MediaQuery.of(context).platformBrightness; <span class="comment">/* 裝置模式 */</span></span><br><span class="line">isDarkMode = (brightness == Brightness.dark &amp;&amp; colorMode == <span class="number">0</span>) || (colorMode == <span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 裝置為黑夜模式且網頁為自動模式 or 網頁為黑夜模式 */</span> </span><br></pre></td></tr></table></figure><p>為了在其他檔案中也能調整 colorMode ，建立 setColorMode 函數，並將其作為參數傳遞給其他檔案，這樣就能在按下按鍵時調整色彩模式。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> setColorMode()&#123;</span><br><span class="line">  setState(() &#123;</span><br><span class="line">    colorMode = (colorMode + <span class="number">1</span>) % <span class="number">3</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>按鍵調整模式：</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Builder(</span><br><span class="line">  builder: (context) =&gt; IconButton(</span><br><span class="line">    <span class="comment">/* 根據模式調整 icon */</span> </span><br><span class="line">    icon: Icon((colorMode == <span class="number">0</span>? Icons.auto_mode:(colorMode == <span class="number">1</span>? Icons.dark_mode:Icons.light_mode)), color: textColor),</span><br><span class="line">    onPressed: ()&#123;</span><br><span class="line">        setState(() &#123;</span><br><span class="line">          widget.setColorMode();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: <span class="string">&quot;顏色模式&quot;</span>,</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1>參考資料</h1><ul><li><a href="https://medium.datadriveninvestor.com/accessing-github-secrets-in-python-d3e758d8089b">Accessing GitHub secrets in Python</a></li><li><a href="https://medium.com/flutter-community/managing-secrets-in-an-open-sourced-flutter-web-app-8c2219ed72b9">Managing secrets in an open-sourced flutter web app</a></li><li><a href="https://blog.csdn.net/a18339063397/article/details/125086853">Flutter Widgets 之 MediaQuery控件獲取屏幕信息</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Project </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flutter </tag>
            
            <tag> 爬蟲 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo建立Blog+魔改心得</title>
      <link href="/2024/04/16/hexo%E5%BB%BA%E7%AB%8Bblog+%E9%AD%94%E6%94%B9%E5%BF%83%E5%BE%97/"/>
      <url>/2024/04/16/hexo%E5%BB%BA%E7%AB%8Bblog+%E9%AD%94%E6%94%B9%E5%BF%83%E5%BE%97/</url>
      
        <content type="html"><![CDATA[<h1>Hexo 簡介</h1><p>Hexo 是一個基於 Node.js 的靜態部落格框架，可以幫助使用者快速搭建並部署個人部落格，主要使用 Markdown 語法來編寫文章，然後透過 Hexo 提供的命令將文章生成靜態網頁，最後部署到伺服器上，且 Hexo 有以下幾個特色：</p><ul><li>使用高效的渲染引擎和緩存機制，生成靜態頁面速度快</li><li>具有豐富主題、插件，可拓展性強</li><li>透過指令可以輕鬆的生成和管理內容</li><li>僅需要使用 Markdown 語法即可邊寫文章，對新手友好</li></ul><h1>安裝與建立</h1><div class="note info flat"><p>詳細安裝過程可以参考： <a href="https://hackmd.io/@Heidi-Liu/note-hexo-github">【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌</a></p></div><h2 id="安裝需求">安裝需求</h2><ul><li><a href="https://nodejs.org/en">Node.js</a></li><li><a href="https://git-scm.com/">git</a></li></ul><h2 id="hexo-安裝">Hexo 安裝</h2><ol><li>安裝完上述軟體之後，在終端機 ( cmd 或 Git Bash ) 中輸入以下指令。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ol start="2"><li>之後可以輸入以下指令確認是否安裝成功。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="項目初始化">項目初始化</h2><ol><li>在目標路徑中打開終端機，輸入以下指令建立項目。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &#123;項目名&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>進入所建立的資料夾，安裝相關的套件。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd &#123;項目名&#125; //進入資料夾</span><br><span class="line">npm i</span><br></pre></td></tr></table></figure><p>這樣就已經完成了項目的初始化了。</p><h2 id="指令">指令</h2><div class="note info flat"><p>更多指令可以参考： <a href="https://hexo.io/zh-tw/docs/commands">指令 | Hexo</a></p></div><ul><li>hexo server：啟動伺服器，啟動後可以在 <a href="http://localhost:4000/">http://localhost:4000/</a> 看到自己的網站</li><li>hexo new {標題} ：建立一篇新的文章(預設為post)</li><li>hexo clean：清除之前建立過的靜態檔案</li><li>hexo generate：生成靜態檔案</li><li>hexo deploy：部署網站</li></ul><h2 id="部署網站到-github">部署網站到 Github</h2><ol><li>在 Github 新增一個 Repository 名稱為 <code>&#123;用戶名&#125;.github.io</code></li><li>在終端機中輸入以下指令，安装 <code>hexo-deployer-git</code></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><ol start="3"><li>修改 <code>_config.yml</code> 文件中的 deploy 設定</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span> </span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:&#123;用戶名&#125;/&#123;用戶名&#125;.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ol start="4"><li>在終端機中輸入指令，部署到 Github (代碼意義可以參考前面)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</span><br></pre></td></tr></table></figure><ol start="5"><li>部署完成後就可以在 https://{用戶名}.github.io 看到自己的網站</li></ol><h1>網頁主題</h1><p>前面有提到過 Hexo 提供了相當多的主題可以使用，首先可以在 <a href="https://hexo.io/themes/">Themes | Hexo</a> 網頁中找到自己喜歡的主題，如本網站使用的主題為 Butterfly 主題，並且閱讀該主題的文檔進行安裝，接著將以 <code>Butterfly</code> 主題作為示範。</p><h2 id="butterfly-主題安裝">Butterfly 主題安裝</h2><ol><li>在終端機中輸入指令，就可以利用 <code>npm</code> 安裝 Butterfly 主題到資料夾內。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>之後就可以在 <code>&#123;資料夾路徑&#125;/node_modules</code> 中找到已經下載完成的 <code>hexo-theme-butterfly</code> 資料夾。</p><ol start="2"><li>修改根目錄資料夾中的 <code>_config.yml</code>，把 theme 改為 butterfly。</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">butterfly</span></span><br></pre></td></tr></table></figure><ol start="3"><li>如果沒有 pug 以及 stylus 的渲染器需要在終端機中輸入以下指令安裝。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure><ol start="4"><li>把 <code>&#123;資料夾路徑&#125;/node_modules/hexo-theme-butterfly</code> 資料夾內的 <code>_config.yml</code> 複製到根目錄中，並且重新命名為 <code>_config.butterfly.yml</code>，記得不要把原本根目錄中的檔案覆蓋掉了，這個新檔案就是這一個主題的配置檔案，可以在其中修改自己想要的設置，而設置的詳細內容可以參考<a href="https://butterfly.js.org/posts/4aa8abbe/">官方文檔</a>，也可以在該網站看到 Butterfly 主題的大致樣式。</li></ol><h1>主題魔改</h1><h2 id="魔改參考">魔改參考</h2><div class="note info flat"><p>主題魔改的部分主要是参考：<a href="https://blog.csdn.net/u014061630/article/details/81359144">博客魔改教程</a>，除了魔改教學之外，在裡面也可以找到基礎的 Butterfly 主題教學。</p></div><div class="note warning flat"><p>部分魔改會修改到 Butterfly 主題的源碼，具有一定風險，修改之前請做好備份。</p></div><p>本網站使用到的魔改有：</p><p><a href="https://www.fomal.cc/posts/eec9786.html">教程一</a></p><ul><li>一圖流：網頁背景和頂部圖合為一體</li><li>文章雙側欄顯示</li><li>自定義字體</li><li>黑夜霓虹燈2.0：標題在黑夜模式會有霓虹燈效果</li></ul><p><a href="https://www.fomal.cc/posts/5389e93f.html">教程二</a></p><ul><li>頁面樣式調節：頁面樣式更為美觀</li><li>漸變色版權美化：美化每篇文章底部的版權區塊</li><li>文章H1~H6標題小風車轉動效果</li></ul><p><a href="https://www.fomal.cc/posts/d739261b.html">教程四</a></p><ul><li>博客寬屏適配：增加空間利用</li><li>頭像呼吸燈：頭像在黑夜模式時周圍會有光效</li></ul><p><a href="https://www.fomal.cc/posts/d1927166.html">教程五</a></p><ul><li>導航欄魔改增強版：使導航欄可以顯示文章名稱以及增加移至頂部功能</li></ul><div class="note info flat"><p>目前使用的 butterfly 主題版本為 <code>4.13.0</code>，部分內容在 <code>5.0.0</code> 以後版本可能會有衝突的情況</p></div><h2 id="魔改心得">魔改心得</h2><p>因為這些魔改教學距離現在也有了約一年的時間，隨著 Butterfly 主題的更新，有部分內容需要微調，以下將說明我在魔改過程中所做的調整。</p><h3 id="導航欄魔改增強版">導航欄魔改增強版</h3><ol><li>重構導航欄：修改 <code>&#123;資料夾路徑&#125;\node_modules\hexo-theme-butterfly\layout\includes\header\nav.pug</code> （因為我沒有修改導航欄的圖標，因此只需要改動以下區塊）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">nav#nav</span><br><span class="line">  span#blog-info</span><br><span class="line">    a#site-name(href=url_for(&#x27;/&#x27;)) #[=config.title]</span><br><span class="line">    </span><br><span class="line">  #menus</span><br><span class="line">    !=partial(&#x27;includes/header/menu_item&#x27;, &#123;&#125;, &#123;cache: true&#125;)</span><br><span class="line">    //- 導航欄顯示標題</span><br><span class="line">    center(id=&quot;name-container&quot;)</span><br><span class="line">      a(id=&quot;page-name&quot; href=&quot;javascript:scrollToTop()&quot;) PAGE_NAME</span><br><span class="line">      </span><br><span class="line">    #nav-right</span><br><span class="line">    if (theme.algolia_search.enable || theme.local_search.enable)</span><br><span class="line">      #search-button</span><br><span class="line">        a.site-page.social-icon.search</span><br><span class="line">          i.fas.fa-search.fa-lg</span><br><span class="line">      #toggle-menu</span><br><span class="line">        a.site-page</span><br><span class="line">          i.fas.fa-bars.fa-fw</span><br></pre></td></tr></table></figure><ol start="2"><li>標題增強：在 <code>custom.css</code> 加入以下代碼，<code>var(--theme-color)</code> 必須改為自己的主題色。</li></ol><div class="note info flat"><p>關於如何新增以及引入 <code>custom.css</code> 可以参考： <a href="https://b.leonus.cn/2022/custom.html">Hexo博客添加自定義css和js文件</a></p></div><div class="note warning flat"><p>在增加了代碼之後，我的 home 圖示卻一直無法正常顯示，在加入了 <code>font-weight: 900</code>; 之後就解決了這個問題。</p></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 標題增強 */</span></span><br><span class="line"><span class="selector-id">#site-name</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--theme-color) <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  -ms-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  -o-<span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  -moz-<span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  -ms-<span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  -o-<span class="attribute">transition</span>: <span class="number">0.3s</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;\f015&quot;</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">5px</span> <span class="built_in">var</span>(--theme-color);</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&quot;Font Awesome 6 Free&quot;</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: <span class="number">900</span>; <span class="comment">/* 新增 */</span></span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">34px</span>; <span class="comment">/*如果有溢出或者垂直不居中的現象微調一下這個參數*/</span></span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>; <span class="comment">/*根據個人喜好*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-name</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">  scale: <span class="number">1.03</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#site-name</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>; <span class="comment">/*一定要把字體調大點，否則效果慘不忍睹！*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>導航欄居中</li></ol><div class="note warning flat"><p>需要在 <code>custom.css</code> 加入以下代碼，讓導航欄居中顯示。</p></div><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*導航欄居中*/</span></span><br><span class="line"><span class="selector-id">#nav</span> <span class="selector-class">.menus_items</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: x-large;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>) <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li>頂欄常駐</li></ol><div class="note warning flat"><p>因為 Butterfly 主題已經將此功能加入，只要在 <code>_config.butterfly.yml</code> 中加入此代碼就可以將頂欄常駐。</p></div><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 頂部欄</span></span><br><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment">#image</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">true</span> <span class="comment"># fixed navigation bar</span></span><br></pre></td></tr></table></figure><ol start="5"><li>顯示標題：<code>新建&#123;資料夾路徑&#125;\source\js\nav.js</code>，加入以下代碼：</li></ol><div class="note warning flat"><p>在這邊必須先引入 jquery，可以參考 <a href="https://yisous.xyz/posts/583ff077/">Hexo Butterfly博客魔改的一點點基礎</a>，之後也別忘了在 <code>_config.butterfly.yml</code> 中引入剛剛新增的 <code>nav.js</code> 檔案</p></div><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> position = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line"></span><br><span class="line">$(<span class="variable language_">window</span>).<span class="title function_">scroll</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> scroll = $(<span class="variable language_">window</span>).<span class="title function_">scrollTop</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (scroll &gt; position) &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none!important&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>, <span class="string">&quot;display:none&quot;</span>);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  position = scroll;</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">scrollToTop</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementsByClassName</span>(<span class="string">&quot;menus_items&quot;</span>)[<span class="number">1</span>].<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;name-container&quot;</span>).<span class="title function_">setAttribute</span>(<span class="string">&quot;style&quot;</span>,<span class="string">&quot;display:none&quot;</span>);</span><br><span class="line">    btf.<span class="title function_">scrollToDest</span>(<span class="number">0</span>, <span class="number">500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&quot;page-name&quot;</span>).<span class="property">innerText</span> = <span class="variable language_">document</span>.<span class="property">title</span>.<span class="title function_">split</span>(<span class="string">&quot; | douobb&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*這裡是去掉你的網站名稱的设置，如果你不需要去掉，你可以寫成：</span></span><br><span class="line"><span class="comment">document.getElementById(&quot;page-name&quot;).innerText=document.title</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>完成以上配置之後，<code>_config.butterfly.yml</code> 的 inject 應該會是這個樣子，分別引入了 <code>custom.css</code>、<code>jquery.min.js</code> 以及 <code>nav.js</code>，注意 <code>jquery.min.js</code> 必須在 <code>nav.js</code> 之前引入。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">inject:</span></span><br><span class="line">  <span class="attr">head:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;link</span> <span class="string">rel=&quot;stylesheet&quot;</span> <span class="string">href=&quot;/css/custom.css&quot;</span> <span class="string">media=&quot;defer&quot;</span> <span class="string">onload=&quot;this.media=&#x27;all&#x27;&quot;&gt;</span></span><br><span class="line">  <span class="attr">bottom:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/jquery.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">&lt;script</span> <span class="string">data-pjax</span> <span class="string">type=&quot;text/javascript&quot;</span> <span class="string">src=&quot;/js/nav.js&quot;&gt;&lt;/script&gt;</span></span><br></pre></td></tr></table></figure><p>且 <code>&#123;資料夾路徑&#125;\source</code> 資料夾內會多出以下檔案</p><ul><li><code>css/custom.css</code></li><li><code>js/jquery.min.js</code></li><li><code>js/nav.js</code></li></ul><ol start="6"><li>最後回到 <code>custom.css</code> 添加以下代碼，<code>var(--theme-color)</code> 必須改為自己的主題色。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 導航欄顯示標題 */</span></span><br><span class="line"><span class="selector-id">#page-name</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">color</span>: white <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;回到頂部&quot;</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">var</span>(--theme-color);</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -moz-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -ms-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -o-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> <span class="number">3px</span> <span class="built_in">var</span>(--theme-color);</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">45px</span>; <span class="comment">/*如果垂直位置不居中可以微调此值，也可以删了*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page-name</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#name-container</span> &#123;</span><br><span class="line">  <span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -webkit-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -moz-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -ms-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">  -o-<span class="attribute">transition</span>: all <span class="number">0.3s</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#name-container</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  scale: <span class="number">1.03</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#page-name</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">30px</span>; <span class="comment">/*如果文字间隔不合理可以微调修改，第二个是水平方向的padding，第一个是垂直的*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#nav</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修复滾動顯示標題居中 */</span></span><br><span class="line">center<span class="selector-id">#name-container</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">width</span>: fit-content <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">42%</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">768px</span>) &#123;</span><br><span class="line">  center<span class="selector-id">#name-container</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="7"><li>這樣就完成了導航欄的魔改。</li></ol><h3 id="右下角選單調整">右下角選單調整</h3><ol><li>在 <code>custom.css</code> 添加以下代碼可以將選單設為不透明，也可以調整為其他透明度。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#rightside</span><span class="selector-class">.rightside-show</span> &#123;</span><br><span class="line">  <span class="attribute">opacity</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>在 <code>custom.css</code> 添加以下代碼可以調整圖形以及文字大小。</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#rightside</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">button</span>,</span><br><span class="line"><span class="selector-id">#rightside</span> &gt; <span class="selector-tag">div</span> &gt; <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">40px</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">18px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文章標題置中">文章標題置中</h3><p>在 <code>custom.css</code> 添加以下代碼可以將文章標題置中，也可以微調調整上下位置。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 文章標題置中 */</span></span><br><span class="line"><span class="selector-id">#post-info</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">55%</span>; <span class="comment">/* 可微調上下 */</span></span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateY</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-class">.post-title</span>&#123;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#post-meta</span>&#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">width</span>: fit-content;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateX</span>(-<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>參考資料</h1><ul><li><a href="https://hackmd.io/@Heidi-Liu/note-hexo-github">【學習筆記】如何使用 Hexo + GitHub Pages 架設個人網誌</a></li><li><a href="https://hexo.io/zh-tw/">Hexo</a></li><li><a href="https://hexo.io/zh-tw/docs/commands">指令 | Hexo</a></li><li><a href="https://blog.csdn.net/u014061630/article/details/81359144">博客魔改教程</a></li><li><a href="https://b.leonus.cn/2022/custom.html">Hexo博客添加自定義css和js文件</a></li><li><a href="https://yisous.xyz/posts/583ff077/">Hexo Butterfly博客魔改的一點點基礎</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Blog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
